// Copyright 2015-2026 The Khronos Group Inc.
//
// SPDX-License-Identifier: Apache-2.0 OR MIT
//

// This header is generated from the Khronos Vulkan XML API Registry.

#ifndef VULKAN_HANDLES_HPP
#define VULKAN_HANDLES_HPP

// include-what-you-use: make sure, vulkan.hpp is used by code-completers
// IWYU pragma: private, include "vulkan/vulkan.hpp"

VULKAN_HPP_EXPORT namespace VULKAN_HPP_NAMESPACE
{
  //===================================
  //=== STRUCT forward declarations ===
  //===================================

  //=== VK_VERSION_1_0 ===
  struct Extent2D;
  struct Extent3D;
  struct Offset2D;
  struct Offset3D;
  struct Rect2D;
  struct BaseInStructure;
  struct BaseOutStructure;
  struct BufferMemoryBarrier;
  struct ImageMemoryBarrier;
  struct MemoryBarrier;
  struct AllocationCallbacks;
  struct ApplicationInfo;
  struct FormatProperties;
  struct ImageFormatProperties;
  struct InstanceCreateInfo;
  struct MemoryHeap;
  struct MemoryType;
  struct PhysicalDeviceFeatures;
  struct PhysicalDeviceLimits;
  struct PhysicalDeviceMemoryProperties;
  struct PhysicalDeviceProperties;
  struct PhysicalDeviceSparseProperties;
  struct QueueFamilyProperties;
  struct DeviceCreateInfo;
  struct DeviceQueueCreateInfo;
  struct ExtensionProperties;
  struct LayerProperties;
  struct SubmitInfo;
  struct MappedMemoryRange;
  struct MemoryAllocateInfo;
  struct MemoryRequirements;
  struct BindSparseInfo;
  struct ImageSubresource;
  struct SparseBufferMemoryBindInfo;
  struct SparseImageFormatProperties;
  struct SparseImageMemoryBind;
  struct SparseImageMemoryBindInfo;
  struct SparseImageMemoryRequirements;
  struct SparseImageOpaqueMemoryBindInfo;
  struct SparseMemoryBind;
  struct FenceCreateInfo;
  struct SemaphoreCreateInfo;
  struct QueryPoolCreateInfo;
  struct BufferCreateInfo;
  struct ImageCreateInfo;
  struct SubresourceLayout;
  struct ComponentMapping;
  struct ImageSubresourceRange;
  struct ImageViewCreateInfo;
  struct CommandPoolCreateInfo;
  struct CommandBufferAllocateInfo;
  struct CommandBufferBeginInfo;
  struct CommandBufferInheritanceInfo;
  struct BufferCopy;
  struct BufferImageCopy;
  struct ImageCopy;
  struct ImageSubresourceLayers;
  struct DispatchIndirectCommand;
  struct PipelineCacheHeaderVersionOne;
  struct EventCreateInfo;
  struct BufferViewCreateInfo;
  struct ShaderModuleCreateInfo;
  struct PipelineCacheCreateInfo;
  struct ComputePipelineCreateInfo;
  struct PipelineShaderStageCreateInfo;
  struct SpecializationInfo;
  struct SpecializationMapEntry;
  struct PipelineLayoutCreateInfo;
  struct PushConstantRange;
  struct SamplerCreateInfo;
  struct CopyDescriptorSet;
  struct DescriptorBufferInfo;
  struct DescriptorImageInfo;
  struct DescriptorPoolCreateInfo;
  struct DescriptorPoolSize;
  struct DescriptorSetAllocateInfo;
  struct DescriptorSetLayoutBinding;
  struct DescriptorSetLayoutCreateInfo;
  struct WriteDescriptorSet;
  union ClearColorValue;
  struct DrawIndexedIndirectCommand;
  struct DrawIndirectCommand;
  struct GraphicsPipelineCreateInfo;
  struct PipelineColorBlendAttachmentState;
  struct PipelineColorBlendStateCreateInfo;
  struct PipelineDepthStencilStateCreateInfo;
  struct PipelineDynamicStateCreateInfo;
  struct PipelineInputAssemblyStateCreateInfo;
  struct PipelineMultisampleStateCreateInfo;
  struct PipelineRasterizationStateCreateInfo;
  struct PipelineTessellationStateCreateInfo;
  struct PipelineVertexInputStateCreateInfo;
  struct PipelineViewportStateCreateInfo;
  struct StencilOpState;
  struct VertexInputAttributeDescription;
  struct VertexInputBindingDescription;
  struct Viewport;
  struct AttachmentDescription;
  struct AttachmentReference;
  struct FramebufferCreateInfo;
  struct RenderPassCreateInfo;
  struct SubpassDependency;
  struct SubpassDescription;
  struct ClearAttachment;
  struct ClearDepthStencilValue;
  struct ClearRect;
  union ClearValue;
  struct ImageBlit;
  struct ImageResolve;
  struct RenderPassBeginInfo;

  //=== VK_VERSION_1_1 ===
  struct BindBufferMemoryInfo;
  using BindBufferMemoryInfoKHR = BindBufferMemoryInfo;
  struct BindImageMemoryInfo;
  using BindImageMemoryInfoKHR = BindImageMemoryInfo;
  struct MemoryDedicatedRequirements;
  using MemoryDedicatedRequirementsKHR = MemoryDedicatedRequirements;
  struct MemoryDedicatedAllocateInfo;
  using MemoryDedicatedAllocateInfoKHR = MemoryDedicatedAllocateInfo;
  struct MemoryAllocateFlagsInfo;
  using MemoryAllocateFlagsInfoKHR = MemoryAllocateFlagsInfo;
  struct DeviceGroupCommandBufferBeginInfo;
  using DeviceGroupCommandBufferBeginInfoKHR = DeviceGroupCommandBufferBeginInfo;
  struct DeviceGroupSubmitInfo;
  using DeviceGroupSubmitInfoKHR = DeviceGroupSubmitInfo;
  struct DeviceGroupBindSparseInfo;
  using DeviceGroupBindSparseInfoKHR = DeviceGroupBindSparseInfo;
  struct BindBufferMemoryDeviceGroupInfo;
  using BindBufferMemoryDeviceGroupInfoKHR = BindBufferMemoryDeviceGroupInfo;
  struct BindImageMemoryDeviceGroupInfo;
  using BindImageMemoryDeviceGroupInfoKHR = BindImageMemoryDeviceGroupInfo;
  struct PhysicalDeviceGroupProperties;
  using PhysicalDeviceGroupPropertiesKHR = PhysicalDeviceGroupProperties;
  struct DeviceGroupDeviceCreateInfo;
  using DeviceGroupDeviceCreateInfoKHR = DeviceGroupDeviceCreateInfo;
  struct BufferMemoryRequirementsInfo2;
  using BufferMemoryRequirementsInfo2KHR = BufferMemoryRequirementsInfo2;
  struct ImageMemoryRequirementsInfo2;
  using ImageMemoryRequirementsInfo2KHR = ImageMemoryRequirementsInfo2;
  struct ImageSparseMemoryRequirementsInfo2;
  using ImageSparseMemoryRequirementsInfo2KHR = ImageSparseMemoryRequirementsInfo2;
  struct MemoryRequirements2;
  using MemoryRequirements2KHR = MemoryRequirements2;
  struct SparseImageMemoryRequirements2;
  using SparseImageMemoryRequirements2KHR = SparseImageMemoryRequirements2;
  struct PhysicalDeviceFeatures2;
  using PhysicalDeviceFeatures2KHR = PhysicalDeviceFeatures2;
  struct PhysicalDeviceProperties2;
  using PhysicalDeviceProperties2KHR = PhysicalDeviceProperties2;
  struct FormatProperties2;
  using FormatProperties2KHR = FormatProperties2;
  struct ImageFormatProperties2;
  using ImageFormatProperties2KHR = ImageFormatProperties2;
  struct PhysicalDeviceImageFormatInfo2;
  using PhysicalDeviceImageFormatInfo2KHR = PhysicalDeviceImageFormatInfo2;
  struct QueueFamilyProperties2;
  using QueueFamilyProperties2KHR = QueueFamilyProperties2;
  struct PhysicalDeviceMemoryProperties2;
  using PhysicalDeviceMemoryProperties2KHR = PhysicalDeviceMemoryProperties2;
  struct SparseImageFormatProperties2;
  using SparseImageFormatProperties2KHR = SparseImageFormatProperties2;
  struct PhysicalDeviceSparseImageFormatInfo2;
  using PhysicalDeviceSparseImageFormatInfo2KHR = PhysicalDeviceSparseImageFormatInfo2;
  struct ImageViewUsageCreateInfo;
  using ImageViewUsageCreateInfoKHR = ImageViewUsageCreateInfo;
  struct PhysicalDeviceProtectedMemoryFeatures;
  struct PhysicalDeviceProtectedMemoryProperties;
  struct DeviceQueueInfo2;
  struct ProtectedSubmitInfo;
  struct BindImagePlaneMemoryInfo;
  using BindImagePlaneMemoryInfoKHR = BindImagePlaneMemoryInfo;
  struct ImagePlaneMemoryRequirementsInfo;
  using ImagePlaneMemoryRequirementsInfoKHR = ImagePlaneMemoryRequirementsInfo;
  struct ExternalMemoryProperties;
  using ExternalMemoryPropertiesKHR = ExternalMemoryProperties;
  struct PhysicalDeviceExternalImageFormatInfo;
  using PhysicalDeviceExternalImageFormatInfoKHR = PhysicalDeviceExternalImageFormatInfo;
  struct ExternalImageFormatProperties;
  using ExternalImageFormatPropertiesKHR = ExternalImageFormatProperties;
  struct PhysicalDeviceExternalBufferInfo;
  using PhysicalDeviceExternalBufferInfoKHR = PhysicalDeviceExternalBufferInfo;
  struct ExternalBufferProperties;
  using ExternalBufferPropertiesKHR = ExternalBufferProperties;
  struct PhysicalDeviceIDProperties;
  using PhysicalDeviceIDPropertiesKHR = PhysicalDeviceIDProperties;
  struct ExternalMemoryImageCreateInfo;
  using ExternalMemoryImageCreateInfoKHR = ExternalMemoryImageCreateInfo;
  struct ExternalMemoryBufferCreateInfo;
  using ExternalMemoryBufferCreateInfoKHR = ExternalMemoryBufferCreateInfo;
  struct ExportMemoryAllocateInfo;
  using ExportMemoryAllocateInfoKHR = ExportMemoryAllocateInfo;
  struct PhysicalDeviceExternalFenceInfo;
  using PhysicalDeviceExternalFenceInfoKHR = PhysicalDeviceExternalFenceInfo;
  struct ExternalFenceProperties;
  using ExternalFencePropertiesKHR = ExternalFenceProperties;
  struct ExportFenceCreateInfo;
  using ExportFenceCreateInfoKHR = ExportFenceCreateInfo;
  struct ExportSemaphoreCreateInfo;
  using ExportSemaphoreCreateInfoKHR = ExportSemaphoreCreateInfo;
  struct PhysicalDeviceExternalSemaphoreInfo;
  using PhysicalDeviceExternalSemaphoreInfoKHR = PhysicalDeviceExternalSemaphoreInfo;
  struct ExternalSemaphoreProperties;
  using ExternalSemaphorePropertiesKHR = ExternalSemaphoreProperties;
  struct PhysicalDeviceSubgroupProperties;
  struct PhysicalDevice16BitStorageFeatures;
  using PhysicalDevice16BitStorageFeaturesKHR = PhysicalDevice16BitStorageFeatures;
  struct PhysicalDeviceVariablePointersFeatures;
  using PhysicalDeviceVariablePointerFeatures     = PhysicalDeviceVariablePointersFeatures;
  using PhysicalDeviceVariablePointerFeaturesKHR  = PhysicalDeviceVariablePointersFeatures;
  using PhysicalDeviceVariablePointersFeaturesKHR = PhysicalDeviceVariablePointersFeatures;
  struct DescriptorUpdateTemplateEntry;
  using DescriptorUpdateTemplateEntryKHR = DescriptorUpdateTemplateEntry;
  struct DescriptorUpdateTemplateCreateInfo;
  using DescriptorUpdateTemplateCreateInfoKHR = DescriptorUpdateTemplateCreateInfo;
  struct PhysicalDeviceMaintenance3Properties;
  using PhysicalDeviceMaintenance3PropertiesKHR = PhysicalDeviceMaintenance3Properties;
  struct DescriptorSetLayoutSupport;
  using DescriptorSetLayoutSupportKHR = DescriptorSetLayoutSupport;
  struct SamplerYcbcrConversionCreateInfo;
  using SamplerYcbcrConversionCreateInfoKHR = SamplerYcbcrConversionCreateInfo;
  struct SamplerYcbcrConversionInfo;
  using SamplerYcbcrConversionInfoKHR = SamplerYcbcrConversionInfo;
  struct PhysicalDeviceSamplerYcbcrConversionFeatures;
  using PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = PhysicalDeviceSamplerYcbcrConversionFeatures;
  struct SamplerYcbcrConversionImageFormatProperties;
  using SamplerYcbcrConversionImageFormatPropertiesKHR = SamplerYcbcrConversionImageFormatProperties;
  struct DeviceGroupRenderPassBeginInfo;
  using DeviceGroupRenderPassBeginInfoKHR = DeviceGroupRenderPassBeginInfo;
  struct PhysicalDevicePointClippingProperties;
  using PhysicalDevicePointClippingPropertiesKHR = PhysicalDevicePointClippingProperties;
  struct RenderPassInputAttachmentAspectCreateInfo;
  using RenderPassInputAttachmentAspectCreateInfoKHR = RenderPassInputAttachmentAspectCreateInfo;
  struct InputAttachmentAspectReference;
  using InputAttachmentAspectReferenceKHR = InputAttachmentAspectReference;
  struct PipelineTessellationDomainOriginStateCreateInfo;
  using PipelineTessellationDomainOriginStateCreateInfoKHR = PipelineTessellationDomainOriginStateCreateInfo;
  struct RenderPassMultiviewCreateInfo;
  using RenderPassMultiviewCreateInfoKHR = RenderPassMultiviewCreateInfo;
  struct PhysicalDeviceMultiviewFeatures;
  using PhysicalDeviceMultiviewFeaturesKHR = PhysicalDeviceMultiviewFeatures;
  struct PhysicalDeviceMultiviewProperties;
  using PhysicalDeviceMultiviewPropertiesKHR = PhysicalDeviceMultiviewProperties;
  struct PhysicalDeviceShaderDrawParametersFeatures;
  using PhysicalDeviceShaderDrawParameterFeatures = PhysicalDeviceShaderDrawParametersFeatures;

  //=== VK_VERSION_1_2 ===
  struct PhysicalDeviceVulkan11Features;
  struct PhysicalDeviceVulkan11Properties;
  struct PhysicalDeviceVulkan12Features;
  struct PhysicalDeviceVulkan12Properties;
  struct ImageFormatListCreateInfo;
  using ImageFormatListCreateInfoKHR = ImageFormatListCreateInfo;
  struct ConformanceVersion;
  using ConformanceVersionKHR = ConformanceVersion;
  struct PhysicalDeviceDriverProperties;
  using PhysicalDeviceDriverPropertiesKHR = PhysicalDeviceDriverProperties;
  struct PhysicalDeviceVulkanMemoryModelFeatures;
  using PhysicalDeviceVulkanMemoryModelFeaturesKHR = PhysicalDeviceVulkanMemoryModelFeatures;
  struct PhysicalDeviceHostQueryResetFeatures;
  using PhysicalDeviceHostQueryResetFeaturesEXT = PhysicalDeviceHostQueryResetFeatures;
  struct PhysicalDeviceTimelineSemaphoreFeatures;
  using PhysicalDeviceTimelineSemaphoreFeaturesKHR = PhysicalDeviceTimelineSemaphoreFeatures;
  struct PhysicalDeviceTimelineSemaphoreProperties;
  using PhysicalDeviceTimelineSemaphorePropertiesKHR = PhysicalDeviceTimelineSemaphoreProperties;
  struct SemaphoreTypeCreateInfo;
  using SemaphoreTypeCreateInfoKHR = SemaphoreTypeCreateInfo;
  struct TimelineSemaphoreSubmitInfo;
  using TimelineSemaphoreSubmitInfoKHR = TimelineSemaphoreSubmitInfo;
  struct SemaphoreWaitInfo;
  using SemaphoreWaitInfoKHR = SemaphoreWaitInfo;
  struct SemaphoreSignalInfo;
  using SemaphoreSignalInfoKHR = SemaphoreSignalInfo;
  struct PhysicalDeviceBufferDeviceAddressFeatures;
  using PhysicalDeviceBufferDeviceAddressFeaturesKHR = PhysicalDeviceBufferDeviceAddressFeatures;
  struct BufferDeviceAddressInfo;
  using BufferDeviceAddressInfoEXT = BufferDeviceAddressInfo;
  using BufferDeviceAddressInfoKHR = BufferDeviceAddressInfo;
  struct BufferOpaqueCaptureAddressCreateInfo;
  using BufferOpaqueCaptureAddressCreateInfoKHR = BufferOpaqueCaptureAddressCreateInfo;
  struct MemoryOpaqueCaptureAddressAllocateInfo;
  using MemoryOpaqueCaptureAddressAllocateInfoKHR = MemoryOpaqueCaptureAddressAllocateInfo;
  struct DeviceMemoryOpaqueCaptureAddressInfo;
  using DeviceMemoryOpaqueCaptureAddressInfoKHR = DeviceMemoryOpaqueCaptureAddressInfo;
  struct PhysicalDevice8BitStorageFeatures;
  using PhysicalDevice8BitStorageFeaturesKHR = PhysicalDevice8BitStorageFeatures;
  struct PhysicalDeviceShaderAtomicInt64Features;
  using PhysicalDeviceShaderAtomicInt64FeaturesKHR = PhysicalDeviceShaderAtomicInt64Features;
  struct PhysicalDeviceShaderFloat16Int8Features;
  using PhysicalDeviceFloat16Int8FeaturesKHR       = PhysicalDeviceShaderFloat16Int8Features;
  using PhysicalDeviceShaderFloat16Int8FeaturesKHR = PhysicalDeviceShaderFloat16Int8Features;
  struct PhysicalDeviceFloatControlsProperties;
  using PhysicalDeviceFloatControlsPropertiesKHR = PhysicalDeviceFloatControlsProperties;
  struct DescriptorSetLayoutBindingFlagsCreateInfo;
  using DescriptorSetLayoutBindingFlagsCreateInfoEXT = DescriptorSetLayoutBindingFlagsCreateInfo;
  struct PhysicalDeviceDescriptorIndexingFeatures;
  using PhysicalDeviceDescriptorIndexingFeaturesEXT = PhysicalDeviceDescriptorIndexingFeatures;
  struct PhysicalDeviceDescriptorIndexingProperties;
  using PhysicalDeviceDescriptorIndexingPropertiesEXT = PhysicalDeviceDescriptorIndexingProperties;
  struct DescriptorSetVariableDescriptorCountAllocateInfo;
  using DescriptorSetVariableDescriptorCountAllocateInfoEXT = DescriptorSetVariableDescriptorCountAllocateInfo;
  struct DescriptorSetVariableDescriptorCountLayoutSupport;
  using DescriptorSetVariableDescriptorCountLayoutSupportEXT = DescriptorSetVariableDescriptorCountLayoutSupport;
  struct PhysicalDeviceScalarBlockLayoutFeatures;
  using PhysicalDeviceScalarBlockLayoutFeaturesEXT = PhysicalDeviceScalarBlockLayoutFeatures;
  struct SamplerReductionModeCreateInfo;
  using SamplerReductionModeCreateInfoEXT = SamplerReductionModeCreateInfo;
  struct PhysicalDeviceSamplerFilterMinmaxProperties;
  using PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = PhysicalDeviceSamplerFilterMinmaxProperties;
  struct PhysicalDeviceUniformBufferStandardLayoutFeatures;
  using PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = PhysicalDeviceUniformBufferStandardLayoutFeatures;
  struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
  using PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
  struct RenderPassCreateInfo2;
  using RenderPassCreateInfo2KHR = RenderPassCreateInfo2;
  struct AttachmentDescription2;
  using AttachmentDescription2KHR = AttachmentDescription2;
  struct AttachmentReference2;
  using AttachmentReference2KHR = AttachmentReference2;
  struct SubpassDescription2;
  using SubpassDescription2KHR = SubpassDescription2;
  struct SubpassDependency2;
  using SubpassDependency2KHR = SubpassDependency2;
  struct SubpassBeginInfo;
  using SubpassBeginInfoKHR = SubpassBeginInfo;
  struct SubpassEndInfo;
  using SubpassEndInfoKHR = SubpassEndInfo;
  struct SubpassDescriptionDepthStencilResolve;
  using SubpassDescriptionDepthStencilResolveKHR = SubpassDescriptionDepthStencilResolve;
  struct PhysicalDeviceDepthStencilResolveProperties;
  using PhysicalDeviceDepthStencilResolvePropertiesKHR = PhysicalDeviceDepthStencilResolveProperties;
  struct ImageStencilUsageCreateInfo;
  using ImageStencilUsageCreateInfoEXT = ImageStencilUsageCreateInfo;
  struct PhysicalDeviceImagelessFramebufferFeatures;
  using PhysicalDeviceImagelessFramebufferFeaturesKHR = PhysicalDeviceImagelessFramebufferFeatures;
  struct FramebufferAttachmentsCreateInfo;
  using FramebufferAttachmentsCreateInfoKHR = FramebufferAttachmentsCreateInfo;
  struct FramebufferAttachmentImageInfo;
  using FramebufferAttachmentImageInfoKHR = FramebufferAttachmentImageInfo;
  struct RenderPassAttachmentBeginInfo;
  using RenderPassAttachmentBeginInfoKHR = RenderPassAttachmentBeginInfo;
  struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
  using PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
  struct AttachmentReferenceStencilLayout;
  using AttachmentReferenceStencilLayoutKHR = AttachmentReferenceStencilLayout;
  struct AttachmentDescriptionStencilLayout;
  using AttachmentDescriptionStencilLayoutKHR = AttachmentDescriptionStencilLayout;

  //=== VK_VERSION_1_3 ===
  struct PhysicalDeviceVulkan13Features;
  struct PhysicalDeviceVulkan13Properties;
  struct PhysicalDeviceToolProperties;
  using PhysicalDeviceToolPropertiesEXT = PhysicalDeviceToolProperties;
  struct PhysicalDevicePrivateDataFeatures;
  using PhysicalDevicePrivateDataFeaturesEXT = PhysicalDevicePrivateDataFeatures;
  struct DevicePrivateDataCreateInfo;
  using DevicePrivateDataCreateInfoEXT = DevicePrivateDataCreateInfo;
  struct PrivateDataSlotCreateInfo;
  using PrivateDataSlotCreateInfoEXT = PrivateDataSlotCreateInfo;
  struct MemoryBarrier2;
  using MemoryBarrier2KHR = MemoryBarrier2;
  struct BufferMemoryBarrier2;
  using BufferMemoryBarrier2KHR = BufferMemoryBarrier2;
  struct ImageMemoryBarrier2;
  using ImageMemoryBarrier2KHR = ImageMemoryBarrier2;
  struct DependencyInfo;
  using DependencyInfoKHR = DependencyInfo;
  struct SubmitInfo2;
  using SubmitInfo2KHR = SubmitInfo2;
  struct SemaphoreSubmitInfo;
  using SemaphoreSubmitInfoKHR = SemaphoreSubmitInfo;
  struct CommandBufferSubmitInfo;
  using CommandBufferSubmitInfoKHR = CommandBufferSubmitInfo;
  struct PhysicalDeviceSynchronization2Features;
  using PhysicalDeviceSynchronization2FeaturesKHR = PhysicalDeviceSynchronization2Features;
  struct CopyBufferInfo2;
  using CopyBufferInfo2KHR = CopyBufferInfo2;
  struct CopyImageInfo2;
  using CopyImageInfo2KHR = CopyImageInfo2;
  struct CopyBufferToImageInfo2;
  using CopyBufferToImageInfo2KHR = CopyBufferToImageInfo2;
  struct CopyImageToBufferInfo2;
  using CopyImageToBufferInfo2KHR = CopyImageToBufferInfo2;
  struct BufferCopy2;
  using BufferCopy2KHR = BufferCopy2;
  struct ImageCopy2;
  using ImageCopy2KHR = ImageCopy2;
  struct BufferImageCopy2;
  using BufferImageCopy2KHR = BufferImageCopy2;
  struct PhysicalDeviceTextureCompressionASTCHDRFeatures;
  using PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = PhysicalDeviceTextureCompressionASTCHDRFeatures;
  struct FormatProperties3;
  using FormatProperties3KHR = FormatProperties3;
  struct PhysicalDeviceMaintenance4Features;
  using PhysicalDeviceMaintenance4FeaturesKHR = PhysicalDeviceMaintenance4Features;
  struct PhysicalDeviceMaintenance4Properties;
  using PhysicalDeviceMaintenance4PropertiesKHR = PhysicalDeviceMaintenance4Properties;
  struct DeviceBufferMemoryRequirements;
  using DeviceBufferMemoryRequirementsKHR = DeviceBufferMemoryRequirements;
  struct DeviceImageMemoryRequirements;
  using DeviceImageMemoryRequirementsKHR = DeviceImageMemoryRequirements;
  struct PipelineCreationFeedbackCreateInfo;
  using PipelineCreationFeedbackCreateInfoEXT = PipelineCreationFeedbackCreateInfo;
  struct PipelineCreationFeedback;
  using PipelineCreationFeedbackEXT = PipelineCreationFeedback;
  struct PhysicalDeviceShaderTerminateInvocationFeatures;
  using PhysicalDeviceShaderTerminateInvocationFeaturesKHR = PhysicalDeviceShaderTerminateInvocationFeatures;
  struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
  using PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
  struct PhysicalDevicePipelineCreationCacheControlFeatures;
  using PhysicalDevicePipelineCreationCacheControlFeaturesEXT = PhysicalDevicePipelineCreationCacheControlFeatures;
  struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
  using PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
  struct PhysicalDeviceImageRobustnessFeatures;
  using PhysicalDeviceImageRobustnessFeaturesEXT = PhysicalDeviceImageRobustnessFeatures;
  struct PhysicalDeviceSubgroupSizeControlFeatures;
  using PhysicalDeviceSubgroupSizeControlFeaturesEXT = PhysicalDeviceSubgroupSizeControlFeatures;
  struct PhysicalDeviceSubgroupSizeControlProperties;
  using PhysicalDeviceSubgroupSizeControlPropertiesEXT = PhysicalDeviceSubgroupSizeControlProperties;
  struct PipelineShaderStageRequiredSubgroupSizeCreateInfo;
  using PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
  using ShaderRequiredSubgroupSizeCreateInfoEXT              = PipelineShaderStageRequiredSubgroupSizeCreateInfo;
  struct PhysicalDeviceInlineUniformBlockFeatures;
  using PhysicalDeviceInlineUniformBlockFeaturesEXT = PhysicalDeviceInlineUniformBlockFeatures;
  struct PhysicalDeviceInlineUniformBlockProperties;
  using PhysicalDeviceInlineUniformBlockPropertiesEXT = PhysicalDeviceInlineUniformBlockProperties;
  struct WriteDescriptorSetInlineUniformBlock;
  using WriteDescriptorSetInlineUniformBlockEXT = WriteDescriptorSetInlineUniformBlock;
  struct DescriptorPoolInlineUniformBlockCreateInfo;
  using DescriptorPoolInlineUniformBlockCreateInfoEXT = DescriptorPoolInlineUniformBlockCreateInfo;
  struct PhysicalDeviceShaderIntegerDotProductFeatures;
  using PhysicalDeviceShaderIntegerDotProductFeaturesKHR = PhysicalDeviceShaderIntegerDotProductFeatures;
  struct PhysicalDeviceShaderIntegerDotProductProperties;
  using PhysicalDeviceShaderIntegerDotProductPropertiesKHR = PhysicalDeviceShaderIntegerDotProductProperties;
  struct PhysicalDeviceTexelBufferAlignmentProperties;
  using PhysicalDeviceTexelBufferAlignmentPropertiesEXT = PhysicalDeviceTexelBufferAlignmentProperties;
  struct BlitImageInfo2;
  using BlitImageInfo2KHR = BlitImageInfo2;
  struct ImageBlit2;
  using ImageBlit2KHR = ImageBlit2;
  struct ResolveImageInfo2;
  using ResolveImageInfo2KHR = ResolveImageInfo2;
  struct ImageResolve2;
  using ImageResolve2KHR = ImageResolve2;
  struct RenderingInfo;
  using RenderingInfoKHR = RenderingInfo;
  struct RenderingAttachmentInfo;
  using RenderingAttachmentInfoKHR = RenderingAttachmentInfo;
  struct PipelineRenderingCreateInfo;
  using PipelineRenderingCreateInfoKHR = PipelineRenderingCreateInfo;
  struct PhysicalDeviceDynamicRenderingFeatures;
  using PhysicalDeviceDynamicRenderingFeaturesKHR = PhysicalDeviceDynamicRenderingFeatures;
  struct CommandBufferInheritanceRenderingInfo;
  using CommandBufferInheritanceRenderingInfoKHR = CommandBufferInheritanceRenderingInfo;

  //=== VK_VERSION_1_4 ===
  struct PhysicalDeviceVulkan14Features;
  struct PhysicalDeviceVulkan14Properties;
  struct DeviceQueueGlobalPriorityCreateInfo;
  using DeviceQueueGlobalPriorityCreateInfoEXT = DeviceQueueGlobalPriorityCreateInfo;
  using DeviceQueueGlobalPriorityCreateInfoKHR = DeviceQueueGlobalPriorityCreateInfo;
  struct PhysicalDeviceGlobalPriorityQueryFeatures;
  using PhysicalDeviceGlobalPriorityQueryFeaturesEXT = PhysicalDeviceGlobalPriorityQueryFeatures;
  using PhysicalDeviceGlobalPriorityQueryFeaturesKHR = PhysicalDeviceGlobalPriorityQueryFeatures;
  struct QueueFamilyGlobalPriorityProperties;
  using QueueFamilyGlobalPriorityPropertiesEXT = QueueFamilyGlobalPriorityProperties;
  using QueueFamilyGlobalPriorityPropertiesKHR = QueueFamilyGlobalPriorityProperties;
  struct PhysicalDeviceIndexTypeUint8Features;
  using PhysicalDeviceIndexTypeUint8FeaturesEXT = PhysicalDeviceIndexTypeUint8Features;
  using PhysicalDeviceIndexTypeUint8FeaturesKHR = PhysicalDeviceIndexTypeUint8Features;
  struct MemoryMapInfo;
  using MemoryMapInfoKHR = MemoryMapInfo;
  struct MemoryUnmapInfo;
  using MemoryUnmapInfoKHR = MemoryUnmapInfo;
  struct PhysicalDeviceMaintenance5Features;
  using PhysicalDeviceMaintenance5FeaturesKHR = PhysicalDeviceMaintenance5Features;
  struct PhysicalDeviceMaintenance5Properties;
  using PhysicalDeviceMaintenance5PropertiesKHR = PhysicalDeviceMaintenance5Properties;
  struct DeviceImageSubresourceInfo;
  using DeviceImageSubresourceInfoKHR = DeviceImageSubresourceInfo;
  struct ImageSubresource2;
  using ImageSubresource2EXT = ImageSubresource2;
  using ImageSubresource2KHR = ImageSubresource2;
  struct SubresourceLayout2;
  using SubresourceLayout2EXT = SubresourceLayout2;
  using SubresourceLayout2KHR = SubresourceLayout2;
  struct BufferUsageFlags2CreateInfo;
  using BufferUsageFlags2CreateInfoKHR = BufferUsageFlags2CreateInfo;
  struct PhysicalDeviceMaintenance6Features;
  using PhysicalDeviceMaintenance6FeaturesKHR = PhysicalDeviceMaintenance6Features;
  struct PhysicalDeviceMaintenance6Properties;
  using PhysicalDeviceMaintenance6PropertiesKHR = PhysicalDeviceMaintenance6Properties;
  struct BindMemoryStatus;
  using BindMemoryStatusKHR = BindMemoryStatus;
  struct PhysicalDeviceHostImageCopyFeatures;
  using PhysicalDeviceHostImageCopyFeaturesEXT = PhysicalDeviceHostImageCopyFeatures;
  struct PhysicalDeviceHostImageCopyProperties;
  using PhysicalDeviceHostImageCopyPropertiesEXT = PhysicalDeviceHostImageCopyProperties;
  struct MemoryToImageCopy;
  using MemoryToImageCopyEXT = MemoryToImageCopy;
  struct ImageToMemoryCopy;
  using ImageToMemoryCopyEXT = ImageToMemoryCopy;
  struct CopyMemoryToImageInfo;
  using CopyMemoryToImageInfoEXT = CopyMemoryToImageInfo;
  struct CopyImageToMemoryInfo;
  using CopyImageToMemoryInfoEXT = CopyImageToMemoryInfo;
  struct CopyImageToImageInfo;
  using CopyImageToImageInfoEXT = CopyImageToImageInfo;
  struct HostImageLayoutTransitionInfo;
  using HostImageLayoutTransitionInfoEXT = HostImageLayoutTransitionInfo;
  struct SubresourceHostMemcpySize;
  using SubresourceHostMemcpySizeEXT = SubresourceHostMemcpySize;
  struct HostImageCopyDevicePerformanceQuery;
  using HostImageCopyDevicePerformanceQueryEXT = HostImageCopyDevicePerformanceQuery;
  struct PhysicalDeviceShaderSubgroupRotateFeatures;
  using PhysicalDeviceShaderSubgroupRotateFeaturesKHR = PhysicalDeviceShaderSubgroupRotateFeatures;
  struct PhysicalDeviceShaderFloatControls2Features;
  using PhysicalDeviceShaderFloatControls2FeaturesKHR = PhysicalDeviceShaderFloatControls2Features;
  struct PhysicalDeviceShaderExpectAssumeFeatures;
  using PhysicalDeviceShaderExpectAssumeFeaturesKHR = PhysicalDeviceShaderExpectAssumeFeatures;
  struct PipelineCreateFlags2CreateInfo;
  using PipelineCreateFlags2CreateInfoKHR = PipelineCreateFlags2CreateInfo;
  struct PhysicalDevicePushDescriptorProperties;
  using PhysicalDevicePushDescriptorPropertiesKHR = PhysicalDevicePushDescriptorProperties;
  struct BindDescriptorSetsInfo;
  using BindDescriptorSetsInfoKHR = BindDescriptorSetsInfo;
  struct PushConstantsInfo;
  using PushConstantsInfoKHR = PushConstantsInfo;
  struct PushDescriptorSetInfo;
  using PushDescriptorSetInfoKHR = PushDescriptorSetInfo;
  struct PushDescriptorSetWithTemplateInfo;
  using PushDescriptorSetWithTemplateInfoKHR = PushDescriptorSetWithTemplateInfo;
  struct PhysicalDevicePipelineProtectedAccessFeatures;
  using PhysicalDevicePipelineProtectedAccessFeaturesEXT = PhysicalDevicePipelineProtectedAccessFeatures;
  struct PhysicalDevicePipelineRobustnessFeatures;
  using PhysicalDevicePipelineRobustnessFeaturesEXT = PhysicalDevicePipelineRobustnessFeatures;
  struct PhysicalDevicePipelineRobustnessProperties;
  using PhysicalDevicePipelineRobustnessPropertiesEXT = PhysicalDevicePipelineRobustnessProperties;
  struct PipelineRobustnessCreateInfo;
  using PipelineRobustnessCreateInfoEXT = PipelineRobustnessCreateInfo;
  struct PhysicalDeviceLineRasterizationFeatures;
  using PhysicalDeviceLineRasterizationFeaturesEXT = PhysicalDeviceLineRasterizationFeatures;
  using PhysicalDeviceLineRasterizationFeaturesKHR = PhysicalDeviceLineRasterizationFeatures;
  struct PhysicalDeviceLineRasterizationProperties;
  using PhysicalDeviceLineRasterizationPropertiesEXT = PhysicalDeviceLineRasterizationProperties;
  using PhysicalDeviceLineRasterizationPropertiesKHR = PhysicalDeviceLineRasterizationProperties;
  struct PipelineRasterizationLineStateCreateInfo;
  using PipelineRasterizationLineStateCreateInfoEXT = PipelineRasterizationLineStateCreateInfo;
  using PipelineRasterizationLineStateCreateInfoKHR = PipelineRasterizationLineStateCreateInfo;
  struct PhysicalDeviceVertexAttributeDivisorProperties;
  using PhysicalDeviceVertexAttributeDivisorPropertiesKHR = PhysicalDeviceVertexAttributeDivisorProperties;
  struct VertexInputBindingDivisorDescription;
  using VertexInputBindingDivisorDescriptionEXT = VertexInputBindingDivisorDescription;
  using VertexInputBindingDivisorDescriptionKHR = VertexInputBindingDivisorDescription;
  struct PipelineVertexInputDivisorStateCreateInfo;
  using PipelineVertexInputDivisorStateCreateInfoEXT = PipelineVertexInputDivisorStateCreateInfo;
  using PipelineVertexInputDivisorStateCreateInfoKHR = PipelineVertexInputDivisorStateCreateInfo;
  struct PhysicalDeviceVertexAttributeDivisorFeatures;
  using PhysicalDeviceVertexAttributeDivisorFeaturesEXT = PhysicalDeviceVertexAttributeDivisorFeatures;
  using PhysicalDeviceVertexAttributeDivisorFeaturesKHR = PhysicalDeviceVertexAttributeDivisorFeatures;
  struct RenderingAreaInfo;
  using RenderingAreaInfoKHR = RenderingAreaInfo;
  struct PhysicalDeviceDynamicRenderingLocalReadFeatures;
  using PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = PhysicalDeviceDynamicRenderingLocalReadFeatures;
  struct RenderingAttachmentLocationInfo;
  using RenderingAttachmentLocationInfoKHR = RenderingAttachmentLocationInfo;
  struct RenderingInputAttachmentIndexInfo;
  using RenderingInputAttachmentIndexInfoKHR = RenderingInputAttachmentIndexInfo;

  //=== VK_KHR_surface ===
  struct SurfaceCapabilitiesKHR;
  struct SurfaceFormatKHR;

  //=== VK_KHR_swapchain ===
  struct SwapchainCreateInfoKHR;
  struct PresentInfoKHR;
  struct ImageSwapchainCreateInfoKHR;
  struct BindImageMemorySwapchainInfoKHR;
  struct AcquireNextImageInfoKHR;
  struct DeviceGroupPresentCapabilitiesKHR;
  struct DeviceGroupPresentInfoKHR;
  struct DeviceGroupSwapchainCreateInfoKHR;

  //=== VK_KHR_display ===
  struct DisplayModeCreateInfoKHR;
  struct DisplayModeParametersKHR;
  struct DisplayModePropertiesKHR;
  struct DisplayPlaneCapabilitiesKHR;
  struct DisplayPlanePropertiesKHR;
  struct DisplayPropertiesKHR;
  struct DisplaySurfaceCreateInfoKHR;

  //=== VK_KHR_display_swapchain ===
  struct DisplayPresentInfoKHR;

#if defined( VK_USE_PLATFORM_XLIB_KHR )
  //=== VK_KHR_xlib_surface ===
  struct XlibSurfaceCreateInfoKHR;
#endif /*VK_USE_PLATFORM_XLIB_KHR*/

#if defined( VK_USE_PLATFORM_XCB_KHR )
  //=== VK_KHR_xcb_surface ===
  struct XcbSurfaceCreateInfoKHR;
#endif /*VK_USE_PLATFORM_XCB_KHR*/

#if defined( VK_USE_PLATFORM_WAYLAND_KHR )
  //=== VK_KHR_wayland_surface ===
  struct WaylandSurfaceCreateInfoKHR;
#endif /*VK_USE_PLATFORM_WAYLAND_KHR*/

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  //=== VK_KHR_android_surface ===
  struct AndroidSurfaceCreateInfoKHR;
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_KHR_win32_surface ===
  struct Win32SurfaceCreateInfoKHR;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  //=== VK_EXT_debug_report ===
  struct DebugReportCallbackCreateInfoEXT;

  //=== VK_AMD_rasterization_order ===
  struct PipelineRasterizationStateRasterizationOrderAMD;

  //=== VK_EXT_debug_marker ===
  struct DebugMarkerObjectNameInfoEXT;
  struct DebugMarkerObjectTagInfoEXT;
  struct DebugMarkerMarkerInfoEXT;

  //=== VK_KHR_video_queue ===
  struct QueueFamilyQueryResultStatusPropertiesKHR;
  struct QueueFamilyVideoPropertiesKHR;
  struct VideoProfileInfoKHR;
  struct VideoProfileListInfoKHR;
  struct VideoCapabilitiesKHR;
  struct PhysicalDeviceVideoFormatInfoKHR;
  struct VideoFormatPropertiesKHR;
  struct VideoPictureResourceInfoKHR;
  struct VideoReferenceSlotInfoKHR;
  struct VideoSessionMemoryRequirementsKHR;
  struct BindVideoSessionMemoryInfoKHR;
  struct VideoSessionCreateInfoKHR;
  struct VideoSessionParametersCreateInfoKHR;
  struct VideoSessionParametersUpdateInfoKHR;
  struct VideoBeginCodingInfoKHR;
  struct VideoEndCodingInfoKHR;
  struct VideoCodingControlInfoKHR;

  //=== VK_KHR_video_decode_queue ===
  struct VideoDecodeCapabilitiesKHR;
  struct VideoDecodeUsageInfoKHR;
  struct VideoDecodeInfoKHR;

  //=== VK_NV_dedicated_allocation ===
  struct DedicatedAllocationImageCreateInfoNV;
  struct DedicatedAllocationBufferCreateInfoNV;
  struct DedicatedAllocationMemoryAllocateInfoNV;

  //=== VK_EXT_transform_feedback ===
  struct PhysicalDeviceTransformFeedbackFeaturesEXT;
  struct PhysicalDeviceTransformFeedbackPropertiesEXT;
  struct PipelineRasterizationStateStreamCreateInfoEXT;

  //=== VK_NVX_binary_import ===
  struct CuModuleCreateInfoNVX;
  struct CuModuleTexturingModeCreateInfoNVX;
  struct CuFunctionCreateInfoNVX;
  struct CuLaunchInfoNVX;

  //=== VK_NVX_image_view_handle ===
  struct ImageViewHandleInfoNVX;
  struct ImageViewAddressPropertiesNVX;

  //=== VK_KHR_video_encode_h264 ===
  struct VideoEncodeH264CapabilitiesKHR;
  struct VideoEncodeH264QualityLevelPropertiesKHR;
  struct VideoEncodeH264SessionCreateInfoKHR;
  struct VideoEncodeH264SessionParametersCreateInfoKHR;
  struct VideoEncodeH264SessionParametersAddInfoKHR;
  struct VideoEncodeH264SessionParametersGetInfoKHR;
  struct VideoEncodeH264SessionParametersFeedbackInfoKHR;
  struct VideoEncodeH264PictureInfoKHR;
  struct VideoEncodeH264DpbSlotInfoKHR;
  struct VideoEncodeH264NaluSliceInfoKHR;
  struct VideoEncodeH264ProfileInfoKHR;
  struct VideoEncodeH264RateControlInfoKHR;
  struct VideoEncodeH264RateControlLayerInfoKHR;
  struct VideoEncodeH264QpKHR;
  struct VideoEncodeH264FrameSizeKHR;
  struct VideoEncodeH264GopRemainingFrameInfoKHR;

  //=== VK_KHR_video_encode_h265 ===
  struct VideoEncodeH265CapabilitiesKHR;
  struct VideoEncodeH265SessionCreateInfoKHR;
  struct VideoEncodeH265QualityLevelPropertiesKHR;
  struct VideoEncodeH265SessionParametersCreateInfoKHR;
  struct VideoEncodeH265SessionParametersAddInfoKHR;
  struct VideoEncodeH265SessionParametersGetInfoKHR;
  struct VideoEncodeH265SessionParametersFeedbackInfoKHR;
  struct VideoEncodeH265PictureInfoKHR;
  struct VideoEncodeH265DpbSlotInfoKHR;
  struct VideoEncodeH265NaluSliceSegmentInfoKHR;
  struct VideoEncodeH265ProfileInfoKHR;
  struct VideoEncodeH265RateControlInfoKHR;
  struct VideoEncodeH265RateControlLayerInfoKHR;
  struct VideoEncodeH265QpKHR;
  struct VideoEncodeH265FrameSizeKHR;
  struct VideoEncodeH265GopRemainingFrameInfoKHR;

  //=== VK_KHR_video_decode_h264 ===
  struct VideoDecodeH264ProfileInfoKHR;
  struct VideoDecodeH264CapabilitiesKHR;
  struct VideoDecodeH264SessionParametersCreateInfoKHR;
  struct VideoDecodeH264SessionParametersAddInfoKHR;
  struct VideoDecodeH264PictureInfoKHR;
  struct VideoDecodeH264DpbSlotInfoKHR;

  //=== VK_AMD_texture_gather_bias_lod ===
  struct TextureLODGatherFormatPropertiesAMD;

  //=== VK_AMD_shader_info ===
  struct ShaderResourceUsageAMD;
  struct ShaderStatisticsInfoAMD;

#if defined( VK_USE_PLATFORM_GGP )
  //=== VK_GGP_stream_descriptor_surface ===
  struct StreamDescriptorSurfaceCreateInfoGGP;
#endif /*VK_USE_PLATFORM_GGP*/

  //=== VK_NV_corner_sampled_image ===
  struct PhysicalDeviceCornerSampledImageFeaturesNV;

  //=== VK_NV_external_memory_capabilities ===
  struct ExternalImageFormatPropertiesNV;

  //=== VK_NV_external_memory ===
  struct ExternalMemoryImageCreateInfoNV;
  struct ExportMemoryAllocateInfoNV;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_NV_external_memory_win32 ===
  struct ImportMemoryWin32HandleInfoNV;
  struct ExportMemoryWin32HandleInfoNV;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_NV_win32_keyed_mutex ===
  struct Win32KeyedMutexAcquireReleaseInfoNV;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  //=== VK_EXT_validation_flags ===
  struct ValidationFlagsEXT;

#if defined( VK_USE_PLATFORM_VI_NN )
  //=== VK_NN_vi_surface ===
  struct ViSurfaceCreateInfoNN;
#endif /*VK_USE_PLATFORM_VI_NN*/

  //=== VK_EXT_astc_decode_mode ===
  struct ImageViewASTCDecodeModeEXT;
  struct PhysicalDeviceASTCDecodeFeaturesEXT;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_KHR_external_memory_win32 ===
  struct ImportMemoryWin32HandleInfoKHR;
  struct ExportMemoryWin32HandleInfoKHR;
  struct MemoryWin32HandlePropertiesKHR;
  struct MemoryGetWin32HandleInfoKHR;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  //=== VK_KHR_external_memory_fd ===
  struct ImportMemoryFdInfoKHR;
  struct MemoryFdPropertiesKHR;
  struct MemoryGetFdInfoKHR;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_KHR_win32_keyed_mutex ===
  struct Win32KeyedMutexAcquireReleaseInfoKHR;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_KHR_external_semaphore_win32 ===
  struct ImportSemaphoreWin32HandleInfoKHR;
  struct ExportSemaphoreWin32HandleInfoKHR;
  struct D3D12FenceSubmitInfoKHR;
  struct SemaphoreGetWin32HandleInfoKHR;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  //=== VK_KHR_external_semaphore_fd ===
  struct ImportSemaphoreFdInfoKHR;
  struct SemaphoreGetFdInfoKHR;

  //=== VK_EXT_conditional_rendering ===
  struct ConditionalRenderingBeginInfoEXT;
  struct PhysicalDeviceConditionalRenderingFeaturesEXT;
  struct CommandBufferInheritanceConditionalRenderingInfoEXT;

  //=== VK_KHR_incremental_present ===
  struct PresentRegionsKHR;
  struct PresentRegionKHR;
  struct RectLayerKHR;

  //=== VK_NV_clip_space_w_scaling ===
  struct ViewportWScalingNV;
  struct PipelineViewportWScalingStateCreateInfoNV;

  //=== VK_EXT_display_surface_counter ===
  struct SurfaceCapabilities2EXT;

  //=== VK_EXT_display_control ===
  struct DisplayPowerInfoEXT;
  struct DeviceEventInfoEXT;
  struct DisplayEventInfoEXT;
  struct SwapchainCounterCreateInfoEXT;

  //=== VK_GOOGLE_display_timing ===
  struct RefreshCycleDurationGOOGLE;
  struct PastPresentationTimingGOOGLE;
  struct PresentTimesInfoGOOGLE;
  struct PresentTimeGOOGLE;

  //=== VK_NVX_multiview_per_view_attributes ===
  struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
  struct MultiviewPerViewAttributesInfoNVX;

  //=== VK_NV_viewport_swizzle ===
  struct ViewportSwizzleNV;
  struct PipelineViewportSwizzleStateCreateInfoNV;

  //=== VK_EXT_discard_rectangles ===
  struct PhysicalDeviceDiscardRectanglePropertiesEXT;
  struct PipelineDiscardRectangleStateCreateInfoEXT;

  //=== VK_EXT_conservative_rasterization ===
  struct PhysicalDeviceConservativeRasterizationPropertiesEXT;
  struct PipelineRasterizationConservativeStateCreateInfoEXT;

  //=== VK_EXT_depth_clip_enable ===
  struct PhysicalDeviceDepthClipEnableFeaturesEXT;
  struct PipelineRasterizationDepthClipStateCreateInfoEXT;

  //=== VK_EXT_hdr_metadata ===
  struct HdrMetadataEXT;
  struct XYColorEXT;

  //=== VK_IMG_relaxed_line_rasterization ===
  struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMG;

  //=== VK_KHR_shared_presentable_image ===
  struct SharedPresentSurfaceCapabilitiesKHR;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_KHR_external_fence_win32 ===
  struct ImportFenceWin32HandleInfoKHR;
  struct ExportFenceWin32HandleInfoKHR;
  struct FenceGetWin32HandleInfoKHR;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  //=== VK_KHR_external_fence_fd ===
  struct ImportFenceFdInfoKHR;
  struct FenceGetFdInfoKHR;

  //=== VK_KHR_performance_query ===
  struct PhysicalDevicePerformanceQueryFeaturesKHR;
  struct PhysicalDevicePerformanceQueryPropertiesKHR;
  struct PerformanceCounterKHR;
  struct PerformanceCounterDescriptionKHR;
  struct QueryPoolPerformanceCreateInfoKHR;
  union PerformanceCounterResultKHR;
  struct AcquireProfilingLockInfoKHR;
  struct PerformanceQuerySubmitInfoKHR;

  //=== VK_KHR_get_surface_capabilities2 ===
  struct PhysicalDeviceSurfaceInfo2KHR;
  struct SurfaceCapabilities2KHR;
  struct SurfaceFormat2KHR;

  //=== VK_KHR_get_display_properties2 ===
  struct DisplayProperties2KHR;
  struct DisplayPlaneProperties2KHR;
  struct DisplayModeProperties2KHR;
  struct DisplayPlaneInfo2KHR;
  struct DisplayPlaneCapabilities2KHR;

#if defined( VK_USE_PLATFORM_IOS_MVK )
  //=== VK_MVK_ios_surface ===
  struct IOSSurfaceCreateInfoMVK;
#endif /*VK_USE_PLATFORM_IOS_MVK*/

#if defined( VK_USE_PLATFORM_MACOS_MVK )
  //=== VK_MVK_macos_surface ===
  struct MacOSSurfaceCreateInfoMVK;
#endif /*VK_USE_PLATFORM_MACOS_MVK*/

  //=== VK_EXT_debug_utils ===
  struct DebugUtilsLabelEXT;
  struct DebugUtilsMessengerCallbackDataEXT;
  struct DebugUtilsMessengerCreateInfoEXT;
  struct DebugUtilsObjectNameInfoEXT;
  struct DebugUtilsObjectTagInfoEXT;

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  //=== VK_ANDROID_external_memory_android_hardware_buffer ===
  struct AndroidHardwareBufferUsageANDROID;
  struct AndroidHardwareBufferPropertiesANDROID;
  struct AndroidHardwareBufferFormatPropertiesANDROID;
  struct ImportAndroidHardwareBufferInfoANDROID;
  struct MemoryGetAndroidHardwareBufferInfoANDROID;
  struct ExternalFormatANDROID;
  struct AndroidHardwareBufferFormatProperties2ANDROID;
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_AMDX_shader_enqueue ===
  struct PhysicalDeviceShaderEnqueueFeaturesAMDX;
  struct PhysicalDeviceShaderEnqueuePropertiesAMDX;
  struct ExecutionGraphPipelineScratchSizeAMDX;
  struct ExecutionGraphPipelineCreateInfoAMDX;
  struct DispatchGraphInfoAMDX;
  struct DispatchGraphCountInfoAMDX;
  struct PipelineShaderStageNodeCreateInfoAMDX;
  union DeviceOrHostAddressConstAMDX;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  //=== VK_EXT_descriptor_heap ===
  struct HostAddressRangeEXT;
  struct HostAddressRangeConstEXT;
  struct DeviceAddressRangeEXT;
  struct TexelBufferDescriptorInfoEXT;
  struct ImageDescriptorInfoEXT;
  struct ResourceDescriptorInfoEXT;
  union ResourceDescriptorDataEXT;
  struct BindHeapInfoEXT;
  struct PushDataInfoEXT;
  struct DescriptorMappingSourceConstantOffsetEXT;
  struct DescriptorMappingSourcePushIndexEXT;
  struct DescriptorMappingSourceIndirectIndexEXT;
  struct DescriptorMappingSourceHeapDataEXT;
  struct DescriptorMappingSourceIndirectAddressEXT;
  struct DescriptorMappingSourceShaderRecordIndexEXT;
  union DescriptorMappingSourceDataEXT;
  struct DescriptorMappingSourceIndirectIndexArrayEXT;
  struct DescriptorSetAndBindingMappingEXT;
  struct ShaderDescriptorSetAndBindingMappingInfoEXT;
  struct OpaqueCaptureDataCreateInfoEXT;
  struct PhysicalDeviceDescriptorHeapFeaturesEXT;
  struct PhysicalDeviceDescriptorHeapPropertiesEXT;
  struct CommandBufferInheritanceDescriptorHeapInfoEXT;
  struct SamplerCustomBorderColorIndexCreateInfoEXT;
  struct IndirectCommandsLayoutPushDataTokenNV;
  struct SubsampledImageFormatPropertiesEXT;
  struct TensorViewCreateInfoARM;
  struct PhysicalDeviceDescriptorHeapTensorPropertiesARM;

  //=== VK_AMD_mixed_attachment_samples ===
  struct AttachmentSampleCountInfoAMD;
  using AttachmentSampleCountInfoNV = AttachmentSampleCountInfoAMD;

  //=== VK_KHR_shader_bfloat16 ===
  struct PhysicalDeviceShaderBfloat16FeaturesKHR;

  //=== VK_EXT_sample_locations ===
  struct SampleLocationEXT;
  struct SampleLocationsInfoEXT;
  struct AttachmentSampleLocationsEXT;
  struct SubpassSampleLocationsEXT;
  struct RenderPassSampleLocationsBeginInfoEXT;
  struct PipelineSampleLocationsStateCreateInfoEXT;
  struct PhysicalDeviceSampleLocationsPropertiesEXT;
  struct MultisamplePropertiesEXT;

  //=== VK_EXT_blend_operation_advanced ===
  struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT;
  struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT;
  struct PipelineColorBlendAdvancedStateCreateInfoEXT;

  //=== VK_NV_fragment_coverage_to_color ===
  struct PipelineCoverageToColorStateCreateInfoNV;

  //=== VK_KHR_acceleration_structure ===
  union DeviceOrHostAddressKHR;
  union DeviceOrHostAddressConstKHR;
  struct AccelerationStructureBuildRangeInfoKHR;
  struct AabbPositionsKHR;
  using AabbPositionsNV = AabbPositionsKHR;
  struct AccelerationStructureGeometryTrianglesDataKHR;
  struct TransformMatrixKHR;
  using TransformMatrixNV = TransformMatrixKHR;
  struct AccelerationStructureBuildGeometryInfoKHR;
  struct AccelerationStructureGeometryAabbsDataKHR;
  struct AccelerationStructureInstanceKHR;
  using AccelerationStructureInstanceNV = AccelerationStructureInstanceKHR;
  struct AccelerationStructureGeometryInstancesDataKHR;
  union AccelerationStructureGeometryDataKHR;
  struct AccelerationStructureGeometryKHR;
  struct AccelerationStructureCreateInfoKHR;
  struct WriteDescriptorSetAccelerationStructureKHR;
  struct PhysicalDeviceAccelerationStructureFeaturesKHR;
  struct PhysicalDeviceAccelerationStructurePropertiesKHR;
  struct AccelerationStructureDeviceAddressInfoKHR;
  struct AccelerationStructureVersionInfoKHR;
  struct CopyAccelerationStructureToMemoryInfoKHR;
  struct CopyMemoryToAccelerationStructureInfoKHR;
  struct CopyAccelerationStructureInfoKHR;
  struct AccelerationStructureBuildSizesInfoKHR;

  //=== VK_KHR_ray_tracing_pipeline ===
  struct RayTracingShaderGroupCreateInfoKHR;
  struct RayTracingPipelineCreateInfoKHR;
  struct PhysicalDeviceRayTracingPipelineFeaturesKHR;
  struct PhysicalDeviceRayTracingPipelinePropertiesKHR;
  struct StridedDeviceAddressRegionKHR;
  struct TraceRaysIndirectCommandKHR;
  struct RayTracingPipelineInterfaceCreateInfoKHR;

  //=== VK_KHR_ray_query ===
  struct PhysicalDeviceRayQueryFeaturesKHR;

  //=== VK_NV_framebuffer_mixed_samples ===
  struct PipelineCoverageModulationStateCreateInfoNV;

  //=== VK_NV_shader_sm_builtins ===
  struct PhysicalDeviceShaderSMBuiltinsPropertiesNV;
  struct PhysicalDeviceShaderSMBuiltinsFeaturesNV;

  //=== VK_EXT_image_drm_format_modifier ===
  struct DrmFormatModifierPropertiesListEXT;
  struct DrmFormatModifierPropertiesEXT;
  struct PhysicalDeviceImageDrmFormatModifierInfoEXT;
  struct ImageDrmFormatModifierListCreateInfoEXT;
  struct ImageDrmFormatModifierExplicitCreateInfoEXT;
  struct ImageDrmFormatModifierPropertiesEXT;
  struct DrmFormatModifierPropertiesList2EXT;
  struct DrmFormatModifierProperties2EXT;

  //=== VK_EXT_validation_cache ===
  struct ValidationCacheCreateInfoEXT;
  struct ShaderModuleValidationCacheCreateInfoEXT;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_KHR_portability_subset ===
  struct PhysicalDevicePortabilitySubsetFeaturesKHR;
  struct PhysicalDevicePortabilitySubsetPropertiesKHR;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  //=== VK_NV_shading_rate_image ===
  struct ShadingRatePaletteNV;
  struct PipelineViewportShadingRateImageStateCreateInfoNV;
  struct PhysicalDeviceShadingRateImageFeaturesNV;
  struct PhysicalDeviceShadingRateImagePropertiesNV;
  struct CoarseSampleLocationNV;
  struct CoarseSampleOrderCustomNV;
  struct PipelineViewportCoarseSampleOrderStateCreateInfoNV;

  //=== VK_NV_ray_tracing ===
  struct RayTracingShaderGroupCreateInfoNV;
  struct RayTracingPipelineCreateInfoNV;
  struct GeometryTrianglesNV;
  struct GeometryAABBNV;
  struct GeometryDataNV;
  struct GeometryNV;
  struct AccelerationStructureInfoNV;
  struct AccelerationStructureCreateInfoNV;
  struct BindAccelerationStructureMemoryInfoNV;
  struct WriteDescriptorSetAccelerationStructureNV;
  struct AccelerationStructureMemoryRequirementsInfoNV;
  struct PhysicalDeviceRayTracingPropertiesNV;

  //=== VK_NV_representative_fragment_test ===
  struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV;
  struct PipelineRepresentativeFragmentTestStateCreateInfoNV;

  //=== VK_EXT_filter_cubic ===
  struct PhysicalDeviceImageViewImageFormatInfoEXT;
  struct FilterCubicImageViewImageFormatPropertiesEXT;

  //=== VK_QCOM_cooperative_matrix_conversion ===
  struct PhysicalDeviceCooperativeMatrixConversionFeaturesQCOM;

  //=== VK_EXT_external_memory_host ===
  struct ImportMemoryHostPointerInfoEXT;
  struct MemoryHostPointerPropertiesEXT;
  struct PhysicalDeviceExternalMemoryHostPropertiesEXT;

  //=== VK_KHR_shader_clock ===
  struct PhysicalDeviceShaderClockFeaturesKHR;

  //=== VK_AMD_pipeline_compiler_control ===
  struct PipelineCompilerControlCreateInfoAMD;

  //=== VK_AMD_shader_core_properties ===
  struct PhysicalDeviceShaderCorePropertiesAMD;

  //=== VK_KHR_video_decode_h265 ===
  struct VideoDecodeH265ProfileInfoKHR;
  struct VideoDecodeH265CapabilitiesKHR;
  struct VideoDecodeH265SessionParametersCreateInfoKHR;
  struct VideoDecodeH265SessionParametersAddInfoKHR;
  struct VideoDecodeH265PictureInfoKHR;
  struct VideoDecodeH265DpbSlotInfoKHR;

  //=== VK_AMD_memory_overallocation_behavior ===
  struct DeviceMemoryOverallocationCreateInfoAMD;

  //=== VK_EXT_vertex_attribute_divisor ===
  struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT;

#if defined( VK_USE_PLATFORM_GGP )
  //=== VK_GGP_frame_token ===
  struct PresentFrameTokenGGP;
#endif /*VK_USE_PLATFORM_GGP*/

  //=== VK_NV_mesh_shader ===
  struct PhysicalDeviceMeshShaderFeaturesNV;
  struct PhysicalDeviceMeshShaderPropertiesNV;
  struct DrawMeshTasksIndirectCommandNV;

  //=== VK_NV_shader_image_footprint ===
  struct PhysicalDeviceShaderImageFootprintFeaturesNV;

  //=== VK_NV_scissor_exclusive ===
  struct PipelineViewportExclusiveScissorStateCreateInfoNV;
  struct PhysicalDeviceExclusiveScissorFeaturesNV;

  //=== VK_NV_device_diagnostic_checkpoints ===
  struct QueueFamilyCheckpointPropertiesNV;
  struct CheckpointDataNV;
  struct QueueFamilyCheckpointProperties2NV;
  struct CheckpointData2NV;

  //=== VK_EXT_present_timing ===
  struct PhysicalDevicePresentTimingFeaturesEXT;
  struct PresentTimingSurfaceCapabilitiesEXT;
  struct SwapchainCalibratedTimestampInfoEXT;
  struct SwapchainTimingPropertiesEXT;
  struct SwapchainTimeDomainPropertiesEXT;
  struct PastPresentationTimingInfoEXT;
  struct PastPresentationTimingPropertiesEXT;
  struct PastPresentationTimingEXT;
  struct PresentTimingsInfoEXT;
  struct PresentTimingInfoEXT;
  struct PresentStageTimeEXT;

  //=== VK_INTEL_shader_integer_functions2 ===
  struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;

  //=== VK_INTEL_performance_query ===
  union PerformanceValueDataINTEL;
  struct PerformanceValueINTEL;
  struct InitializePerformanceApiInfoINTEL;
  struct QueryPoolPerformanceQueryCreateInfoINTEL;
  using QueryPoolCreateInfoINTEL = QueryPoolPerformanceQueryCreateInfoINTEL;
  struct PerformanceMarkerInfoINTEL;
  struct PerformanceStreamMarkerInfoINTEL;
  struct PerformanceOverrideInfoINTEL;
  struct PerformanceConfigurationAcquireInfoINTEL;

  //=== VK_EXT_pci_bus_info ===
  struct PhysicalDevicePCIBusInfoPropertiesEXT;

  //=== VK_AMD_display_native_hdr ===
  struct DisplayNativeHdrSurfaceCapabilitiesAMD;
  struct SwapchainDisplayNativeHdrCreateInfoAMD;

#if defined( VK_USE_PLATFORM_FUCHSIA )
  //=== VK_FUCHSIA_imagepipe_surface ===
  struct ImagePipeSurfaceCreateInfoFUCHSIA;
#endif /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_METAL_EXT )
  //=== VK_EXT_metal_surface ===
  struct MetalSurfaceCreateInfoEXT;
#endif /*VK_USE_PLATFORM_METAL_EXT*/

  //=== VK_EXT_fragment_density_map ===
  struct PhysicalDeviceFragmentDensityMapFeaturesEXT;
  struct PhysicalDeviceFragmentDensityMapPropertiesEXT;
  struct RenderPassFragmentDensityMapCreateInfoEXT;
  struct RenderingFragmentDensityMapAttachmentInfoEXT;

  //=== VK_KHR_fragment_shading_rate ===
  struct FragmentShadingRateAttachmentInfoKHR;
  struct PipelineFragmentShadingRateStateCreateInfoKHR;
  struct PhysicalDeviceFragmentShadingRateFeaturesKHR;
  struct PhysicalDeviceFragmentShadingRatePropertiesKHR;
  struct PhysicalDeviceFragmentShadingRateKHR;
  struct RenderingFragmentShadingRateAttachmentInfoKHR;

  //=== VK_AMD_shader_core_properties2 ===
  struct PhysicalDeviceShaderCoreProperties2AMD;

  //=== VK_AMD_device_coherent_memory ===
  struct PhysicalDeviceCoherentMemoryFeaturesAMD;

  //=== VK_EXT_shader_image_atomic_int64 ===
  struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT;

  //=== VK_KHR_shader_quad_control ===
  struct PhysicalDeviceShaderQuadControlFeaturesKHR;

  //=== VK_EXT_memory_budget ===
  struct PhysicalDeviceMemoryBudgetPropertiesEXT;

  //=== VK_EXT_memory_priority ===
  struct PhysicalDeviceMemoryPriorityFeaturesEXT;
  struct MemoryPriorityAllocateInfoEXT;

  //=== VK_KHR_surface_protected_capabilities ===
  struct SurfaceProtectedCapabilitiesKHR;

  //=== VK_NV_dedicated_allocation_image_aliasing ===
  struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;

  //=== VK_EXT_buffer_device_address ===
  struct PhysicalDeviceBufferDeviceAddressFeaturesEXT;
  using PhysicalDeviceBufferAddressFeaturesEXT = PhysicalDeviceBufferDeviceAddressFeaturesEXT;
  struct BufferDeviceAddressCreateInfoEXT;

  //=== VK_EXT_validation_features ===
  struct ValidationFeaturesEXT;

  //=== VK_KHR_present_wait ===
  struct PhysicalDevicePresentWaitFeaturesKHR;

  //=== VK_NV_cooperative_matrix ===
  struct CooperativeMatrixPropertiesNV;
  struct PhysicalDeviceCooperativeMatrixFeaturesNV;
  struct PhysicalDeviceCooperativeMatrixPropertiesNV;

  //=== VK_NV_coverage_reduction_mode ===
  struct PhysicalDeviceCoverageReductionModeFeaturesNV;
  struct PipelineCoverageReductionStateCreateInfoNV;
  struct FramebufferMixedSamplesCombinationNV;

  //=== VK_EXT_fragment_shader_interlock ===
  struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT;

  //=== VK_EXT_ycbcr_image_arrays ===
  struct PhysicalDeviceYcbcrImageArraysFeaturesEXT;

  //=== VK_EXT_provoking_vertex ===
  struct PhysicalDeviceProvokingVertexFeaturesEXT;
  struct PhysicalDeviceProvokingVertexPropertiesEXT;
  struct PipelineRasterizationProvokingVertexStateCreateInfoEXT;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
  //=== VK_EXT_full_screen_exclusive ===
  struct SurfaceFullScreenExclusiveInfoEXT;
  struct SurfaceCapabilitiesFullScreenExclusiveEXT;
  struct SurfaceFullScreenExclusiveWin32InfoEXT;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

  //=== VK_EXT_headless_surface ===
  struct HeadlessSurfaceCreateInfoEXT;

  //=== VK_EXT_shader_atomic_float ===
  struct PhysicalDeviceShaderAtomicFloatFeaturesEXT;

  //=== VK_EXT_extended_dynamic_state ===
  struct PhysicalDeviceExtendedDynamicStateFeaturesEXT;

  //=== VK_KHR_pipeline_executable_properties ===
  struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
  struct PipelineInfoKHR;
  using PipelineInfoEXT = PipelineInfoKHR;
  struct PipelineExecutablePropertiesKHR;
  struct PipelineExecutableInfoKHR;
  union PipelineExecutableStatisticValueKHR;
  struct PipelineExecutableStatisticKHR;
  struct PipelineExecutableInternalRepresentationKHR;

  //=== VK_EXT_map_memory_placed ===
  struct PhysicalDeviceMapMemoryPlacedFeaturesEXT;
  struct PhysicalDeviceMapMemoryPlacedPropertiesEXT;
  struct MemoryMapPlacedInfoEXT;

  //=== VK_EXT_shader_atomic_float2 ===
  struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT;

  //=== VK_NV_device_generated_commands ===
  struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV;
  struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV;
  struct GraphicsShaderGroupCreateInfoNV;
  struct GraphicsPipelineShaderGroupsCreateInfoNV;
  struct BindShaderGroupIndirectCommandNV;
  struct BindIndexBufferIndirectCommandNV;
  struct BindVertexBufferIndirectCommandNV;
  struct SetStateFlagsIndirectCommandNV;
  struct IndirectCommandsStreamNV;
  struct IndirectCommandsLayoutTokenNV;
  struct IndirectCommandsLayoutCreateInfoNV;
  struct GeneratedCommandsInfoNV;
  struct GeneratedCommandsMemoryRequirementsInfoNV;

  //=== VK_NV_inherited_viewport_scissor ===
  struct PhysicalDeviceInheritedViewportScissorFeaturesNV;
  struct CommandBufferInheritanceViewportScissorInfoNV;

  //=== VK_EXT_texel_buffer_alignment ===
  struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT;

  //=== VK_QCOM_render_pass_transform ===
  struct RenderPassTransformBeginInfoQCOM;
  struct CommandBufferInheritanceRenderPassTransformInfoQCOM;

  //=== VK_EXT_depth_bias_control ===
  struct PhysicalDeviceDepthBiasControlFeaturesEXT;
  struct DepthBiasInfoEXT;
  struct DepthBiasRepresentationInfoEXT;

  //=== VK_EXT_device_memory_report ===
  struct PhysicalDeviceDeviceMemoryReportFeaturesEXT;
  struct DeviceDeviceMemoryReportCreateInfoEXT;
  struct DeviceMemoryReportCallbackDataEXT;

  //=== VK_EXT_custom_border_color ===
  struct SamplerCustomBorderColorCreateInfoEXT;
  struct PhysicalDeviceCustomBorderColorPropertiesEXT;
  struct PhysicalDeviceCustomBorderColorFeaturesEXT;

  //=== VK_EXT_texture_compression_astc_3d ===
  struct PhysicalDeviceTextureCompressionASTC3DFeaturesEXT;

  //=== VK_KHR_pipeline_library ===
  struct PipelineLibraryCreateInfoKHR;

  //=== VK_NV_present_barrier ===
  struct PhysicalDevicePresentBarrierFeaturesNV;
  struct SurfaceCapabilitiesPresentBarrierNV;
  struct SwapchainPresentBarrierCreateInfoNV;

  //=== VK_KHR_present_id ===
  struct PresentIdKHR;
  struct PhysicalDevicePresentIdFeaturesKHR;

  //=== VK_KHR_video_encode_queue ===
  struct VideoEncodeInfoKHR;
  struct VideoEncodeCapabilitiesKHR;
  struct QueryPoolVideoEncodeFeedbackCreateInfoKHR;
  struct VideoEncodeUsageInfoKHR;
  struct VideoEncodeRateControlInfoKHR;
  struct VideoEncodeRateControlLayerInfoKHR;
  struct PhysicalDeviceVideoEncodeQualityLevelInfoKHR;
  struct VideoEncodeQualityLevelPropertiesKHR;
  struct VideoEncodeQualityLevelInfoKHR;
  struct VideoEncodeSessionParametersGetInfoKHR;
  struct VideoEncodeSessionParametersFeedbackInfoKHR;

  //=== VK_NV_device_diagnostics_config ===
  struct PhysicalDeviceDiagnosticsConfigFeaturesNV;
  struct DeviceDiagnosticsConfigCreateInfoNV;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_NV_cuda_kernel_launch ===
  struct CudaModuleCreateInfoNV;
  struct CudaFunctionCreateInfoNV;
  struct CudaLaunchInfoNV;
  struct PhysicalDeviceCudaKernelLaunchFeaturesNV;
  struct PhysicalDeviceCudaKernelLaunchPropertiesNV;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  //=== VK_QCOM_tile_shading ===
  struct PhysicalDeviceTileShadingFeaturesQCOM;
  struct PhysicalDeviceTileShadingPropertiesQCOM;
  struct RenderPassTileShadingCreateInfoQCOM;
  struct PerTileBeginInfoQCOM;
  struct PerTileEndInfoQCOM;
  struct DispatchTileInfoQCOM;

  //=== VK_NV_low_latency ===
  struct QueryLowLatencySupportNV;

#if defined( VK_USE_PLATFORM_METAL_EXT )
  //=== VK_EXT_metal_objects ===
  struct ExportMetalObjectCreateInfoEXT;
  struct ExportMetalObjectsInfoEXT;
  struct ExportMetalDeviceInfoEXT;
  struct ExportMetalCommandQueueInfoEXT;
  struct ExportMetalBufferInfoEXT;
  struct ImportMetalBufferInfoEXT;
  struct ExportMetalTextureInfoEXT;
  struct ImportMetalTextureInfoEXT;
  struct ExportMetalIOSurfaceInfoEXT;
  struct ImportMetalIOSurfaceInfoEXT;
  struct ExportMetalSharedEventInfoEXT;
  struct ImportMetalSharedEventInfoEXT;
#endif /*VK_USE_PLATFORM_METAL_EXT*/

  //=== VK_EXT_descriptor_buffer ===
  struct PhysicalDeviceDescriptorBufferPropertiesEXT;
  struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT;
  struct PhysicalDeviceDescriptorBufferFeaturesEXT;
  struct DescriptorAddressInfoEXT;
  struct DescriptorBufferBindingInfoEXT;
  struct DescriptorBufferBindingPushDescriptorBufferHandleEXT;
  union DescriptorDataEXT;
  struct DescriptorGetInfoEXT;
  struct BufferCaptureDescriptorDataInfoEXT;
  struct ImageCaptureDescriptorDataInfoEXT;
  struct ImageViewCaptureDescriptorDataInfoEXT;
  struct SamplerCaptureDescriptorDataInfoEXT;
  struct OpaqueCaptureDescriptorDataCreateInfoEXT;
  struct AccelerationStructureCaptureDescriptorDataInfoEXT;

  //=== VK_EXT_graphics_pipeline_library ===
  struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;
  struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;
  struct GraphicsPipelineLibraryCreateInfoEXT;

  //=== VK_AMD_shader_early_and_late_fragment_tests ===
  struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD;

  //=== VK_KHR_fragment_shader_barycentric ===
  struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
  using PhysicalDeviceFragmentShaderBarycentricFeaturesNV = PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
  struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR;

  //=== VK_KHR_shader_subgroup_uniform_control_flow ===
  struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR;

  //=== VK_NV_fragment_shading_rate_enums ===
  struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
  struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV;
  struct PipelineFragmentShadingRateEnumStateCreateInfoNV;

  //=== VK_NV_ray_tracing_motion_blur ===
  struct AccelerationStructureGeometryMotionTrianglesDataNV;
  struct AccelerationStructureMotionInfoNV;
  struct AccelerationStructureMotionInstanceNV;
  union AccelerationStructureMotionInstanceDataNV;
  struct AccelerationStructureMatrixMotionInstanceNV;
  struct AccelerationStructureSRTMotionInstanceNV;
  struct SRTDataNV;
  struct PhysicalDeviceRayTracingMotionBlurFeaturesNV;

  //=== VK_EXT_mesh_shader ===
  struct PhysicalDeviceMeshShaderFeaturesEXT;
  struct PhysicalDeviceMeshShaderPropertiesEXT;
  struct DrawMeshTasksIndirectCommandEXT;

  //=== VK_EXT_ycbcr_2plane_444_formats ===
  struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT;

  //=== VK_EXT_fragment_density_map2 ===
  struct PhysicalDeviceFragmentDensityMap2FeaturesEXT;
  struct PhysicalDeviceFragmentDensityMap2PropertiesEXT;

  //=== VK_QCOM_rotated_copy_commands ===
  struct CopyCommandTransformInfoQCOM;

  //=== VK_KHR_workgroup_memory_explicit_layout ===
  struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;

  //=== VK_EXT_image_compression_control ===
  struct PhysicalDeviceImageCompressionControlFeaturesEXT;
  struct ImageCompressionControlEXT;
  struct ImageCompressionPropertiesEXT;

  //=== VK_EXT_attachment_feedback_loop_layout ===
  struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT;

  //=== VK_EXT_4444_formats ===
  struct PhysicalDevice4444FormatsFeaturesEXT;

  //=== VK_EXT_device_fault ===
  struct PhysicalDeviceFaultFeaturesEXT;
  struct DeviceFaultCountsEXT;
  struct DeviceFaultInfoEXT;
  struct DeviceFaultAddressInfoEXT;
  struct DeviceFaultVendorInfoEXT;
  struct DeviceFaultVendorBinaryHeaderVersionOneEXT;

  //=== VK_EXT_rgba10x6_formats ===
  struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT;

#if defined( VK_USE_PLATFORM_DIRECTFB_EXT )
  //=== VK_EXT_directfb_surface ===
  struct DirectFBSurfaceCreateInfoEXT;
#endif /*VK_USE_PLATFORM_DIRECTFB_EXT*/

  //=== VK_EXT_vertex_input_dynamic_state ===
  struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT;
  struct VertexInputBindingDescription2EXT;
  struct VertexInputAttributeDescription2EXT;

  //=== VK_EXT_physical_device_drm ===
  struct PhysicalDeviceDrmPropertiesEXT;

  //=== VK_EXT_device_address_binding_report ===
  struct PhysicalDeviceAddressBindingReportFeaturesEXT;
  struct DeviceAddressBindingCallbackDataEXT;

  //=== VK_EXT_depth_clip_control ===
  struct PhysicalDeviceDepthClipControlFeaturesEXT;
  struct PipelineViewportDepthClipControlCreateInfoEXT;

  //=== VK_EXT_primitive_topology_list_restart ===
  struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT;

#if defined( VK_USE_PLATFORM_FUCHSIA )
  //=== VK_FUCHSIA_external_memory ===
  struct ImportMemoryZirconHandleInfoFUCHSIA;
  struct MemoryZirconHandlePropertiesFUCHSIA;
  struct MemoryGetZirconHandleInfoFUCHSIA;
#endif /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  //=== VK_FUCHSIA_external_semaphore ===
  struct ImportSemaphoreZirconHandleInfoFUCHSIA;
  struct SemaphoreGetZirconHandleInfoFUCHSIA;
#endif /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  //=== VK_FUCHSIA_buffer_collection ===
  struct BufferCollectionCreateInfoFUCHSIA;
  struct ImportMemoryBufferCollectionFUCHSIA;
  struct BufferCollectionImageCreateInfoFUCHSIA;
  struct BufferConstraintsInfoFUCHSIA;
  struct BufferCollectionBufferCreateInfoFUCHSIA;
  struct BufferCollectionPropertiesFUCHSIA;
  struct SysmemColorSpaceFUCHSIA;
  struct ImageConstraintsInfoFUCHSIA;
  struct ImageFormatConstraintsInfoFUCHSIA;
  struct BufferCollectionConstraintsInfoFUCHSIA;
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  //=== VK_HUAWEI_subpass_shading ===
  struct SubpassShadingPipelineCreateInfoHUAWEI;
  struct PhysicalDeviceSubpassShadingFeaturesHUAWEI;
  struct PhysicalDeviceSubpassShadingPropertiesHUAWEI;

  //=== VK_HUAWEI_invocation_mask ===
  struct PhysicalDeviceInvocationMaskFeaturesHUAWEI;

  //=== VK_NV_external_memory_rdma ===
  struct MemoryGetRemoteAddressInfoNV;
  struct PhysicalDeviceExternalMemoryRDMAFeaturesNV;

  //=== VK_EXT_pipeline_properties ===
  struct PipelinePropertiesIdentifierEXT;
  struct PhysicalDevicePipelinePropertiesFeaturesEXT;

  //=== VK_EXT_frame_boundary ===
  struct PhysicalDeviceFrameBoundaryFeaturesEXT;
  struct FrameBoundaryEXT;

  //=== VK_EXT_multisampled_render_to_single_sampled ===
  struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT;
  struct SubpassResolvePerformanceQueryEXT;
  struct MultisampledRenderToSingleSampledInfoEXT;

  //=== VK_EXT_extended_dynamic_state2 ===
  struct PhysicalDeviceExtendedDynamicState2FeaturesEXT;

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
  //=== VK_QNX_screen_surface ===
  struct ScreenSurfaceCreateInfoQNX;
#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

  //=== VK_EXT_color_write_enable ===
  struct PhysicalDeviceColorWriteEnableFeaturesEXT;
  struct PipelineColorWriteCreateInfoEXT;

  //=== VK_EXT_primitives_generated_query ===
  struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;

  //=== VK_KHR_ray_tracing_maintenance1 ===
  struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR;
  struct TraceRaysIndirectCommand2KHR;

  //=== VK_KHR_shader_untyped_pointers ===
  struct PhysicalDeviceShaderUntypedPointersFeaturesKHR;

  //=== VK_VALVE_video_encode_rgb_conversion ===
  struct PhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE;
  struct VideoEncodeRgbConversionCapabilitiesVALVE;
  struct VideoEncodeProfileRgbConversionInfoVALVE;
  struct VideoEncodeSessionRgbConversionCreateInfoVALVE;

  //=== VK_EXT_image_view_min_lod ===
  struct PhysicalDeviceImageViewMinLodFeaturesEXT;
  struct ImageViewMinLodCreateInfoEXT;

  //=== VK_EXT_multi_draw ===
  struct PhysicalDeviceMultiDrawFeaturesEXT;
  struct PhysicalDeviceMultiDrawPropertiesEXT;
  struct MultiDrawInfoEXT;
  struct MultiDrawIndexedInfoEXT;

  //=== VK_EXT_image_2d_view_of_3d ===
  struct PhysicalDeviceImage2DViewOf3DFeaturesEXT;

  //=== VK_EXT_shader_tile_image ===
  struct PhysicalDeviceShaderTileImageFeaturesEXT;
  struct PhysicalDeviceShaderTileImagePropertiesEXT;

  //=== VK_EXT_opacity_micromap ===
  struct MicromapBuildInfoEXT;
  struct MicromapUsageEXT;
  struct MicromapCreateInfoEXT;
  struct PhysicalDeviceOpacityMicromapFeaturesEXT;
  struct PhysicalDeviceOpacityMicromapPropertiesEXT;
  struct MicromapVersionInfoEXT;
  struct CopyMicromapToMemoryInfoEXT;
  struct CopyMemoryToMicromapInfoEXT;
  struct CopyMicromapInfoEXT;
  struct MicromapBuildSizesInfoEXT;
  struct AccelerationStructureTrianglesOpacityMicromapEXT;
  struct MicromapTriangleEXT;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_NV_displacement_micromap ===
  struct PhysicalDeviceDisplacementMicromapFeaturesNV;
  struct PhysicalDeviceDisplacementMicromapPropertiesNV;
  struct AccelerationStructureTrianglesDisplacementMicromapNV;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  //=== VK_HUAWEI_cluster_culling_shader ===
  struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI;
  struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEI;
  struct PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI;

  //=== VK_EXT_border_color_swizzle ===
  struct PhysicalDeviceBorderColorSwizzleFeaturesEXT;
  struct SamplerBorderColorComponentMappingCreateInfoEXT;

  //=== VK_EXT_pageable_device_local_memory ===
  struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT;

  //=== VK_ARM_shader_core_properties ===
  struct PhysicalDeviceShaderCorePropertiesARM;

  //=== VK_ARM_scheduling_controls ===
  struct DeviceQueueShaderCoreControlCreateInfoARM;
  struct PhysicalDeviceSchedulingControlsFeaturesARM;
  struct PhysicalDeviceSchedulingControlsPropertiesARM;

  //=== VK_EXT_image_sliced_view_of_3d ===
  struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT;
  struct ImageViewSlicedCreateInfoEXT;

  //=== VK_VALVE_descriptor_set_host_mapping ===
  struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;
  struct DescriptorSetBindingReferenceVALVE;
  struct DescriptorSetLayoutHostMappingInfoVALVE;

  //=== VK_EXT_non_seamless_cube_map ===
  struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT;

  //=== VK_ARM_render_pass_striped ===
  struct PhysicalDeviceRenderPassStripedFeaturesARM;
  struct PhysicalDeviceRenderPassStripedPropertiesARM;
  struct RenderPassStripeBeginInfoARM;
  struct RenderPassStripeInfoARM;
  struct RenderPassStripeSubmitInfoARM;

  //=== VK_NV_copy_memory_indirect ===
  struct PhysicalDeviceCopyMemoryIndirectFeaturesNV;

  //=== VK_NV_memory_decompression ===
  struct DecompressMemoryRegionNV;

  //=== VK_NV_device_generated_commands_compute ===
  struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV;
  struct ComputePipelineIndirectBufferInfoNV;
  struct PipelineIndirectDeviceAddressInfoNV;
  struct BindPipelineIndirectCommandNV;

  //=== VK_NV_ray_tracing_linear_swept_spheres ===
  struct PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV;
  struct AccelerationStructureGeometryLinearSweptSpheresDataNV;
  struct AccelerationStructureGeometrySpheresDataNV;

  //=== VK_NV_linear_color_attachment ===
  struct PhysicalDeviceLinearColorAttachmentFeaturesNV;

  //=== VK_KHR_shader_maximal_reconvergence ===
  struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR;

  //=== VK_EXT_image_compression_control_swapchain ===
  struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;

  //=== VK_QCOM_image_processing ===
  struct ImageViewSampleWeightCreateInfoQCOM;
  struct PhysicalDeviceImageProcessingFeaturesQCOM;
  struct PhysicalDeviceImageProcessingPropertiesQCOM;

  //=== VK_EXT_nested_command_buffer ===
  struct PhysicalDeviceNestedCommandBufferFeaturesEXT;
  struct PhysicalDeviceNestedCommandBufferPropertiesEXT;

#if defined( VK_USE_PLATFORM_OHOS )
  //=== VK_OHOS_external_memory ===
  struct NativeBufferUsageOHOS;
  struct NativeBufferPropertiesOHOS;
  struct NativeBufferFormatPropertiesOHOS;
  struct ImportNativeBufferInfoOHOS;
  struct MemoryGetNativeBufferInfoOHOS;
  struct ExternalFormatOHOS;
#endif /*VK_USE_PLATFORM_OHOS*/

  //=== VK_EXT_external_memory_acquire_unmodified ===
  struct ExternalMemoryAcquireUnmodifiedEXT;

  //=== VK_EXT_extended_dynamic_state3 ===
  struct PhysicalDeviceExtendedDynamicState3FeaturesEXT;
  struct PhysicalDeviceExtendedDynamicState3PropertiesEXT;
  struct ColorBlendEquationEXT;
  struct ColorBlendAdvancedEXT;

  //=== VK_EXT_subpass_merge_feedback ===
  struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT;
  struct RenderPassCreationControlEXT;
  struct RenderPassCreationFeedbackInfoEXT;
  struct RenderPassCreationFeedbackCreateInfoEXT;
  struct RenderPassSubpassFeedbackInfoEXT;
  struct RenderPassSubpassFeedbackCreateInfoEXT;

  //=== VK_LUNARG_direct_driver_loading ===
  struct DirectDriverLoadingInfoLUNARG;
  struct DirectDriverLoadingListLUNARG;

  //=== VK_ARM_tensors ===
  struct TensorDescriptionARM;
  struct TensorCreateInfoARM;
  struct TensorMemoryRequirementsInfoARM;
  struct BindTensorMemoryInfoARM;
  struct WriteDescriptorSetTensorARM;
  struct TensorFormatPropertiesARM;
  struct PhysicalDeviceTensorPropertiesARM;
  struct TensorMemoryBarrierARM;
  struct TensorDependencyInfoARM;
  struct PhysicalDeviceTensorFeaturesARM;
  struct DeviceTensorMemoryRequirementsARM;
  struct CopyTensorInfoARM;
  struct TensorCopyARM;
  struct MemoryDedicatedAllocateInfoTensorARM;
  struct PhysicalDeviceExternalTensorInfoARM;
  struct ExternalTensorPropertiesARM;
  struct ExternalMemoryTensorCreateInfoARM;
  struct PhysicalDeviceDescriptorBufferTensorFeaturesARM;
  struct PhysicalDeviceDescriptorBufferTensorPropertiesARM;
  struct DescriptorGetTensorInfoARM;
  struct TensorCaptureDescriptorDataInfoARM;
  struct TensorViewCaptureDescriptorDataInfoARM;
  struct FrameBoundaryTensorsARM;

  //=== VK_EXT_shader_module_identifier ===
  struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT;
  struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT;
  struct PipelineShaderStageModuleIdentifierCreateInfoEXT;
  struct ShaderModuleIdentifierEXT;

  //=== VK_EXT_rasterization_order_attachment_access ===
  struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
  using PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;

  //=== VK_NV_optical_flow ===
  struct PhysicalDeviceOpticalFlowFeaturesNV;
  struct PhysicalDeviceOpticalFlowPropertiesNV;
  struct OpticalFlowImageFormatInfoNV;
  struct OpticalFlowImageFormatPropertiesNV;
  struct OpticalFlowSessionCreateInfoNV;
  struct OpticalFlowSessionCreatePrivateDataInfoNV;
  struct OpticalFlowExecuteInfoNV;

  //=== VK_EXT_legacy_dithering ===
  struct PhysicalDeviceLegacyDitheringFeaturesEXT;

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
  //=== VK_ANDROID_external_format_resolve ===
  struct PhysicalDeviceExternalFormatResolveFeaturesANDROID;
  struct PhysicalDeviceExternalFormatResolvePropertiesANDROID;
  struct AndroidHardwareBufferFormatResolvePropertiesANDROID;
#endif /*VK_USE_PLATFORM_ANDROID_KHR*/

  //=== VK_AMD_anti_lag ===
  struct PhysicalDeviceAntiLagFeaturesAMD;
  struct AntiLagDataAMD;
  struct AntiLagPresentationInfoAMD;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_AMDX_dense_geometry_format ===
  struct PhysicalDeviceDenseGeometryFormatFeaturesAMDX;
  struct AccelerationStructureDenseGeometryFormatTrianglesDataAMDX;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  //=== VK_KHR_present_id2 ===
  struct SurfaceCapabilitiesPresentId2KHR;
  struct PresentId2KHR;
  struct PhysicalDevicePresentId2FeaturesKHR;

  //=== VK_KHR_present_wait2 ===
  struct SurfaceCapabilitiesPresentWait2KHR;
  struct PhysicalDevicePresentWait2FeaturesKHR;
  struct PresentWait2InfoKHR;

  //=== VK_KHR_ray_tracing_position_fetch ===
  struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR;

  //=== VK_EXT_shader_object ===
  struct PhysicalDeviceShaderObjectFeaturesEXT;
  struct PhysicalDeviceShaderObjectPropertiesEXT;
  struct ShaderCreateInfoEXT;

  //=== VK_KHR_pipeline_binary ===
  struct PhysicalDevicePipelineBinaryFeaturesKHR;
  struct PhysicalDevicePipelineBinaryPropertiesKHR;
  struct DevicePipelineBinaryInternalCacheControlKHR;
  struct PipelineBinaryKeyKHR;
  struct PipelineBinaryDataKHR;
  struct PipelineBinaryKeysAndDataKHR;
  struct PipelineBinaryCreateInfoKHR;
  struct PipelineBinaryInfoKHR;
  struct ReleaseCapturedPipelineDataInfoKHR;
  struct PipelineBinaryDataInfoKHR;
  struct PipelineCreateInfoKHR;
  struct PipelineBinaryHandlesInfoKHR;

  //=== VK_QCOM_tile_properties ===
  struct PhysicalDeviceTilePropertiesFeaturesQCOM;
  struct TilePropertiesQCOM;

  //=== VK_SEC_amigo_profiling ===
  struct PhysicalDeviceAmigoProfilingFeaturesSEC;
  struct AmigoProfilingSubmitInfoSEC;

  //=== VK_KHR_surface_maintenance1 ===
  struct SurfacePresentModeKHR;
  using SurfacePresentModeEXT = SurfacePresentModeKHR;
  struct SurfacePresentScalingCapabilitiesKHR;
  using SurfacePresentScalingCapabilitiesEXT = SurfacePresentScalingCapabilitiesKHR;
  struct SurfacePresentModeCompatibilityKHR;
  using SurfacePresentModeCompatibilityEXT = SurfacePresentModeCompatibilityKHR;

  //=== VK_KHR_swapchain_maintenance1 ===
  struct PhysicalDeviceSwapchainMaintenance1FeaturesKHR;
  using PhysicalDeviceSwapchainMaintenance1FeaturesEXT = PhysicalDeviceSwapchainMaintenance1FeaturesKHR;
  struct SwapchainPresentFenceInfoKHR;
  using SwapchainPresentFenceInfoEXT = SwapchainPresentFenceInfoKHR;
  struct SwapchainPresentModesCreateInfoKHR;
  using SwapchainPresentModesCreateInfoEXT = SwapchainPresentModesCreateInfoKHR;
  struct SwapchainPresentModeInfoKHR;
  using SwapchainPresentModeInfoEXT = SwapchainPresentModeInfoKHR;
  struct SwapchainPresentScalingCreateInfoKHR;
  using SwapchainPresentScalingCreateInfoEXT = SwapchainPresentScalingCreateInfoKHR;
  struct ReleaseSwapchainImagesInfoKHR;
  using ReleaseSwapchainImagesInfoEXT = ReleaseSwapchainImagesInfoKHR;

  //=== VK_QCOM_multiview_per_view_viewports ===
  struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM;

  //=== VK_NV_ray_tracing_invocation_reorder ===
  struct PhysicalDeviceRayTracingInvocationReorderPropertiesNV;
  struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV;

  //=== VK_NV_cooperative_vector ===
  struct PhysicalDeviceCooperativeVectorPropertiesNV;
  struct PhysicalDeviceCooperativeVectorFeaturesNV;
  struct CooperativeVectorPropertiesNV;
  struct ConvertCooperativeVectorMatrixInfoNV;

  //=== VK_NV_extended_sparse_address_space ===
  struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV;
  struct PhysicalDeviceExtendedSparseAddressSpacePropertiesNV;

  //=== VK_EXT_mutable_descriptor_type ===
  struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
  using PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
  struct MutableDescriptorTypeListEXT;
  using MutableDescriptorTypeListVALVE = MutableDescriptorTypeListEXT;
  struct MutableDescriptorTypeCreateInfoEXT;
  using MutableDescriptorTypeCreateInfoVALVE = MutableDescriptorTypeCreateInfoEXT;

  //=== VK_EXT_legacy_vertex_attributes ===
  struct PhysicalDeviceLegacyVertexAttributesFeaturesEXT;
  struct PhysicalDeviceLegacyVertexAttributesPropertiesEXT;

  //=== VK_EXT_layer_settings ===
  struct LayerSettingsCreateInfoEXT;
  struct LayerSettingEXT;

  //=== VK_ARM_shader_core_builtins ===
  struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM;
  struct PhysicalDeviceShaderCoreBuiltinsPropertiesARM;

  //=== VK_EXT_pipeline_library_group_handles ===
  struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT;

  //=== VK_EXT_dynamic_rendering_unused_attachments ===
  struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT;

  //=== VK_KHR_internally_synchronized_queues ===
  struct PhysicalDeviceInternallySynchronizedQueuesFeaturesKHR;

  //=== VK_NV_low_latency2 ===
  struct LatencySleepModeInfoNV;
  struct LatencySleepInfoNV;
  struct SetLatencyMarkerInfoNV;
  struct GetLatencyMarkerInfoNV;
  struct LatencyTimingsFrameReportNV;
  struct LatencySubmissionPresentIdNV;
  struct SwapchainLatencyCreateInfoNV;
  struct OutOfBandQueueTypeInfoNV;
  struct LatencySurfaceCapabilitiesNV;

  //=== VK_KHR_cooperative_matrix ===
  struct CooperativeMatrixPropertiesKHR;
  struct PhysicalDeviceCooperativeMatrixFeaturesKHR;
  struct PhysicalDeviceCooperativeMatrixPropertiesKHR;

  //=== VK_ARM_data_graph ===
  struct PhysicalDeviceDataGraphFeaturesARM;
  struct DataGraphPipelineConstantARM;
  struct DataGraphPipelineResourceInfoARM;
  struct DataGraphPipelineCompilerControlCreateInfoARM;
  struct DataGraphPipelineCreateInfoARM;
  struct DataGraphPipelineShaderModuleCreateInfoARM;
  struct DataGraphPipelineSessionCreateInfoARM;
  struct DataGraphPipelineSessionBindPointRequirementsInfoARM;
  struct DataGraphPipelineSessionBindPointRequirementARM;
  struct DataGraphPipelineSessionMemoryRequirementsInfoARM;
  struct BindDataGraphPipelineSessionMemoryInfoARM;
  struct DataGraphPipelineInfoARM;
  struct DataGraphPipelinePropertyQueryResultARM;
  struct DataGraphPipelineIdentifierCreateInfoARM;
  struct DataGraphPipelineDispatchInfoARM;
  struct PhysicalDeviceDataGraphProcessingEngineARM;
  struct QueueFamilyDataGraphPropertiesARM;
  struct DataGraphProcessingEngineCreateInfoARM;
  struct PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM;
  struct QueueFamilyDataGraphProcessingEnginePropertiesARM;
  struct PhysicalDeviceDataGraphOperationSupportARM;
  struct DataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM;

  //=== VK_QCOM_multiview_per_view_render_areas ===
  struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM;
  struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM;

  //=== VK_KHR_compute_shader_derivatives ===
  struct PhysicalDeviceComputeShaderDerivativesFeaturesKHR;
  using PhysicalDeviceComputeShaderDerivativesFeaturesNV = PhysicalDeviceComputeShaderDerivativesFeaturesKHR;
  struct PhysicalDeviceComputeShaderDerivativesPropertiesKHR;

  //=== VK_KHR_video_decode_av1 ===
  struct VideoDecodeAV1ProfileInfoKHR;
  struct VideoDecodeAV1CapabilitiesKHR;
  struct VideoDecodeAV1SessionParametersCreateInfoKHR;
  struct VideoDecodeAV1PictureInfoKHR;
  struct VideoDecodeAV1DpbSlotInfoKHR;

  //=== VK_KHR_video_encode_av1 ===
  struct PhysicalDeviceVideoEncodeAV1FeaturesKHR;
  struct VideoEncodeAV1CapabilitiesKHR;
  struct VideoEncodeAV1QualityLevelPropertiesKHR;
  struct VideoEncodeAV1SessionCreateInfoKHR;
  struct VideoEncodeAV1SessionParametersCreateInfoKHR;
  struct VideoEncodeAV1PictureInfoKHR;
  struct VideoEncodeAV1DpbSlotInfoKHR;
  struct VideoEncodeAV1ProfileInfoKHR;
  struct VideoEncodeAV1QIndexKHR;
  struct VideoEncodeAV1FrameSizeKHR;
  struct VideoEncodeAV1GopRemainingFrameInfoKHR;
  struct VideoEncodeAV1RateControlInfoKHR;
  struct VideoEncodeAV1RateControlLayerInfoKHR;

  //=== VK_KHR_video_decode_vp9 ===
  struct PhysicalDeviceVideoDecodeVP9FeaturesKHR;
  struct VideoDecodeVP9ProfileInfoKHR;
  struct VideoDecodeVP9CapabilitiesKHR;
  struct VideoDecodeVP9PictureInfoKHR;

  //=== VK_KHR_video_maintenance1 ===
  struct PhysicalDeviceVideoMaintenance1FeaturesKHR;
  struct VideoInlineQueryInfoKHR;

  //=== VK_NV_per_stage_descriptor_set ===
  struct PhysicalDevicePerStageDescriptorSetFeaturesNV;

  //=== VK_QCOM_image_processing2 ===
  struct PhysicalDeviceImageProcessing2FeaturesQCOM;
  struct PhysicalDeviceImageProcessing2PropertiesQCOM;
  struct SamplerBlockMatchWindowCreateInfoQCOM;

  //=== VK_QCOM_filter_cubic_weights ===
  struct PhysicalDeviceCubicWeightsFeaturesQCOM;
  struct SamplerCubicWeightsCreateInfoQCOM;
  struct BlitImageCubicWeightsInfoQCOM;

  //=== VK_QCOM_ycbcr_degamma ===
  struct PhysicalDeviceYcbcrDegammaFeaturesQCOM;
  struct SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM;

  //=== VK_QCOM_filter_cubic_clamp ===
  struct PhysicalDeviceCubicClampFeaturesQCOM;

  //=== VK_EXT_attachment_feedback_loop_dynamic_state ===
  struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT;

  //=== VK_KHR_unified_image_layouts ===
  struct PhysicalDeviceUnifiedImageLayoutsFeaturesKHR;
  struct AttachmentFeedbackLoopInfoEXT;

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
  //=== VK_QNX_external_memory_screen_buffer ===
  struct ScreenBufferPropertiesQNX;
  struct ScreenBufferFormatPropertiesQNX;
  struct ImportScreenBufferInfoQNX;
  struct ExternalFormatQNX;
  struct PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX;
#endif /*VK_USE_PLATFORM_SCREEN_QNX*/

  //=== VK_MSFT_layered_driver ===
  struct PhysicalDeviceLayeredDriverPropertiesMSFT;

  //=== VK_KHR_calibrated_timestamps ===
  struct CalibratedTimestampInfoKHR;
  using CalibratedTimestampInfoEXT = CalibratedTimestampInfoKHR;

  //=== VK_KHR_maintenance6 ===
  struct SetDescriptorBufferOffsetsInfoEXT;
  struct BindDescriptorBufferEmbeddedSamplersInfoEXT;

  //=== VK_NV_descriptor_pool_overallocation ===
  struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNV;

  //=== VK_QCOM_tile_memory_heap ===
  struct PhysicalDeviceTileMemoryHeapFeaturesQCOM;
  struct PhysicalDeviceTileMemoryHeapPropertiesQCOM;
  struct TileMemoryRequirementsQCOM;
  struct TileMemoryBindInfoQCOM;
  struct TileMemorySizeInfoQCOM;

  //=== VK_KHR_copy_memory_indirect ===
  struct StridedDeviceAddressRangeKHR;
  struct CopyMemoryIndirectCommandKHR;
  using CopyMemoryIndirectCommandNV = CopyMemoryIndirectCommandKHR;
  struct CopyMemoryIndirectInfoKHR;
  struct CopyMemoryToImageIndirectCommandKHR;
  using CopyMemoryToImageIndirectCommandNV = CopyMemoryToImageIndirectCommandKHR;
  struct CopyMemoryToImageIndirectInfoKHR;
  struct PhysicalDeviceCopyMemoryIndirectFeaturesKHR;
  struct PhysicalDeviceCopyMemoryIndirectPropertiesKHR;
  using PhysicalDeviceCopyMemoryIndirectPropertiesNV = PhysicalDeviceCopyMemoryIndirectPropertiesKHR;

  //=== VK_EXT_memory_decompression ===
  struct DecompressMemoryInfoEXT;
  struct DecompressMemoryRegionEXT;
  struct PhysicalDeviceMemoryDecompressionFeaturesEXT;
  using PhysicalDeviceMemoryDecompressionFeaturesNV = PhysicalDeviceMemoryDecompressionFeaturesEXT;
  struct PhysicalDeviceMemoryDecompressionPropertiesEXT;
  using PhysicalDeviceMemoryDecompressionPropertiesNV = PhysicalDeviceMemoryDecompressionPropertiesEXT;

  //=== VK_NV_display_stereo ===
  struct DisplaySurfaceStereoCreateInfoNV;
  struct DisplayModeStereoPropertiesNV;

  //=== VK_KHR_video_encode_intra_refresh ===
  struct VideoEncodeIntraRefreshCapabilitiesKHR;
  struct VideoEncodeSessionIntraRefreshCreateInfoKHR;
  struct VideoEncodeIntraRefreshInfoKHR;
  struct VideoReferenceIntraRefreshInfoKHR;
  struct PhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR;

  //=== VK_KHR_video_encode_quantization_map ===
  struct VideoEncodeQuantizationMapCapabilitiesKHR;
  struct VideoFormatQuantizationMapPropertiesKHR;
  struct VideoEncodeQuantizationMapInfoKHR;
  struct VideoEncodeQuantizationMapSessionParametersCreateInfoKHR;
  struct PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR;
  struct VideoEncodeH264QuantizationMapCapabilitiesKHR;
  struct VideoEncodeH265QuantizationMapCapabilitiesKHR;
  struct VideoFormatH265QuantizationMapPropertiesKHR;
  struct VideoEncodeAV1QuantizationMapCapabilitiesKHR;
  struct VideoFormatAV1QuantizationMapPropertiesKHR;

  //=== VK_NV_raw_access_chains ===
  struct PhysicalDeviceRawAccessChainsFeaturesNV;

  //=== VK_NV_external_compute_queue ===
  struct ExternalComputeQueueDeviceCreateInfoNV;
  struct ExternalComputeQueueCreateInfoNV;
  struct ExternalComputeQueueDataParamsNV;
  struct PhysicalDeviceExternalComputeQueuePropertiesNV;

  //=== VK_KHR_shader_relaxed_extended_instruction ===
  struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR;

  //=== VK_NV_command_buffer_inheritance ===
  struct PhysicalDeviceCommandBufferInheritanceFeaturesNV;

  //=== VK_KHR_maintenance7 ===
  struct PhysicalDeviceMaintenance7FeaturesKHR;
  struct PhysicalDeviceMaintenance7PropertiesKHR;
  struct PhysicalDeviceLayeredApiPropertiesListKHR;
  struct PhysicalDeviceLayeredApiPropertiesKHR;
  struct PhysicalDeviceLayeredApiVulkanPropertiesKHR;

  //=== VK_NV_shader_atomic_float16_vector ===
  struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;

  //=== VK_EXT_shader_replicated_composites ===
  struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXT;

  //=== VK_EXT_shader_float8 ===
  struct PhysicalDeviceShaderFloat8FeaturesEXT;

  //=== VK_NV_ray_tracing_validation ===
  struct PhysicalDeviceRayTracingValidationFeaturesNV;

  //=== VK_NV_cluster_acceleration_structure ===
  struct PhysicalDeviceClusterAccelerationStructureFeaturesNV;
  struct PhysicalDeviceClusterAccelerationStructurePropertiesNV;
  struct ClusterAccelerationStructureClustersBottomLevelInputNV;
  struct ClusterAccelerationStructureTriangleClusterInputNV;
  struct ClusterAccelerationStructureMoveObjectsInputNV;
  union ClusterAccelerationStructureOpInputNV;
  struct ClusterAccelerationStructureInputInfoNV;
  struct ClusterAccelerationStructureCommandsInfoNV;
  struct StridedDeviceAddressNV;
  struct ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV;
  struct ClusterAccelerationStructureMoveObjectsInfoNV;
  struct ClusterAccelerationStructureBuildClustersBottomLevelInfoNV;
  struct ClusterAccelerationStructureBuildTriangleClusterInfoNV;
  struct ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV;
  struct ClusterAccelerationStructureInstantiateClusterInfoNV;
  struct ClusterAccelerationStructureGetTemplateIndicesInfoNV;
  struct RayTracingPipelineClusterAccelerationStructureCreateInfoNV;

  //=== VK_NV_partitioned_acceleration_structure ===
  struct PhysicalDevicePartitionedAccelerationStructureFeaturesNV;
  struct PhysicalDevicePartitionedAccelerationStructurePropertiesNV;
  struct PartitionedAccelerationStructureFlagsNV;
  struct BuildPartitionedAccelerationStructureIndirectCommandNV;
  struct PartitionedAccelerationStructureWriteInstanceDataNV;
  struct PartitionedAccelerationStructureUpdateInstanceDataNV;
  struct PartitionedAccelerationStructureWritePartitionTranslationDataNV;
  struct WriteDescriptorSetPartitionedAccelerationStructureNV;
  struct PartitionedAccelerationStructureInstancesInputNV;
  struct BuildPartitionedAccelerationStructureInfoNV;

  //=== VK_EXT_device_generated_commands ===
  struct PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT;
  struct PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT;
  struct GeneratedCommandsMemoryRequirementsInfoEXT;
  struct IndirectExecutionSetCreateInfoEXT;
  union IndirectExecutionSetInfoEXT;
  struct IndirectExecutionSetPipelineInfoEXT;
  struct IndirectExecutionSetShaderInfoEXT;
  struct GeneratedCommandsInfoEXT;
  struct WriteIndirectExecutionSetPipelineEXT;
  struct IndirectCommandsLayoutCreateInfoEXT;
  struct IndirectCommandsLayoutTokenEXT;
  struct DrawIndirectCountIndirectCommandEXT;
  struct IndirectCommandsVertexBufferTokenEXT;
  struct BindVertexBufferIndirectCommandEXT;
  struct IndirectCommandsIndexBufferTokenEXT;
  struct BindIndexBufferIndirectCommandEXT;
  struct IndirectCommandsPushConstantTokenEXT;
  struct IndirectCommandsExecutionSetTokenEXT;
  union IndirectCommandsTokenDataEXT;
  struct IndirectExecutionSetShaderLayoutInfoEXT;
  struct GeneratedCommandsPipelineInfoEXT;
  struct GeneratedCommandsShaderInfoEXT;
  struct WriteIndirectExecutionSetShaderEXT;

  //=== VK_KHR_maintenance8 ===
  struct MemoryBarrierAccessFlags3KHR;
  struct PhysicalDeviceMaintenance8FeaturesKHR;

  //=== VK_MESA_image_alignment_control ===
  struct PhysicalDeviceImageAlignmentControlFeaturesMESA;
  struct PhysicalDeviceImageAlignmentControlPropertiesMESA;
  struct ImageAlignmentControlCreateInfoMESA;

  //=== VK_KHR_shader_fma ===
  struct PhysicalDeviceShaderFmaFeaturesKHR;

  //=== VK_NV_push_constant_bank ===
  struct PushConstantBankInfoNV;
  struct PhysicalDevicePushConstantBankFeaturesNV;
  struct PhysicalDevicePushConstantBankPropertiesNV;

  //=== VK_EXT_ray_tracing_invocation_reorder ===
  struct PhysicalDeviceRayTracingInvocationReorderPropertiesEXT;
  struct PhysicalDeviceRayTracingInvocationReorderFeaturesEXT;

  //=== VK_EXT_depth_clamp_control ===
  struct PhysicalDeviceDepthClampControlFeaturesEXT;
  struct PipelineViewportDepthClampControlCreateInfoEXT;
  struct DepthClampRangeEXT;

  //=== VK_KHR_maintenance9 ===
  struct PhysicalDeviceMaintenance9FeaturesKHR;
  struct PhysicalDeviceMaintenance9PropertiesKHR;
  struct QueueFamilyOwnershipTransferPropertiesKHR;

  //=== VK_KHR_video_maintenance2 ===
  struct PhysicalDeviceVideoMaintenance2FeaturesKHR;
  struct VideoDecodeH264InlineSessionParametersInfoKHR;
  struct VideoDecodeH265InlineSessionParametersInfoKHR;
  struct VideoDecodeAV1InlineSessionParametersInfoKHR;

#if defined( VK_USE_PLATFORM_OHOS )
  //=== VK_OHOS_surface ===
  struct SurfaceCreateInfoOHOS;
#endif /*VK_USE_PLATFORM_OHOS*/

  //=== VK_HUAWEI_hdr_vivid ===
  struct PhysicalDeviceHdrVividFeaturesHUAWEI;
  struct HdrVividDynamicMetadataHUAWEI;

  //=== VK_NV_cooperative_matrix2 ===
  struct CooperativeMatrixFlexibleDimensionsPropertiesNV;
  struct PhysicalDeviceCooperativeMatrix2FeaturesNV;
  struct PhysicalDeviceCooperativeMatrix2PropertiesNV;

  //=== VK_ARM_pipeline_opacity_micromap ===
  struct PhysicalDevicePipelineOpacityMicromapFeaturesARM;

#if defined( VK_USE_PLATFORM_METAL_EXT )
  //=== VK_EXT_external_memory_metal ===
  struct ImportMemoryMetalHandleInfoEXT;
  struct MemoryMetalHandlePropertiesEXT;
  struct MemoryGetMetalHandleInfoEXT;
#endif /*VK_USE_PLATFORM_METAL_EXT*/

  //=== VK_KHR_depth_clamp_zero_one ===
  struct PhysicalDeviceDepthClampZeroOneFeaturesKHR;
  using PhysicalDeviceDepthClampZeroOneFeaturesEXT = PhysicalDeviceDepthClampZeroOneFeaturesKHR;

  //=== VK_ARM_performance_counters_by_region ===
  struct PhysicalDevicePerformanceCountersByRegionFeaturesARM;
  struct PhysicalDevicePerformanceCountersByRegionPropertiesARM;
  struct PerformanceCounterARM;
  struct PerformanceCounterDescriptionARM;
  struct RenderPassPerformanceCountersByRegionBeginInfoARM;

  //=== VK_EXT_vertex_attribute_robustness ===
  struct PhysicalDeviceVertexAttributeRobustnessFeaturesEXT;

  //=== VK_ARM_format_pack ===
  struct PhysicalDeviceFormatPackFeaturesARM;

  //=== VK_VALVE_fragment_density_map_layered ===
  struct PhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE;
  struct PhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE;
  struct PipelineFragmentDensityMapLayeredCreateInfoVALVE;

  //=== VK_KHR_robustness2 ===
  struct PhysicalDeviceRobustness2FeaturesKHR;
  using PhysicalDeviceRobustness2FeaturesEXT = PhysicalDeviceRobustness2FeaturesKHR;
  struct PhysicalDeviceRobustness2PropertiesKHR;
  using PhysicalDeviceRobustness2PropertiesEXT = PhysicalDeviceRobustness2PropertiesKHR;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_NV_present_metering ===
  struct SetPresentConfigNV;
  struct PhysicalDevicePresentMeteringFeaturesNV;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  //=== VK_EXT_fragment_density_map_offset ===
  struct PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
  using PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
  struct PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
  using PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
  struct RenderPassFragmentDensityMapOffsetEndInfoEXT;
  using SubpassFragmentDensityMapOffsetEndInfoQCOM = RenderPassFragmentDensityMapOffsetEndInfoEXT;

  //=== VK_EXT_zero_initialize_device_memory ===
  struct PhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT;

  //=== VK_KHR_present_mode_fifo_latest_ready ===
  struct PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
  using PhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = PhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;

  //=== VK_EXT_shader_64bit_indexing ===
  struct PhysicalDeviceShader64BitIndexingFeaturesEXT;

  //=== VK_EXT_custom_resolve ===
  struct PhysicalDeviceCustomResolveFeaturesEXT;
  struct BeginCustomResolveInfoEXT;
  struct CustomResolveCreateInfoEXT;

  //=== VK_QCOM_data_graph_model ===
  struct PipelineCacheHeaderVersionDataGraphQCOM;
  struct DataGraphPipelineBuiltinModelCreateInfoQCOM;
  struct PhysicalDeviceDataGraphModelFeaturesQCOM;

  //=== VK_KHR_maintenance10 ===
  struct PhysicalDeviceMaintenance10FeaturesKHR;
  struct PhysicalDeviceMaintenance10PropertiesKHR;
  struct RenderingEndInfoKHR;
  using RenderingEndInfoEXT = RenderingEndInfoKHR;
  struct RenderingAttachmentFlagsInfoKHR;
  struct ResolveImageModeInfoKHR;

  //=== VK_EXT_shader_long_vector ===
  struct PhysicalDeviceShaderLongVectorFeaturesEXT;
  struct PhysicalDeviceShaderLongVectorPropertiesEXT;

  //=== VK_SEC_pipeline_cache_incremental_mode ===
  struct PhysicalDevicePipelineCacheIncrementalModeFeaturesSEC;

  //=== VK_EXT_shader_uniform_buffer_unsized_array ===
  struct PhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT;

  //=== VK_NV_compute_occupancy_priority ===
  struct ComputeOccupancyPriorityParametersNV;
  struct PhysicalDeviceComputeOccupancyPriorityFeaturesNV;

  //=== VK_EXT_shader_subgroup_partitioned ===
  struct PhysicalDeviceShaderSubgroupPartitionedFeaturesEXT;

#if defined( VK_USE_PLATFORM_UBM_SEC )
  //=== VK_SEC_ubm_surface ===
  struct UbmSurfaceCreateInfoSEC;
#endif /*VK_USE_PLATFORM_UBM_SEC*/

  //===================================
  //=== HANDLE forward declarations ===
  //===================================

  //=== VK_VERSION_1_0 ===
  class Instance;
  class PhysicalDevice;
  class Device;
  class Queue;
  class DeviceMemory;
  class Fence;
  class Semaphore;
  class QueryPool;
  class Buffer;
  class Image;
  class ImageView;
  class CommandPool;
  class CommandBuffer;
  class Event;
  class BufferView;
  class ShaderModule;
  class PipelineCache;
  class Pipeline;
  class PipelineLayout;
  class Sampler;
  class DescriptorPool;
  class DescriptorSet;
  class DescriptorSetLayout;
  class Framebuffer;
  class RenderPass;

  //=== VK_VERSION_1_1 ===
  class DescriptorUpdateTemplate;
  class SamplerYcbcrConversion;

  //=== VK_VERSION_1_3 ===
  class PrivateDataSlot;

  //=== VK_KHR_surface ===
  class SurfaceKHR;

  //=== VK_KHR_swapchain ===
  class SwapchainKHR;

  //=== VK_KHR_display ===
  class DisplayKHR;
  class DisplayModeKHR;

  //=== VK_EXT_debug_report ===
  class DebugReportCallbackEXT;

  //=== VK_KHR_video_queue ===
  class VideoSessionKHR;
  class VideoSessionParametersKHR;

  //=== VK_NVX_binary_import ===
  class CuModuleNVX;
  class CuFunctionNVX;

  //=== VK_EXT_debug_utils ===
  class DebugUtilsMessengerEXT;

  //=== VK_EXT_descriptor_heap ===
  class TensorARM;

  //=== VK_KHR_acceleration_structure ===
  class AccelerationStructureKHR;

  //=== VK_EXT_validation_cache ===
  class ValidationCacheEXT;

  //=== VK_NV_ray_tracing ===
  class AccelerationStructureNV;

  //=== VK_INTEL_performance_query ===
  class PerformanceConfigurationINTEL;

  //=== VK_KHR_deferred_host_operations ===
  class DeferredOperationKHR;

  //=== VK_NV_device_generated_commands ===
  class IndirectCommandsLayoutNV;

#if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_NV_cuda_kernel_launch ===
  class CudaModuleNV;
  class CudaFunctionNV;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
  //=== VK_FUCHSIA_buffer_collection ===
  class BufferCollectionFUCHSIA;
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  //=== VK_EXT_opacity_micromap ===
  class MicromapEXT;

  //=== VK_ARM_tensors ===
  class TensorARM;
  class TensorViewARM;

  //=== VK_NV_optical_flow ===
  class OpticalFlowSessionNV;

  //=== VK_EXT_shader_object ===
  class ShaderEXT;

  //=== VK_KHR_pipeline_binary ===
  class PipelineBinaryKHR;

  //=== VK_ARM_data_graph ===
  class DataGraphPipelineSessionARM;

  //=== VK_NV_external_compute_queue ===
  class ExternalComputeQueueNV;

  //=== VK_EXT_device_generated_commands ===
  class IndirectCommandsLayoutEXT;
  class IndirectExecutionSetEXT;

  typedef void( VKAPI_PTR * PFN_VoidFunction )();

#ifndef VULKAN_HPP_NO_SMART_HANDLE
  //======================
  //=== UNIQUE HANDLEs ===
  //======================

  //=== VK_VERSION_1_0 ===

  template <>
  class UniqueHandleTraits<Instance>
  {
  public:
    using deleter = detail::ObjectDestroy<detail::NoParent>;
  };

  using UniqueInstance = UniqueHandle<Instance>;

  template <>
  class UniqueHandleTraits<Device>
  {
  public:
    using deleter = detail::ObjectDestroy<detail::NoParent>;
  };

  using UniqueDevice = UniqueHandle<Device>;

  template <>
  class UniqueHandleTraits<DeviceMemory>
  {
  public:
    using deleter = detail::ObjectFree<Device>;
  };

  using UniqueDeviceMemory = UniqueHandle<DeviceMemory>;

  template <>
  class UniqueHandleTraits<Fence>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueFence = UniqueHandle<Fence>;

  template <>
  class UniqueHandleTraits<Semaphore>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueSemaphore = UniqueHandle<Semaphore>;

  template <>
  class UniqueHandleTraits<QueryPool>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueQueryPool = UniqueHandle<QueryPool>;

  template <>
  class UniqueHandleTraits<Buffer>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueBuffer = UniqueHandle<Buffer>;

  template <>
  class UniqueHandleTraits<Image>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueImage = UniqueHandle<Image>;

  template <>
  class UniqueHandleTraits<ImageView>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueImageView = UniqueHandle<ImageView>;

  template <>
  class UniqueHandleTraits<CommandPool>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueCommandPool = UniqueHandle<CommandPool>;

  template <>
  class UniqueHandleTraits<CommandBuffer>
  {
  public:
    using deleter = detail::PoolFree<Device, CommandPool>;
  };

  using UniqueCommandBuffer = UniqueHandle<CommandBuffer>;

  template <>
  class UniqueHandleTraits<Event>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueEvent = UniqueHandle<Event>;

  template <>
  class UniqueHandleTraits<BufferView>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueBufferView = UniqueHandle<BufferView>;

  template <>
  class UniqueHandleTraits<ShaderModule>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueShaderModule = UniqueHandle<ShaderModule>;

  template <>
  class UniqueHandleTraits<PipelineCache>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniquePipelineCache = UniqueHandle<PipelineCache>;

  template <>
  class UniqueHandleTraits<Pipeline>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniquePipeline = UniqueHandle<Pipeline>;

  template <>
  class UniqueHandleTraits<PipelineLayout>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniquePipelineLayout = UniqueHandle<PipelineLayout>;

  template <>
  class UniqueHandleTraits<Sampler>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueSampler = UniqueHandle<Sampler>;

  template <>
  class UniqueHandleTraits<DescriptorPool>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueDescriptorPool = UniqueHandle<DescriptorPool>;

  template <>
  class UniqueHandleTraits<DescriptorSet>
  {
  public:
    using deleter = detail::PoolFree<Device, DescriptorPool>;
  };

  using UniqueDescriptorSet = UniqueHandle<DescriptorSet>;

  template <>
  class UniqueHandleTraits<DescriptorSetLayout>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueDescriptorSetLayout = UniqueHandle<DescriptorSetLayout>;

  template <>
  class UniqueHandleTraits<Framebuffer>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueFramebuffer = UniqueHandle<Framebuffer>;

  template <>
  class UniqueHandleTraits<RenderPass>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueRenderPass = UniqueHandle<RenderPass>;

  //=== VK_VERSION_1_1 ===

  template <>
  class UniqueHandleTraits<DescriptorUpdateTemplate>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueDescriptorUpdateTemplate    = UniqueHandle<DescriptorUpdateTemplate>;
  using UniqueDescriptorUpdateTemplateKHR = UniqueHandle<DescriptorUpdateTemplate>;

  template <>
  class UniqueHandleTraits<SamplerYcbcrConversion>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueSamplerYcbcrConversion    = UniqueHandle<SamplerYcbcrConversion>;
  using UniqueSamplerYcbcrConversionKHR = UniqueHandle<SamplerYcbcrConversion>;

  //=== VK_VERSION_1_3 ===

  template <>
  class UniqueHandleTraits<PrivateDataSlot>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniquePrivateDataSlot    = UniqueHandle<PrivateDataSlot>;
  using UniquePrivateDataSlotEXT = UniqueHandle<PrivateDataSlot>;

  //=== VK_KHR_surface ===

  template <>
  class UniqueHandleTraits<SurfaceKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Instance>;
  };

  using UniqueSurfaceKHR = UniqueHandle<SurfaceKHR>;

  //=== VK_KHR_swapchain ===

  template <>
  class UniqueHandleTraits<SwapchainKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueSwapchainKHR = UniqueHandle<SwapchainKHR>;

  //=== VK_KHR_display ===

  template <>
  class UniqueHandleTraits<DisplayKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<PhysicalDevice>;
  };

  using UniqueDisplayKHR = UniqueHandle<DisplayKHR>;

  //=== VK_EXT_debug_report ===

  template <>
  class UniqueHandleTraits<DebugReportCallbackEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Instance>;
  };

  using UniqueDebugReportCallbackEXT = UniqueHandle<DebugReportCallbackEXT>;

  //=== VK_KHR_video_queue ===

  template <>
  class UniqueHandleTraits<VideoSessionKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueVideoSessionKHR = UniqueHandle<VideoSessionKHR>;

  template <>
  class UniqueHandleTraits<VideoSessionParametersKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueVideoSessionParametersKHR = UniqueHandle<VideoSessionParametersKHR>;

  //=== VK_NVX_binary_import ===

  template <>
  class UniqueHandleTraits<CuModuleNVX>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueCuModuleNVX = UniqueHandle<CuModuleNVX>;

  template <>
  class UniqueHandleTraits<CuFunctionNVX>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueCuFunctionNVX = UniqueHandle<CuFunctionNVX>;

  //=== VK_EXT_debug_utils ===

  template <>
  class UniqueHandleTraits<DebugUtilsMessengerEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Instance>;
  };

  using UniqueDebugUtilsMessengerEXT = UniqueHandle<DebugUtilsMessengerEXT>;

  //=== VK_EXT_descriptor_heap ===

  template <>
  class UniqueHandleTraits<TensorARM>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueTensorARM = UniqueHandle<TensorARM>;

  //=== VK_KHR_acceleration_structure ===

  template <>
  class UniqueHandleTraits<AccelerationStructureKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueAccelerationStructureKHR = UniqueHandle<AccelerationStructureKHR>;

  //=== VK_EXT_validation_cache ===

  template <>
  class UniqueHandleTraits<ValidationCacheEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueValidationCacheEXT = UniqueHandle<ValidationCacheEXT>;

  //=== VK_NV_ray_tracing ===

  template <>
  class UniqueHandleTraits<AccelerationStructureNV>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueAccelerationStructureNV = UniqueHandle<AccelerationStructureNV>;

  //=== VK_INTEL_performance_query ===

  template <>
  class UniqueHandleTraits<PerformanceConfigurationINTEL>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniquePerformanceConfigurationINTEL = UniqueHandle<PerformanceConfigurationINTEL>;

  //=== VK_KHR_deferred_host_operations ===

  template <>
  class UniqueHandleTraits<DeferredOperationKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueDeferredOperationKHR = UniqueHandle<DeferredOperationKHR>;

  //=== VK_NV_device_generated_commands ===

  template <>
  class UniqueHandleTraits<IndirectCommandsLayoutNV>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueIndirectCommandsLayoutNV = UniqueHandle<IndirectCommandsLayoutNV>;

#  if defined( VK_ENABLE_BETA_EXTENSIONS )
  //=== VK_NV_cuda_kernel_launch ===

  template <>
  class UniqueHandleTraits<CudaModuleNV>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueCudaModuleNV = UniqueHandle<CudaModuleNV>;

  template <>
  class UniqueHandleTraits<CudaFunctionNV>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueCudaFunctionNV = UniqueHandle<CudaFunctionNV>;
#  endif /*VK_ENABLE_BETA_EXTENSIONS*/

#  if defined( VK_USE_PLATFORM_FUCHSIA )
  //=== VK_FUCHSIA_buffer_collection ===

  template <>
  class UniqueHandleTraits<BufferCollectionFUCHSIA>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueBufferCollectionFUCHSIA = UniqueHandle<BufferCollectionFUCHSIA>;
#  endif /*VK_USE_PLATFORM_FUCHSIA*/

  //=== VK_EXT_opacity_micromap ===

  template <>
  class UniqueHandleTraits<MicromapEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueMicromapEXT = UniqueHandle<MicromapEXT>;

  //=== VK_ARM_tensors ===

  template <>
  class UniqueHandleTraits<TensorViewARM>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueTensorViewARM = UniqueHandle<TensorViewARM>;

  //=== VK_NV_optical_flow ===

  template <>
  class UniqueHandleTraits<OpticalFlowSessionNV>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueOpticalFlowSessionNV = UniqueHandle<OpticalFlowSessionNV>;

  //=== VK_EXT_shader_object ===

  template <>
  class UniqueHandleTraits<ShaderEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueShaderEXT = UniqueHandle<ShaderEXT>;

  //=== VK_KHR_pipeline_binary ===

  template <>
  class UniqueHandleTraits<PipelineBinaryKHR>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniquePipelineBinaryKHR = UniqueHandle<PipelineBinaryKHR>;

  //=== VK_ARM_data_graph ===

  template <>
  class UniqueHandleTraits<DataGraphPipelineSessionARM>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueDataGraphPipelineSessionARM = UniqueHandle<DataGraphPipelineSessionARM>;

  //=== VK_NV_external_compute_queue ===

  template <>
  class UniqueHandleTraits<ExternalComputeQueueNV>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueExternalComputeQueueNV = UniqueHandle<ExternalComputeQueueNV>;

  //=== VK_EXT_device_generated_commands ===

  template <>
  class UniqueHandleTraits<IndirectCommandsLayoutEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueIndirectCommandsLayoutEXT = UniqueHandle<IndirectCommandsLayoutEXT>;

  template <>
  class UniqueHandleTraits<IndirectExecutionSetEXT>
  {
  public:
    using deleter = detail::ObjectDestroy<Device>;
  };

  using UniqueIndirectExecutionSetEXT = UniqueHandle<IndirectExecutionSetEXT>;
#endif /*VULKAN_HPP_NO_SMART_HANDLE*/

  //===============
  //=== HANDLEs ===
  //===============

  template <typename Type>
  struct isVulkanHandleType
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = false;
  };

  // wrapper class for handle VkSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkSurfaceKHR.html
  class SurfaceKHR
  {
  public:
    using CType      = VkSurfaceKHR;
    using NativeType = VkSurfaceKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eSurfaceKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eSurfaceKHR;

  public:
    SurfaceKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    SurfaceKHR( SurfaceKHR const & rhs )             = default;
    SurfaceKHR & operator=( SurfaceKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    SurfaceKHR( SurfaceKHR && rhs )             = default;
    SurfaceKHR & operator=( SurfaceKHR && rhs ) = default;
#else
    SurfaceKHR( SurfaceKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_surfaceKHR( exchange( rhs.m_surfaceKHR, {} ) ) {}

    SurfaceKHR & operator=( SurfaceKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_surfaceKHR = exchange( rhs.m_surfaceKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR SurfaceKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT SurfaceKHR( VkSurfaceKHR surfaceKHR ) VULKAN_HPP_NOEXCEPT : m_surfaceKHR( surfaceKHR ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    SurfaceKHR & operator=( VkSurfaceKHR surfaceKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_surfaceKHR = surfaceKHR;
      return *this;
    }
#endif

    SurfaceKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_surfaceKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSurfaceKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_surfaceKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_surfaceKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_surfaceKHR == VK_NULL_HANDLE;
    }

  private:
    VkSurfaceKHR m_surfaceKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eSurfaceKHR>
  {
    using Type = SurfaceKHR;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eSurfaceKHR>
  {
    using Type = SurfaceKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkSurfaceKHR, VK_NULL_HANDLE>
  {
    using Type = SurfaceKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<SurfaceKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDebugReportCallbackEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugReportCallbackEXT.html
  class DebugReportCallbackEXT
  {
  public:
    using CType      = VkDebugReportCallbackEXT;
    using NativeType = VkDebugReportCallbackEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDebugReportCallbackEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDebugReportCallbackEXT;

  public:
    DebugReportCallbackEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DebugReportCallbackEXT( DebugReportCallbackEXT const & rhs )             = default;
    DebugReportCallbackEXT & operator=( DebugReportCallbackEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DebugReportCallbackEXT( DebugReportCallbackEXT && rhs )             = default;
    DebugReportCallbackEXT & operator=( DebugReportCallbackEXT && rhs ) = default;
#else
    DebugReportCallbackEXT( DebugReportCallbackEXT && rhs ) VULKAN_HPP_NOEXCEPT : m_debugReportCallbackEXT( exchange( rhs.m_debugReportCallbackEXT, {} ) ) {}

    DebugReportCallbackEXT & operator=( DebugReportCallbackEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_debugReportCallbackEXT = exchange( rhs.m_debugReportCallbackEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DebugReportCallbackEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DebugReportCallbackEXT( VkDebugReportCallbackEXT debugReportCallbackEXT ) VULKAN_HPP_NOEXCEPT
      : m_debugReportCallbackEXT( debugReportCallbackEXT )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DebugReportCallbackEXT & operator=( VkDebugReportCallbackEXT debugReportCallbackEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_debugReportCallbackEXT = debugReportCallbackEXT;
      return *this;
    }
#endif

    DebugReportCallbackEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_debugReportCallbackEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDebugReportCallbackEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_debugReportCallbackEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_debugReportCallbackEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_debugReportCallbackEXT == VK_NULL_HANDLE;
    }

  private:
    VkDebugReportCallbackEXT m_debugReportCallbackEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDebugReportCallbackEXT>
  {
    using Type = DebugReportCallbackEXT;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDebugReportCallbackEXT>
  {
    using Type = DebugReportCallbackEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDebugReportCallbackEXT, VK_NULL_HANDLE>
  {
    using Type = DebugReportCallbackEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<DebugReportCallbackEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDebugUtilsMessengerEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDebugUtilsMessengerEXT.html
  class DebugUtilsMessengerEXT
  {
  public:
    using CType      = VkDebugUtilsMessengerEXT;
    using NativeType = VkDebugUtilsMessengerEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDebugUtilsMessengerEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    DebugUtilsMessengerEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DebugUtilsMessengerEXT( DebugUtilsMessengerEXT const & rhs )             = default;
    DebugUtilsMessengerEXT & operator=( DebugUtilsMessengerEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DebugUtilsMessengerEXT( DebugUtilsMessengerEXT && rhs )             = default;
    DebugUtilsMessengerEXT & operator=( DebugUtilsMessengerEXT && rhs ) = default;
#else
    DebugUtilsMessengerEXT( DebugUtilsMessengerEXT && rhs ) VULKAN_HPP_NOEXCEPT : m_debugUtilsMessengerEXT( exchange( rhs.m_debugUtilsMessengerEXT, {} ) ) {}

    DebugUtilsMessengerEXT & operator=( DebugUtilsMessengerEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_debugUtilsMessengerEXT = exchange( rhs.m_debugUtilsMessengerEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DebugUtilsMessengerEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DebugUtilsMessengerEXT( VkDebugUtilsMessengerEXT debugUtilsMessengerEXT ) VULKAN_HPP_NOEXCEPT
      : m_debugUtilsMessengerEXT( debugUtilsMessengerEXT )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DebugUtilsMessengerEXT & operator=( VkDebugUtilsMessengerEXT debugUtilsMessengerEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_debugUtilsMessengerEXT = debugUtilsMessengerEXT;
      return *this;
    }
#endif

    DebugUtilsMessengerEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_debugUtilsMessengerEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDebugUtilsMessengerEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_debugUtilsMessengerEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_debugUtilsMessengerEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_debugUtilsMessengerEXT == VK_NULL_HANDLE;
    }

  private:
    VkDebugUtilsMessengerEXT m_debugUtilsMessengerEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDebugUtilsMessengerEXT>
  {
    using Type = DebugUtilsMessengerEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDebugUtilsMessengerEXT, VK_NULL_HANDLE>
  {
    using Type = DebugUtilsMessengerEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<DebugUtilsMessengerEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDisplayKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayKHR.html
  class DisplayKHR
  {
  public:
    using CType      = VkDisplayKHR;
    using NativeType = VkDisplayKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDisplayKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDisplayKHR;

  public:
    DisplayKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DisplayKHR( DisplayKHR const & rhs )             = default;
    DisplayKHR & operator=( DisplayKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DisplayKHR( DisplayKHR && rhs )             = default;
    DisplayKHR & operator=( DisplayKHR && rhs ) = default;
#else
    DisplayKHR( DisplayKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_displayKHR( exchange( rhs.m_displayKHR, {} ) ) {}

    DisplayKHR & operator=( DisplayKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_displayKHR = exchange( rhs.m_displayKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DisplayKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DisplayKHR( VkDisplayKHR displayKHR ) VULKAN_HPP_NOEXCEPT : m_displayKHR( displayKHR ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DisplayKHR & operator=( VkDisplayKHR displayKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_displayKHR = displayKHR;
      return *this;
    }
#endif

    DisplayKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_displayKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDisplayKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_displayKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_displayKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_displayKHR == VK_NULL_HANDLE;
    }

  private:
    VkDisplayKHR m_displayKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDisplayKHR>
  {
    using Type = DisplayKHR;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDisplayKHR>
  {
    using Type = DisplayKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDisplayKHR, VK_NULL_HANDLE>
  {
    using Type = DisplayKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<DisplayKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkSwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkSwapchainKHR.html
  class SwapchainKHR
  {
  public:
    using CType      = VkSwapchainKHR;
    using NativeType = VkSwapchainKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eSwapchainKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eSwapchainKHR;

  public:
    SwapchainKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    SwapchainKHR( SwapchainKHR const & rhs )             = default;
    SwapchainKHR & operator=( SwapchainKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    SwapchainKHR( SwapchainKHR && rhs )             = default;
    SwapchainKHR & operator=( SwapchainKHR && rhs ) = default;
#else
    SwapchainKHR( SwapchainKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_swapchainKHR( exchange( rhs.m_swapchainKHR, {} ) ) {}

    SwapchainKHR & operator=( SwapchainKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_swapchainKHR = exchange( rhs.m_swapchainKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR SwapchainKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT SwapchainKHR( VkSwapchainKHR swapchainKHR ) VULKAN_HPP_NOEXCEPT : m_swapchainKHR( swapchainKHR ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    SwapchainKHR & operator=( VkSwapchainKHR swapchainKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_swapchainKHR = swapchainKHR;
      return *this;
    }
#endif

    SwapchainKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_swapchainKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSwapchainKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_swapchainKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_swapchainKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_swapchainKHR == VK_NULL_HANDLE;
    }

  private:
    VkSwapchainKHR m_swapchainKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eSwapchainKHR>
  {
    using Type = SwapchainKHR;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eSwapchainKHR>
  {
    using Type = SwapchainKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkSwapchainKHR, VK_NULL_HANDLE>
  {
    using Type = SwapchainKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<SwapchainKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkSemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkSemaphore.html
  class Semaphore
  {
  public:
    using CType      = VkSemaphore;
    using NativeType = VkSemaphore;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eSemaphore;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eSemaphore;

  public:
    Semaphore() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Semaphore( Semaphore const & rhs )             = default;
    Semaphore & operator=( Semaphore const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Semaphore( Semaphore && rhs )             = default;
    Semaphore & operator=( Semaphore && rhs ) = default;
#else
    Semaphore( Semaphore && rhs ) VULKAN_HPP_NOEXCEPT : m_semaphore( exchange( rhs.m_semaphore, {} ) ) {}

    Semaphore & operator=( Semaphore && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_semaphore = exchange( rhs.m_semaphore, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Semaphore( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Semaphore( VkSemaphore semaphore ) VULKAN_HPP_NOEXCEPT : m_semaphore( semaphore ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Semaphore & operator=( VkSemaphore semaphore ) VULKAN_HPP_NOEXCEPT
    {
      m_semaphore = semaphore;
      return *this;
    }
#endif

    Semaphore & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_semaphore = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSemaphore() const VULKAN_HPP_NOEXCEPT
    {
      return m_semaphore;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_semaphore != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_semaphore == VK_NULL_HANDLE;
    }

  private:
    VkSemaphore m_semaphore = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eSemaphore>
  {
    using Type = Semaphore;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eSemaphore>
  {
    using Type = Semaphore;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkSemaphore, VK_NULL_HANDLE>
  {
    using Type = Semaphore;
  };
#endif

  template <>
  struct isVulkanHandleType<Semaphore>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkFence.html
  class Fence
  {
  public:
    using CType      = VkFence;
    using NativeType = VkFence;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eFence;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eFence;

  public:
    Fence() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Fence( Fence const & rhs )             = default;
    Fence & operator=( Fence const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Fence( Fence && rhs )             = default;
    Fence & operator=( Fence && rhs ) = default;
#else
    Fence( Fence && rhs ) VULKAN_HPP_NOEXCEPT : m_fence( exchange( rhs.m_fence, {} ) ) {}

    Fence & operator=( Fence && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_fence = exchange( rhs.m_fence, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Fence( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Fence( VkFence fence ) VULKAN_HPP_NOEXCEPT : m_fence( fence ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Fence & operator=( VkFence fence ) VULKAN_HPP_NOEXCEPT
    {
      m_fence = fence;
      return *this;
    }
#endif

    Fence & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_fence = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkFence() const VULKAN_HPP_NOEXCEPT
    {
      return m_fence;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_fence != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_fence == VK_NULL_HANDLE;
    }

  private:
    VkFence m_fence = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eFence>
  {
    using Type = Fence;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eFence>
  {
    using Type = Fence;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkFence, VK_NULL_HANDLE>
  {
    using Type = Fence;
  };
#endif

  template <>
  struct isVulkanHandleType<Fence>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPerformanceConfigurationINTEL, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/VkPerformanceConfigurationINTEL.html
  class PerformanceConfigurationINTEL
  {
  public:
    using CType      = VkPerformanceConfigurationINTEL;
    using NativeType = VkPerformanceConfigurationINTEL;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePerformanceConfigurationINTEL;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    PerformanceConfigurationINTEL() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    PerformanceConfigurationINTEL( PerformanceConfigurationINTEL const & rhs )             = default;
    PerformanceConfigurationINTEL & operator=( PerformanceConfigurationINTEL const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    PerformanceConfigurationINTEL( PerformanceConfigurationINTEL && rhs )             = default;
    PerformanceConfigurationINTEL & operator=( PerformanceConfigurationINTEL && rhs ) = default;
#else
    PerformanceConfigurationINTEL( PerformanceConfigurationINTEL && rhs ) VULKAN_HPP_NOEXCEPT
      : m_performanceConfigurationINTEL( exchange( rhs.m_performanceConfigurationINTEL, {} ) )
    {
    }

    PerformanceConfigurationINTEL & operator=( PerformanceConfigurationINTEL && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_performanceConfigurationINTEL = exchange( rhs.m_performanceConfigurationINTEL, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR PerformanceConfigurationINTEL( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PerformanceConfigurationINTEL( VkPerformanceConfigurationINTEL performanceConfigurationINTEL ) VULKAN_HPP_NOEXCEPT
      : m_performanceConfigurationINTEL( performanceConfigurationINTEL )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    PerformanceConfigurationINTEL & operator=( VkPerformanceConfigurationINTEL performanceConfigurationINTEL ) VULKAN_HPP_NOEXCEPT
    {
      m_performanceConfigurationINTEL = performanceConfigurationINTEL;
      return *this;
    }
#endif

    PerformanceConfigurationINTEL & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_performanceConfigurationINTEL = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPerformanceConfigurationINTEL() const VULKAN_HPP_NOEXCEPT
    {
      return m_performanceConfigurationINTEL;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_performanceConfigurationINTEL != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_performanceConfigurationINTEL == VK_NULL_HANDLE;
    }

  private:
    VkPerformanceConfigurationINTEL m_performanceConfigurationINTEL = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePerformanceConfigurationINTEL>
  {
    using Type = PerformanceConfigurationINTEL;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPerformanceConfigurationINTEL, VK_NULL_HANDLE>
  {
    using Type = PerformanceConfigurationINTEL;
  };
#endif

  template <>
  struct isVulkanHandleType<PerformanceConfigurationINTEL>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueryPool.html
  class QueryPool
  {
  public:
    using CType      = VkQueryPool;
    using NativeType = VkQueryPool;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eQueryPool;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eQueryPool;

  public:
    QueryPool() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    QueryPool( QueryPool const & rhs )             = default;
    QueryPool & operator=( QueryPool const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    QueryPool( QueryPool && rhs )             = default;
    QueryPool & operator=( QueryPool && rhs ) = default;
#else
    QueryPool( QueryPool && rhs ) VULKAN_HPP_NOEXCEPT : m_queryPool( exchange( rhs.m_queryPool, {} ) ) {}

    QueryPool & operator=( QueryPool && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_queryPool = exchange( rhs.m_queryPool, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR QueryPool( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT QueryPool( VkQueryPool queryPool ) VULKAN_HPP_NOEXCEPT : m_queryPool( queryPool ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    QueryPool & operator=( VkQueryPool queryPool ) VULKAN_HPP_NOEXCEPT
    {
      m_queryPool = queryPool;
      return *this;
    }
#endif

    QueryPool & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_queryPool = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkQueryPool() const VULKAN_HPP_NOEXCEPT
    {
      return m_queryPool;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_queryPool != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_queryPool == VK_NULL_HANDLE;
    }

  private:
    VkQueryPool m_queryPool = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eQueryPool>
  {
    using Type = QueryPool;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eQueryPool>
  {
    using Type = QueryPool;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkQueryPool, VK_NULL_HANDLE>
  {
    using Type = QueryPool;
  };
#endif

  template <>
  struct isVulkanHandleType<QueryPool>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkBuffer.html
  class Buffer
  {
  public:
    using CType      = VkBuffer;
    using NativeType = VkBuffer;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eBuffer;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eBuffer;

  public:
    Buffer() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Buffer( Buffer const & rhs )             = default;
    Buffer & operator=( Buffer const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Buffer( Buffer && rhs )             = default;
    Buffer & operator=( Buffer && rhs ) = default;
#else
    Buffer( Buffer && rhs ) VULKAN_HPP_NOEXCEPT : m_buffer( exchange( rhs.m_buffer, {} ) ) {}

    Buffer & operator=( Buffer && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_buffer = exchange( rhs.m_buffer, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Buffer( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Buffer( VkBuffer buffer ) VULKAN_HPP_NOEXCEPT : m_buffer( buffer ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Buffer & operator=( VkBuffer buffer ) VULKAN_HPP_NOEXCEPT
    {
      m_buffer = buffer;
      return *this;
    }
#endif

    Buffer & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_buffer = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkBuffer() const VULKAN_HPP_NOEXCEPT
    {
      return m_buffer;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_buffer != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_buffer == VK_NULL_HANDLE;
    }

  private:
    VkBuffer m_buffer = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eBuffer>
  {
    using Type = Buffer;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eBuffer>
  {
    using Type = Buffer;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkBuffer, VK_NULL_HANDLE>
  {
    using Type = Buffer;
  };
#endif

  template <>
  struct isVulkanHandleType<Buffer>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineLayout.html
  class PipelineLayout
  {
  public:
    using CType      = VkPipelineLayout;
    using NativeType = VkPipelineLayout;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePipelineLayout;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::ePipelineLayout;

  public:
    PipelineLayout() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    PipelineLayout( PipelineLayout const & rhs )             = default;
    PipelineLayout & operator=( PipelineLayout const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    PipelineLayout( PipelineLayout && rhs )             = default;
    PipelineLayout & operator=( PipelineLayout && rhs ) = default;
#else
    PipelineLayout( PipelineLayout && rhs ) VULKAN_HPP_NOEXCEPT : m_pipelineLayout( exchange( rhs.m_pipelineLayout, {} ) ) {}

    PipelineLayout & operator=( PipelineLayout && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineLayout = exchange( rhs.m_pipelineLayout, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR PipelineLayout( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PipelineLayout( VkPipelineLayout pipelineLayout ) VULKAN_HPP_NOEXCEPT : m_pipelineLayout( pipelineLayout ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    PipelineLayout & operator=( VkPipelineLayout pipelineLayout ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineLayout = pipelineLayout;
      return *this;
    }
#endif

    PipelineLayout & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineLayout = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipelineLayout() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineLayout;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineLayout != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineLayout == VK_NULL_HANDLE;
    }

  private:
    VkPipelineLayout m_pipelineLayout = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePipelineLayout>
  {
    using Type = PipelineLayout;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::ePipelineLayout>
  {
    using Type = PipelineLayout;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPipelineLayout, VK_NULL_HANDLE>
  {
    using Type = PipelineLayout;
  };
#endif

  template <>
  struct isVulkanHandleType<PipelineLayout>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDescriptorSet, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSet.html
  class DescriptorSet
  {
  public:
    using CType      = VkDescriptorSet;
    using NativeType = VkDescriptorSet;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDescriptorSet;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDescriptorSet;

  public:
    DescriptorSet() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DescriptorSet( DescriptorSet const & rhs )             = default;
    DescriptorSet & operator=( DescriptorSet const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DescriptorSet( DescriptorSet && rhs )             = default;
    DescriptorSet & operator=( DescriptorSet && rhs ) = default;
#else
    DescriptorSet( DescriptorSet && rhs ) VULKAN_HPP_NOEXCEPT : m_descriptorSet( exchange( rhs.m_descriptorSet, {} ) ) {}

    DescriptorSet & operator=( DescriptorSet && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorSet = exchange( rhs.m_descriptorSet, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DescriptorSet( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorSet( VkDescriptorSet descriptorSet ) VULKAN_HPP_NOEXCEPT : m_descriptorSet( descriptorSet ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DescriptorSet & operator=( VkDescriptorSet descriptorSet ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorSet = descriptorSet;
      return *this;
    }
#endif

    DescriptorSet & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorSet = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorSet() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorSet;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorSet != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorSet == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorSet m_descriptorSet = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDescriptorSet>
  {
    using Type = DescriptorSet;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDescriptorSet>
  {
    using Type = DescriptorSet;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDescriptorSet, VK_NULL_HANDLE>
  {
    using Type = DescriptorSet;
  };
#endif

  template <>
  struct isVulkanHandleType<DescriptorSet>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkImageView.html
  class ImageView
  {
  public:
    using CType      = VkImageView;
    using NativeType = VkImageView;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eImageView;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eImageView;

  public:
    ImageView() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    ImageView( ImageView const & rhs )             = default;
    ImageView & operator=( ImageView const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    ImageView( ImageView && rhs )             = default;
    ImageView & operator=( ImageView && rhs ) = default;
#else
    ImageView( ImageView && rhs ) VULKAN_HPP_NOEXCEPT : m_imageView( exchange( rhs.m_imageView, {} ) ) {}

    ImageView & operator=( ImageView && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_imageView = exchange( rhs.m_imageView, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR ImageView( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ImageView( VkImageView imageView ) VULKAN_HPP_NOEXCEPT : m_imageView( imageView ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    ImageView & operator=( VkImageView imageView ) VULKAN_HPP_NOEXCEPT
    {
      m_imageView = imageView;
      return *this;
    }
#endif

    ImageView & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_imageView = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkImageView() const VULKAN_HPP_NOEXCEPT
    {
      return m_imageView;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_imageView != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_imageView == VK_NULL_HANDLE;
    }

  private:
    VkImageView m_imageView = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eImageView>
  {
    using Type = ImageView;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eImageView>
  {
    using Type = ImageView;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkImageView, VK_NULL_HANDLE>
  {
    using Type = ImageView;
  };
#endif

  template <>
  struct isVulkanHandleType<ImageView>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPipeline, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipeline.html
  class Pipeline
  {
  public:
    using CType      = VkPipeline;
    using NativeType = VkPipeline;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePipeline;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::ePipeline;

  public:
    Pipeline() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Pipeline( Pipeline const & rhs )             = default;
    Pipeline & operator=( Pipeline const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Pipeline( Pipeline && rhs )             = default;
    Pipeline & operator=( Pipeline && rhs ) = default;
#else
    Pipeline( Pipeline && rhs ) VULKAN_HPP_NOEXCEPT : m_pipeline( exchange( rhs.m_pipeline, {} ) ) {}

    Pipeline & operator=( Pipeline && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_pipeline = exchange( rhs.m_pipeline, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Pipeline( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Pipeline( VkPipeline pipeline ) VULKAN_HPP_NOEXCEPT : m_pipeline( pipeline ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Pipeline & operator=( VkPipeline pipeline ) VULKAN_HPP_NOEXCEPT
    {
      m_pipeline = pipeline;
      return *this;
    }
#endif

    Pipeline & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_pipeline = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipeline() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipeline;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipeline != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipeline == VK_NULL_HANDLE;
    }

  private:
    VkPipeline m_pipeline = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePipeline>
  {
    using Type = Pipeline;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::ePipeline>
  {
    using Type = Pipeline;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPipeline, VK_NULL_HANDLE>
  {
    using Type = Pipeline;
  };
#endif

  template <>
  struct isVulkanHandleType<Pipeline>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkShaderEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderEXT.html
  class ShaderEXT
  {
  public:
    using CType      = VkShaderEXT;
    using NativeType = VkShaderEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eShaderEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    ShaderEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    ShaderEXT( ShaderEXT const & rhs )             = default;
    ShaderEXT & operator=( ShaderEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    ShaderEXT( ShaderEXT && rhs )             = default;
    ShaderEXT & operator=( ShaderEXT && rhs ) = default;
#else
    ShaderEXT( ShaderEXT && rhs ) VULKAN_HPP_NOEXCEPT : m_shaderEXT( exchange( rhs.m_shaderEXT, {} ) ) {}

    ShaderEXT & operator=( ShaderEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_shaderEXT = exchange( rhs.m_shaderEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR ShaderEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ShaderEXT( VkShaderEXT shaderEXT ) VULKAN_HPP_NOEXCEPT : m_shaderEXT( shaderEXT ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    ShaderEXT & operator=( VkShaderEXT shaderEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_shaderEXT = shaderEXT;
      return *this;
    }
#endif

    ShaderEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_shaderEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkShaderEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_shaderEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_shaderEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_shaderEXT == VK_NULL_HANDLE;
    }

  private:
    VkShaderEXT m_shaderEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eShaderEXT>
  {
    using Type = ShaderEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkShaderEXT, VK_NULL_HANDLE>
  {
    using Type = ShaderEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<ShaderEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkImage.html
  class Image
  {
  public:
    using CType      = VkImage;
    using NativeType = VkImage;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eImage;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eImage;

  public:
    Image() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Image( Image const & rhs )             = default;
    Image & operator=( Image const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Image( Image && rhs )             = default;
    Image & operator=( Image && rhs ) = default;
#else
    Image( Image && rhs ) VULKAN_HPP_NOEXCEPT : m_image( exchange( rhs.m_image, {} ) ) {}

    Image & operator=( Image && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_image = exchange( rhs.m_image, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Image( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Image( VkImage image ) VULKAN_HPP_NOEXCEPT : m_image( image ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Image & operator=( VkImage image ) VULKAN_HPP_NOEXCEPT
    {
      m_image = image;
      return *this;
    }
#endif

    Image & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_image = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkImage() const VULKAN_HPP_NOEXCEPT
    {
      return m_image;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_image != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_image == VK_NULL_HANDLE;
    }

  private:
    VkImage m_image = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eImage>
  {
    using Type = Image;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eImage>
  {
    using Type = Image;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkImage, VK_NULL_HANDLE>
  {
    using Type = Image;
  };
#endif

  template <>
  struct isVulkanHandleType<Image>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkAccelerationStructureNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureNV.html
  class AccelerationStructureNV
  {
  public:
    using CType      = VkAccelerationStructureNV;
    using NativeType = VkAccelerationStructureNV;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eAccelerationStructureNV;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eAccelerationStructureNV;

  public:
    AccelerationStructureNV() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    AccelerationStructureNV( AccelerationStructureNV const & rhs )             = default;
    AccelerationStructureNV & operator=( AccelerationStructureNV const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    AccelerationStructureNV( AccelerationStructureNV && rhs )             = default;
    AccelerationStructureNV & operator=( AccelerationStructureNV && rhs ) = default;
#else
    AccelerationStructureNV( AccelerationStructureNV && rhs ) VULKAN_HPP_NOEXCEPT : m_accelerationStructureNV( exchange( rhs.m_accelerationStructureNV, {} ) )
    {
    }

    AccelerationStructureNV & operator=( AccelerationStructureNV && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_accelerationStructureNV = exchange( rhs.m_accelerationStructureNV, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR AccelerationStructureNV( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT AccelerationStructureNV( VkAccelerationStructureNV accelerationStructureNV ) VULKAN_HPP_NOEXCEPT
      : m_accelerationStructureNV( accelerationStructureNV )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    AccelerationStructureNV & operator=( VkAccelerationStructureNV accelerationStructureNV ) VULKAN_HPP_NOEXCEPT
    {
      m_accelerationStructureNV = accelerationStructureNV;
      return *this;
    }
#endif

    AccelerationStructureNV & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_accelerationStructureNV = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkAccelerationStructureNV() const VULKAN_HPP_NOEXCEPT
    {
      return m_accelerationStructureNV;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_accelerationStructureNV != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_accelerationStructureNV == VK_NULL_HANDLE;
    }

  private:
    VkAccelerationStructureNV m_accelerationStructureNV = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eAccelerationStructureNV>
  {
    using Type = AccelerationStructureNV;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eAccelerationStructureNV>
  {
    using Type = AccelerationStructureNV;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkAccelerationStructureNV, VK_NULL_HANDLE>
  {
    using Type = AccelerationStructureNV;
  };
#endif

  template <>
  struct isVulkanHandleType<AccelerationStructureNV>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDataGraphPipelineSessionARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDataGraphPipelineSessionARM.html
  class DataGraphPipelineSessionARM
  {
  public:
    using CType      = VkDataGraphPipelineSessionARM;
    using NativeType = VkDataGraphPipelineSessionARM;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDataGraphPipelineSessionARM;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    DataGraphPipelineSessionARM() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DataGraphPipelineSessionARM( DataGraphPipelineSessionARM const & rhs )             = default;
    DataGraphPipelineSessionARM & operator=( DataGraphPipelineSessionARM const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DataGraphPipelineSessionARM( DataGraphPipelineSessionARM && rhs )             = default;
    DataGraphPipelineSessionARM & operator=( DataGraphPipelineSessionARM && rhs ) = default;
#else
    DataGraphPipelineSessionARM( DataGraphPipelineSessionARM && rhs ) VULKAN_HPP_NOEXCEPT
      : m_dataGraphPipelineSessionARM( exchange( rhs.m_dataGraphPipelineSessionARM, {} ) )
    {
    }

    DataGraphPipelineSessionARM & operator=( DataGraphPipelineSessionARM && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_dataGraphPipelineSessionARM = exchange( rhs.m_dataGraphPipelineSessionARM, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DataGraphPipelineSessionARM( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DataGraphPipelineSessionARM( VkDataGraphPipelineSessionARM dataGraphPipelineSessionARM ) VULKAN_HPP_NOEXCEPT
      : m_dataGraphPipelineSessionARM( dataGraphPipelineSessionARM )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DataGraphPipelineSessionARM & operator=( VkDataGraphPipelineSessionARM dataGraphPipelineSessionARM ) VULKAN_HPP_NOEXCEPT
    {
      m_dataGraphPipelineSessionARM = dataGraphPipelineSessionARM;
      return *this;
    }
#endif

    DataGraphPipelineSessionARM & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_dataGraphPipelineSessionARM = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDataGraphPipelineSessionARM() const VULKAN_HPP_NOEXCEPT
    {
      return m_dataGraphPipelineSessionARM;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_dataGraphPipelineSessionARM != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_dataGraphPipelineSessionARM == VK_NULL_HANDLE;
    }

  private:
    VkDataGraphPipelineSessionARM m_dataGraphPipelineSessionARM = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDataGraphPipelineSessionARM>
  {
    using Type = DataGraphPipelineSessionARM;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDataGraphPipelineSessionARM, VK_NULL_HANDLE>
  {
    using Type = DataGraphPipelineSessionARM;
  };
#endif

  template <>
  struct isVulkanHandleType<DataGraphPipelineSessionARM>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkOpticalFlowSessionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkOpticalFlowSessionNV.html
  class OpticalFlowSessionNV
  {
  public:
    using CType      = VkOpticalFlowSessionNV;
    using NativeType = VkOpticalFlowSessionNV;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eOpticalFlowSessionNV;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    OpticalFlowSessionNV() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    OpticalFlowSessionNV( OpticalFlowSessionNV const & rhs )             = default;
    OpticalFlowSessionNV & operator=( OpticalFlowSessionNV const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    OpticalFlowSessionNV( OpticalFlowSessionNV && rhs )             = default;
    OpticalFlowSessionNV & operator=( OpticalFlowSessionNV && rhs ) = default;
#else
    OpticalFlowSessionNV( OpticalFlowSessionNV && rhs ) VULKAN_HPP_NOEXCEPT : m_opticalFlowSessionNV( exchange( rhs.m_opticalFlowSessionNV, {} ) ) {}

    OpticalFlowSessionNV & operator=( OpticalFlowSessionNV && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_opticalFlowSessionNV = exchange( rhs.m_opticalFlowSessionNV, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR OpticalFlowSessionNV( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT OpticalFlowSessionNV( VkOpticalFlowSessionNV opticalFlowSessionNV ) VULKAN_HPP_NOEXCEPT
      : m_opticalFlowSessionNV( opticalFlowSessionNV )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    OpticalFlowSessionNV & operator=( VkOpticalFlowSessionNV opticalFlowSessionNV ) VULKAN_HPP_NOEXCEPT
    {
      m_opticalFlowSessionNV = opticalFlowSessionNV;
      return *this;
    }
#endif

    OpticalFlowSessionNV & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_opticalFlowSessionNV = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkOpticalFlowSessionNV() const VULKAN_HPP_NOEXCEPT
    {
      return m_opticalFlowSessionNV;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_opticalFlowSessionNV != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_opticalFlowSessionNV == VK_NULL_HANDLE;
    }

  private:
    VkOpticalFlowSessionNV m_opticalFlowSessionNV = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eOpticalFlowSessionNV>
  {
    using Type = OpticalFlowSessionNV;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkOpticalFlowSessionNV, VK_NULL_HANDLE>
  {
    using Type = OpticalFlowSessionNV;
  };
#endif

  template <>
  struct isVulkanHandleType<OpticalFlowSessionNV>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDescriptorUpdateTemplate, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorUpdateTemplate.html
  class DescriptorUpdateTemplate
  {
  public:
    using CType      = VkDescriptorUpdateTemplate;
    using NativeType = VkDescriptorUpdateTemplate;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDescriptorUpdateTemplate;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDescriptorUpdateTemplate;

  public:
    DescriptorUpdateTemplate() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DescriptorUpdateTemplate( DescriptorUpdateTemplate const & rhs )             = default;
    DescriptorUpdateTemplate & operator=( DescriptorUpdateTemplate const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DescriptorUpdateTemplate( DescriptorUpdateTemplate && rhs )             = default;
    DescriptorUpdateTemplate & operator=( DescriptorUpdateTemplate && rhs ) = default;
#else
    DescriptorUpdateTemplate( DescriptorUpdateTemplate && rhs ) VULKAN_HPP_NOEXCEPT
      : m_descriptorUpdateTemplate( exchange( rhs.m_descriptorUpdateTemplate, {} ) )
    {
    }

    DescriptorUpdateTemplate & operator=( DescriptorUpdateTemplate && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorUpdateTemplate = exchange( rhs.m_descriptorUpdateTemplate, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DescriptorUpdateTemplate( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorUpdateTemplate( VkDescriptorUpdateTemplate descriptorUpdateTemplate ) VULKAN_HPP_NOEXCEPT
      : m_descriptorUpdateTemplate( descriptorUpdateTemplate )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DescriptorUpdateTemplate & operator=( VkDescriptorUpdateTemplate descriptorUpdateTemplate ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorUpdateTemplate = descriptorUpdateTemplate;
      return *this;
    }
#endif

    DescriptorUpdateTemplate & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorUpdateTemplate = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorUpdateTemplate() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorUpdateTemplate;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorUpdateTemplate != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorUpdateTemplate == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorUpdateTemplate m_descriptorUpdateTemplate = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDescriptorUpdateTemplate>
  {
    using Type = DescriptorUpdateTemplate;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDescriptorUpdateTemplate>
  {
    using Type = DescriptorUpdateTemplate;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDescriptorUpdateTemplate, VK_NULL_HANDLE>
  {
    using Type = DescriptorUpdateTemplate;
  };
#endif

  template <>
  struct isVulkanHandleType<DescriptorUpdateTemplate>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  using DescriptorUpdateTemplateKHR = DescriptorUpdateTemplate;

  // wrapper class for handle VkEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkEvent.html
  class Event
  {
  public:
    using CType      = VkEvent;
    using NativeType = VkEvent;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eEvent;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eEvent;

  public:
    Event() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Event( Event const & rhs )             = default;
    Event & operator=( Event const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Event( Event && rhs )             = default;
    Event & operator=( Event && rhs ) = default;
#else
    Event( Event && rhs ) VULKAN_HPP_NOEXCEPT : m_event( exchange( rhs.m_event, {} ) ) {}

    Event & operator=( Event && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_event = exchange( rhs.m_event, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Event( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Event( VkEvent event ) VULKAN_HPP_NOEXCEPT : m_event( event ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Event & operator=( VkEvent event ) VULKAN_HPP_NOEXCEPT
    {
      m_event = event;
      return *this;
    }
#endif

    Event & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_event = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkEvent() const VULKAN_HPP_NOEXCEPT
    {
      return m_event;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_event != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_event == VK_NULL_HANDLE;
    }

  private:
    VkEvent m_event = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eEvent>
  {
    using Type = Event;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eEvent>
  {
    using Type = Event;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkEvent, VK_NULL_HANDLE>
  {
    using Type = Event;
  };
#endif

  template <>
  struct isVulkanHandleType<Event>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkAccelerationStructureKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkAccelerationStructureKHR.html
  class AccelerationStructureKHR
  {
  public:
    using CType      = VkAccelerationStructureKHR;
    using NativeType = VkAccelerationStructureKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eAccelerationStructureKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eAccelerationStructureKHR;

  public:
    AccelerationStructureKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    AccelerationStructureKHR( AccelerationStructureKHR const & rhs )             = default;
    AccelerationStructureKHR & operator=( AccelerationStructureKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    AccelerationStructureKHR( AccelerationStructureKHR && rhs )             = default;
    AccelerationStructureKHR & operator=( AccelerationStructureKHR && rhs ) = default;
#else
    AccelerationStructureKHR( AccelerationStructureKHR && rhs ) VULKAN_HPP_NOEXCEPT
      : m_accelerationStructureKHR( exchange( rhs.m_accelerationStructureKHR, {} ) )
    {
    }

    AccelerationStructureKHR & operator=( AccelerationStructureKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_accelerationStructureKHR = exchange( rhs.m_accelerationStructureKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR AccelerationStructureKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT AccelerationStructureKHR( VkAccelerationStructureKHR accelerationStructureKHR ) VULKAN_HPP_NOEXCEPT
      : m_accelerationStructureKHR( accelerationStructureKHR )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    AccelerationStructureKHR & operator=( VkAccelerationStructureKHR accelerationStructureKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_accelerationStructureKHR = accelerationStructureKHR;
      return *this;
    }
#endif

    AccelerationStructureKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_accelerationStructureKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkAccelerationStructureKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_accelerationStructureKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_accelerationStructureKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_accelerationStructureKHR == VK_NULL_HANDLE;
    }

  private:
    VkAccelerationStructureKHR m_accelerationStructureKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eAccelerationStructureKHR>
  {
    using Type = AccelerationStructureKHR;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eAccelerationStructureKHR>
  {
    using Type = AccelerationStructureKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkAccelerationStructureKHR, VK_NULL_HANDLE>
  {
    using Type = AccelerationStructureKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<AccelerationStructureKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkMicromapEXT.html
  class MicromapEXT
  {
  public:
    using CType      = VkMicromapEXT;
    using NativeType = VkMicromapEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eMicromapEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    MicromapEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    MicromapEXT( MicromapEXT const & rhs )             = default;
    MicromapEXT & operator=( MicromapEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    MicromapEXT( MicromapEXT && rhs )             = default;
    MicromapEXT & operator=( MicromapEXT && rhs ) = default;
#else
    MicromapEXT( MicromapEXT && rhs ) VULKAN_HPP_NOEXCEPT : m_micromapEXT( exchange( rhs.m_micromapEXT, {} ) ) {}

    MicromapEXT & operator=( MicromapEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_micromapEXT = exchange( rhs.m_micromapEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR MicromapEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT MicromapEXT( VkMicromapEXT micromapEXT ) VULKAN_HPP_NOEXCEPT : m_micromapEXT( micromapEXT ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    MicromapEXT & operator=( VkMicromapEXT micromapEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_micromapEXT = micromapEXT;
      return *this;
    }
#endif

    MicromapEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_micromapEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkMicromapEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_micromapEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_micromapEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_micromapEXT == VK_NULL_HANDLE;
    }

  private:
    VkMicromapEXT m_micromapEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eMicromapEXT>
  {
    using Type = MicromapEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkMicromapEXT, VK_NULL_HANDLE>
  {
    using Type = MicromapEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<MicromapEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandBuffer.html
  class CommandBuffer
  {
  public:
    using CType      = VkCommandBuffer;
    using NativeType = VkCommandBuffer;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eCommandBuffer;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eCommandBuffer;

  public:
    CommandBuffer() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    CommandBuffer( CommandBuffer const & rhs )             = default;
    CommandBuffer & operator=( CommandBuffer const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    CommandBuffer( CommandBuffer && rhs )             = default;
    CommandBuffer & operator=( CommandBuffer && rhs ) = default;
#else
    CommandBuffer( CommandBuffer && rhs ) VULKAN_HPP_NOEXCEPT : m_commandBuffer( exchange( rhs.m_commandBuffer, {} ) ) {}

    CommandBuffer & operator=( CommandBuffer && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_commandBuffer = exchange( rhs.m_commandBuffer, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR CommandBuffer( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    CommandBuffer( VkCommandBuffer commandBuffer ) VULKAN_HPP_NOEXCEPT : m_commandBuffer( commandBuffer ) {}

    CommandBuffer & operator=( VkCommandBuffer commandBuffer ) VULKAN_HPP_NOEXCEPT
    {
      m_commandBuffer = commandBuffer;
      return *this;
    }

    CommandBuffer & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_commandBuffer = {};
      return *this;
    }

    //=== VK_VERSION_1_0 ===

    // wrapper function for command vkBeginCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBeginCommandBuffer.html
    VULKAN_HPP_NODISCARD Result begin( CommandBufferBeginInfo const * pBeginInfo,
                                       DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBeginCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBeginCommandBuffer.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      begin( CommandBufferBeginInfo const & beginInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEndCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEndCommandBuffer.html
    VULKAN_HPP_NODISCARD Result end( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkEndCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEndCommandBuffer.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type end( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkResetCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandBuffer.html
    VULKAN_HPP_NODISCARD Result reset( CommandBufferResetFlags  flags,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkResetCommandBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandBuffer.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      reset( CommandBufferResetFlags flags VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ), DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkCmdCopyBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer.html
    void copyBuffer( Buffer                   srcBuffer,
                     Buffer                   dstBuffer,
                     uint32_t                 regionCount,
                     BufferCopy const *       pRegions,
                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer.html
    void copyBuffer( Buffer                               srcBuffer,
                     Buffer                               dstBuffer,
                     ArrayProxy<BufferCopy const> const & regions,
                     DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage.html
    void copyImage( Image                    srcImage,
                    ImageLayout              srcImageLayout,
                    Image                    dstImage,
                    ImageLayout              dstImageLayout,
                    uint32_t                 regionCount,
                    ImageCopy const *        pRegions,
                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage.html
    void copyImage( Image                               srcImage,
                    ImageLayout                         srcImageLayout,
                    Image                               dstImage,
                    ImageLayout                         dstImageLayout,
                    ArrayProxy<ImageCopy const> const & regions,
                    DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyBufferToImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html
    void copyBufferToImage( Buffer                   srcBuffer,
                            Image                    dstImage,
                            ImageLayout              dstImageLayout,
                            uint32_t                 regionCount,
                            BufferImageCopy const *  pRegions,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyBufferToImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage.html
    void copyBufferToImage( Buffer                                    srcBuffer,
                            Image                                     dstImage,
                            ImageLayout                               dstImageLayout,
                            ArrayProxy<BufferImageCopy const> const & regions,
                            DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyImageToBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html
    void copyImageToBuffer( Image                    srcImage,
                            ImageLayout              srcImageLayout,
                            Buffer                   dstBuffer,
                            uint32_t                 regionCount,
                            BufferImageCopy const *  pRegions,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyImageToBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer.html
    void copyImageToBuffer( Image                                     srcImage,
                            ImageLayout                               srcImageLayout,
                            Buffer                                    dstBuffer,
                            ArrayProxy<BufferImageCopy const> const & regions,
                            DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdUpdateBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdUpdateBuffer.html
    void updateBuffer( Buffer                   dstBuffer,
                       DeviceSize               dstOffset,
                       DeviceSize               dataSize,
                       void const *             pData,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdUpdateBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdUpdateBuffer.html
    template <typename DataType>
    void updateBuffer( Buffer                             dstBuffer,
                       DeviceSize                         dstOffset,
                       ArrayProxy<DataType const> const & data,
                       DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdFillBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdFillBuffer.html
    void fillBuffer( Buffer                   dstBuffer,
                     DeviceSize               dstOffset,
                     DeviceSize               size,
                     uint32_t                 data,
                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdPipelineBarrier, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html
    void pipelineBarrier( PipelineStageFlags          srcStageMask,
                          PipelineStageFlags          dstStageMask,
                          DependencyFlags             dependencyFlags,
                          uint32_t                    memoryBarrierCount,
                          MemoryBarrier const *       pMemoryBarriers,
                          uint32_t                    bufferMemoryBarrierCount,
                          BufferMemoryBarrier const * pBufferMemoryBarriers,
                          uint32_t                    imageMemoryBarrierCount,
                          ImageMemoryBarrier const *  pImageMemoryBarriers,
                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPipelineBarrier, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier.html
    void pipelineBarrier( PipelineStageFlags                            srcStageMask,
                          PipelineStageFlags                            dstStageMask,
                          DependencyFlags                               dependencyFlags,
                          ArrayProxy<MemoryBarrier const> const &       memoryBarriers,
                          ArrayProxy<BufferMemoryBarrier const> const & bufferMemoryBarriers,
                          ArrayProxy<ImageMemoryBarrier const> const &  imageMemoryBarriers,
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBeginQuery, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginQuery.html
    void beginQuery( QueryPool                queryPool,
                     uint32_t                 query,
                     QueryControlFlags        flags,
                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdEndQuery, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndQuery.html
    void endQuery( QueryPool queryPool, uint32_t query, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdResetQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetQueryPool.html
    void resetQueryPool( QueryPool                queryPool,
                         uint32_t                 firstQuery,
                         uint32_t                 queryCount,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdWriteTimestamp, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp.html
    void writeTimestamp( PipelineStageFlagBits    pipelineStage,
                         QueryPool                queryPool,
                         uint32_t                 query,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdCopyQueryPoolResults, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyQueryPoolResults.html
    void copyQueryPoolResults( QueryPool                queryPool,
                               uint32_t                 firstQuery,
                               uint32_t                 queryCount,
                               Buffer                   dstBuffer,
                               DeviceSize               dstOffset,
                               DeviceSize               stride,
                               QueryResultFlags         flags,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdExecuteCommands, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteCommands.html
    void executeCommands( uint32_t                 commandBufferCount,
                          CommandBuffer const *    pCommandBuffers,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdExecuteCommands, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteCommands.html
    void executeCommands( ArrayProxy<CommandBuffer const> const & commandBuffers,
                          DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindPipeline, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindPipeline.html
    void bindPipeline( PipelineBindPoint        pipelineBindPoint,
                       Pipeline                 pipeline,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdBindDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html
    void bindDescriptorSets( PipelineBindPoint        pipelineBindPoint,
                             PipelineLayout           layout,
                             uint32_t                 firstSet,
                             uint32_t                 descriptorSetCount,
                             DescriptorSet const *    pDescriptorSets,
                             uint32_t                 dynamicOffsetCount,
                             uint32_t const *         pDynamicOffsets,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets.html
    void bindDescriptorSets( PipelineBindPoint                       pipelineBindPoint,
                             PipelineLayout                          layout,
                             uint32_t                                firstSet,
                             ArrayProxy<DescriptorSet const> const & descriptorSets,
                             ArrayProxy<uint32_t const> const &      dynamicOffsets,
                             DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdClearColorImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearColorImage.html
    void clearColorImage( Image                         image,
                          ImageLayout                   imageLayout,
                          ClearColorValue const *       pColor,
                          uint32_t                      rangeCount,
                          ImageSubresourceRange const * pRanges,
                          DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdClearColorImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearColorImage.html
    void clearColorImage( Image                                           image,
                          ImageLayout                                     imageLayout,
                          ClearColorValue const &                         color,
                          ArrayProxy<ImageSubresourceRange const> const & ranges,
                          DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDispatch, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatch.html
    void dispatch( uint32_t                 groupCountX,
                   uint32_t                 groupCountY,
                   uint32_t                 groupCountZ,
                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDispatchIndirect, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchIndirect.html
    void dispatchIndirect( Buffer buffer, DeviceSize offset, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent.html
    void setEvent( Event event, PipelineStageFlags stageMask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdResetEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent.html
    void resetEvent( Event event, PipelineStageFlags stageMask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdWaitEvents, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents.html
    void waitEvents( uint32_t                    eventCount,
                     Event const *               pEvents,
                     PipelineStageFlags          srcStageMask,
                     PipelineStageFlags          dstStageMask,
                     uint32_t                    memoryBarrierCount,
                     MemoryBarrier const *       pMemoryBarriers,
                     uint32_t                    bufferMemoryBarrierCount,
                     BufferMemoryBarrier const * pBufferMemoryBarriers,
                     uint32_t                    imageMemoryBarrierCount,
                     ImageMemoryBarrier const *  pImageMemoryBarriers,
                     DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdWaitEvents, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents.html
    void waitEvents( ArrayProxy<Event const> const &               events,
                     PipelineStageFlags                            srcStageMask,
                     PipelineStageFlags                            dstStageMask,
                     ArrayProxy<MemoryBarrier const> const &       memoryBarriers,
                     ArrayProxy<BufferMemoryBarrier const> const & bufferMemoryBarriers,
                     ArrayProxy<ImageMemoryBarrier const> const &  imageMemoryBarriers,
                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushConstants, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants.html
    void pushConstants( PipelineLayout           layout,
                        ShaderStageFlags         stageFlags,
                        uint32_t                 offset,
                        uint32_t                 size,
                        void const *             pValues,
                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushConstants, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants.html
    template <typename ValuesType>
    void pushConstants( PipelineLayout                       layout,
                        ShaderStageFlags                     stageFlags,
                        uint32_t                             offset,
                        ArrayProxy<ValuesType const> const & values,
                        DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetViewport, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewport.html
    void setViewport( uint32_t                 firstViewport,
                      uint32_t                 viewportCount,
                      Viewport const *         pViewports,
                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetViewport, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewport.html
    void setViewport( uint32_t                           firstViewport,
                      ArrayProxy<Viewport const> const & viewports,
                      DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetScissor, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissor.html
    void setScissor( uint32_t                 firstScissor,
                     uint32_t                 scissorCount,
                     Rect2D const *           pScissors,
                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetScissor, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissor.html
    void setScissor( uint32_t                         firstScissor,
                     ArrayProxy<Rect2D const> const & scissors,
                     DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetLineWidth, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineWidth.html
    void setLineWidth( float lineWidth, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthBias, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias.html
    void setDepthBias( float                    depthBiasConstantFactor,
                       float                    depthBiasClamp,
                       float                    depthBiasSlopeFactor,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetBlendConstants, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetBlendConstants.html
    void setBlendConstants( float const blendConstants[4], DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthBounds, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBounds.html
    void
      setDepthBounds( float minDepthBounds, float maxDepthBounds, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilCompareMask, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilCompareMask.html
    void setStencilCompareMask( StencilFaceFlags         faceMask,
                                uint32_t                 compareMask,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilWriteMask, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilWriteMask.html
    void setStencilWriteMask( StencilFaceFlags         faceMask,
                              uint32_t                 writeMask,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilReference, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilReference.html
    void setStencilReference( StencilFaceFlags         faceMask,
                              uint32_t                 reference,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdBindIndexBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer.html
    void bindIndexBuffer( Buffer                   buffer,
                          DeviceSize               offset,
                          IndexType                indexType,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdBindVertexBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers.html
    void bindVertexBuffers( uint32_t                 firstBinding,
                            uint32_t                 bindingCount,
                            Buffer const *           pBuffers,
                            DeviceSize const *       pOffsets,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindVertexBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers.html
    void bindVertexBuffers( uint32_t                             firstBinding,
                            ArrayProxy<Buffer const> const &     buffers,
                            ArrayProxy<DeviceSize const> const & offsets,
                            DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDraw, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDraw.html
    void draw( uint32_t                 vertexCount,
               uint32_t                 instanceCount,
               uint32_t                 firstVertex,
               uint32_t                 firstInstance,
               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndexed, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexed.html
    void drawIndexed( uint32_t                 indexCount,
                      uint32_t                 instanceCount,
                      uint32_t                 firstIndex,
                      int32_t                  vertexOffset,
                      uint32_t                 firstInstance,
                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndirect, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirect.html
    void drawIndirect( Buffer                   buffer,
                       DeviceSize               offset,
                       uint32_t                 drawCount,
                       uint32_t                 stride,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndexedIndirect, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirect.html
    void drawIndexedIndirect( Buffer                   buffer,
                              DeviceSize               offset,
                              uint32_t                 drawCount,
                              uint32_t                 stride,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdBlitImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html
    void blitImage( Image                    srcImage,
                    ImageLayout              srcImageLayout,
                    Image                    dstImage,
                    ImageLayout              dstImageLayout,
                    uint32_t                 regionCount,
                    ImageBlit const *        pRegions,
                    Filter                   filter,
                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBlitImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage.html
    void blitImage( Image                               srcImage,
                    ImageLayout                         srcImageLayout,
                    Image                               dstImage,
                    ImageLayout                         dstImageLayout,
                    ArrayProxy<ImageBlit const> const & regions,
                    Filter                              filter,
                    DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdClearDepthStencilImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearDepthStencilImage.html
    void clearDepthStencilImage( Image                          image,
                                 ImageLayout                    imageLayout,
                                 ClearDepthStencilValue const * pDepthStencil,
                                 uint32_t                       rangeCount,
                                 ImageSubresourceRange const *  pRanges,
                                 DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdClearDepthStencilImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearDepthStencilImage.html
    void clearDepthStencilImage( Image                                           image,
                                 ImageLayout                                     imageLayout,
                                 ClearDepthStencilValue const &                  depthStencil,
                                 ArrayProxy<ImageSubresourceRange const> const & ranges,
                                 DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdClearAttachments, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearAttachments.html
    void clearAttachments( uint32_t                 attachmentCount,
                           ClearAttachment const *  pAttachments,
                           uint32_t                 rectCount,
                           ClearRect const *        pRects,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdClearAttachments, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdClearAttachments.html
    void clearAttachments( ArrayProxy<ClearAttachment const> const & attachments,
                           ArrayProxy<ClearRect const> const &       rects,
                           DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdResolveImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage.html
    void resolveImage( Image                    srcImage,
                       ImageLayout              srcImageLayout,
                       Image                    dstImage,
                       ImageLayout              dstImageLayout,
                       uint32_t                 regionCount,
                       ImageResolve const *     pRegions,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdResolveImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage.html
    void resolveImage( Image                                  srcImage,
                       ImageLayout                            srcImageLayout,
                       Image                                  dstImage,
                       ImageLayout                            dstImageLayout,
                       ArrayProxy<ImageResolve const> const & regions,
                       DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBeginRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass.html
    void beginRenderPass( RenderPassBeginInfo const * pRenderPassBegin,
                          SubpassContents             contents,
                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass.html
    void beginRenderPass( RenderPassBeginInfo const & renderPassBegin,
                          SubpassContents             contents,
                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdNextSubpass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass.html
    void nextSubpass( SubpassContents contents, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdEndRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass.html
    void endRenderPass( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_VERSION_1_1 ===

    // wrapper function for command vkCmdSetDeviceMask, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDeviceMask.html
    void setDeviceMask( uint32_t deviceMask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDispatchBase, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchBase.html
    void dispatchBase( uint32_t                 baseGroupX,
                       uint32_t                 baseGroupY,
                       uint32_t                 baseGroupZ,
                       uint32_t                 groupCountX,
                       uint32_t                 groupCountY,
                       uint32_t                 groupCountZ,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_VERSION_1_2 ===

    // wrapper function for command vkCmdDrawIndirectCount, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCount.html
    void drawIndirectCount( Buffer                   buffer,
                            DeviceSize               offset,
                            Buffer                   countBuffer,
                            DeviceSize               countBufferOffset,
                            uint32_t                 maxDrawCount,
                            uint32_t                 stride,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndexedIndirectCount, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCount.html
    void drawIndexedIndirectCount( Buffer                   buffer,
                                   DeviceSize               offset,
                                   Buffer                   countBuffer,
                                   DeviceSize               countBufferOffset,
                                   uint32_t                 maxDrawCount,
                                   uint32_t                 stride,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdBeginRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2.html
    void beginRenderPass2( RenderPassBeginInfo const * pRenderPassBegin,
                           SubpassBeginInfo const *    pSubpassBeginInfo,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2.html
    void beginRenderPass2( RenderPassBeginInfo const & renderPassBegin,
                           SubpassBeginInfo const &    subpassBeginInfo,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdNextSubpass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2.html
    void nextSubpass2( SubpassBeginInfo const * pSubpassBeginInfo,
                       SubpassEndInfo const *   pSubpassEndInfo,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdNextSubpass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2.html
    void nextSubpass2( SubpassBeginInfo const & subpassBeginInfo,
                       SubpassEndInfo const &   subpassEndInfo,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2.html
    void endRenderPass2( SubpassEndInfo const * pSubpassEndInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2.html
    void endRenderPass2( SubpassEndInfo const & subpassEndInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_3 ===

    // wrapper function for command vkCmdPipelineBarrier2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2.html
    void pipelineBarrier2( DependencyInfo const *   pDependencyInfo,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPipelineBarrier2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2.html
    void pipelineBarrier2( DependencyInfo const & dependencyInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdWriteTimestamp2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp2.html
    void writeTimestamp2( PipelineStageFlags2      stage,
                          QueryPool                queryPool,
                          uint32_t                 query,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdCopyBuffer2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2.html
    void copyBuffer2( CopyBufferInfo2 const * pCopyBufferInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyBuffer2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2.html
    void copyBuffer2( CopyBufferInfo2 const & copyBufferInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2.html
    void copyImage2( CopyImageInfo2 const * pCopyImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2.html
    void copyImage2( CopyImageInfo2 const & copyImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyBufferToImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html
    void copyBufferToImage2( CopyBufferToImageInfo2 const * pCopyBufferToImageInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyBufferToImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2.html
    void copyBufferToImage2( CopyBufferToImageInfo2 const & copyBufferToImageInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyImageToBuffer2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html
    void copyImageToBuffer2( CopyImageToBufferInfo2 const * pCopyImageToBufferInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyImageToBuffer2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2.html
    void copyImageToBuffer2( CopyImageToBufferInfo2 const & copyImageToBufferInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetEvent2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2.html
    void setEvent2( Event                    event,
                    DependencyInfo const *   pDependencyInfo,
                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetEvent2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2.html
    void setEvent2( Event                    event,
                    DependencyInfo const &   dependencyInfo,
                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdResetEvent2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent2.html
    void resetEvent2( Event event, PipelineStageFlags2 stageMask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdWaitEvents2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2.html
    void waitEvents2( uint32_t                 eventCount,
                      Event const *            pEvents,
                      DependencyInfo const *   pDependencyInfos,
                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdWaitEvents2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2.html
    void waitEvents2( ArrayProxy<Event const> const &          events,
                      ArrayProxy<DependencyInfo const> const & dependencyInfos,
                      DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBlitImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2.html
    void blitImage2( BlitImageInfo2 const * pBlitImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBlitImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2.html
    void blitImage2( BlitImageInfo2 const & blitImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdResolveImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2.html
    void resolveImage2( ResolveImageInfo2 const * pResolveImageInfo,
                        DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdResolveImage2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2.html
    void resolveImage2( ResolveImageInfo2 const & resolveImageInfo,
                        DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBeginRendering, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html
    void beginRendering( RenderingInfo const * pRenderingInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginRendering, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRendering.html
    void beginRendering( RenderingInfo const & renderingInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndRendering, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering.html
    void endRendering( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetCullMode, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCullMode.html
    void setCullMode( CullModeFlags cullMode, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetFrontFace, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFrontFace.html
    void setFrontFace( FrontFace frontFace, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetPrimitiveTopology, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveTopology.html
    void setPrimitiveTopology( PrimitiveTopology        primitiveTopology,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetViewportWithCount, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCount.html
    void setViewportWithCount( uint32_t                 viewportCount,
                               Viewport const *         pViewports,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetViewportWithCount, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCount.html
    void setViewportWithCount( ArrayProxy<Viewport const> const & viewports,
                               DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetScissorWithCount, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCount.html
    void setScissorWithCount( uint32_t                 scissorCount,
                              Rect2D const *           pScissors,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetScissorWithCount, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCount.html
    void setScissorWithCount( ArrayProxy<Rect2D const> const & scissors,
                              DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindVertexBuffers2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2.html
    void bindVertexBuffers2( uint32_t                 firstBinding,
                             uint32_t                 bindingCount,
                             Buffer const *           pBuffers,
                             DeviceSize const *       pOffsets,
                             DeviceSize const *       pSizes,
                             DeviceSize const *       pStrides,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindVertexBuffers2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2.html
    void bindVertexBuffers2( uint32_t                                     firstBinding,
                             ArrayProxy<Buffer const> const &             buffers,
                             ArrayProxy<DeviceSize const> const &         offsets,
                             ArrayProxy<DeviceSize const> const & sizes   VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             ArrayProxy<DeviceSize const> const & strides VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetDepthTestEnable, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthTestEnable.html
    void setDepthTestEnable( Bool32 depthTestEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthWriteEnable, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthWriteEnable.html
    void setDepthWriteEnable( Bool32 depthWriteEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthCompareOp, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthCompareOp.html
    void setDepthCompareOp( CompareOp depthCompareOp, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthBoundsTestEnable, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBoundsTestEnable.html
    void setDepthBoundsTestEnable( Bool32 depthBoundsTestEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilTestEnable, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilTestEnable.html
    void setStencilTestEnable( Bool32 stencilTestEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilOp, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilOp.html
    void setStencilOp( StencilFaceFlags         faceMask,
                       StencilOp                failOp,
                       StencilOp                passOp,
                       StencilOp                depthFailOp,
                       CompareOp                compareOp,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetRasterizerDiscardEnable, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizerDiscardEnable.html
    void setRasterizerDiscardEnable( Bool32                   rasterizerDiscardEnable,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthBiasEnable, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBiasEnable.html
    void setDepthBiasEnable( Bool32 depthBiasEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetPrimitiveRestartEnable, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveRestartEnable.html
    void setPrimitiveRestartEnable( Bool32                   primitiveRestartEnable,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_VERSION_1_4 ===

    // wrapper function for command vkCmdPushDescriptorSet, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet.html
    void pushDescriptorSet( PipelineBindPoint          pipelineBindPoint,
                            PipelineLayout             layout,
                            uint32_t                   set,
                            uint32_t                   descriptorWriteCount,
                            WriteDescriptorSet const * pDescriptorWrites,
                            DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSet, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet.html
    void pushDescriptorSet( PipelineBindPoint                            pipelineBindPoint,
                            PipelineLayout                               layout,
                            uint32_t                                     set,
                            ArrayProxy<WriteDescriptorSet const> const & descriptorWrites,
                            DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDescriptorSetWithTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate.html
    void pushDescriptorSetWithTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate,
                                        PipelineLayout           layout,
                                        uint32_t                 set,
                                        void const *             pData,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSetWithTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate.html
    template <typename DataType>
    void pushDescriptorSetWithTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate,
                                        PipelineLayout           layout,
                                        uint32_t                 set,
                                        DataType const &         data,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindDescriptorSets2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2.html
    void bindDescriptorSets2( BindDescriptorSetsInfo const * pBindDescriptorSetsInfo,
                              DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindDescriptorSets2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2.html
    void bindDescriptorSets2( BindDescriptorSetsInfo const & bindDescriptorSetsInfo,
                              DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushConstants2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2.html
    void pushConstants2( PushConstantsInfo const * pPushConstantsInfo,
                         DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushConstants2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2.html
    void pushConstants2( PushConstantsInfo const & pushConstantsInfo,
                         DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDescriptorSet2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2.html
    void pushDescriptorSet2( PushDescriptorSetInfo const * pPushDescriptorSetInfo,
                             DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSet2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2.html
    void pushDescriptorSet2( PushDescriptorSetInfo const & pushDescriptorSetInfo,
                             DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDescriptorSetWithTemplate2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2.html
    void pushDescriptorSetWithTemplate2( PushDescriptorSetWithTemplateInfo const * pPushDescriptorSetWithTemplateInfo,
                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSetWithTemplate2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2.html
    void pushDescriptorSetWithTemplate2( PushDescriptorSetWithTemplateInfo const & pushDescriptorSetWithTemplateInfo,
                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetLineStipple, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStipple.html
    void setLineStipple( uint32_t                 lineStippleFactor,
                         uint16_t                 lineStipplePattern,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdBindIndexBuffer2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer2.html
    void bindIndexBuffer2( Buffer                   buffer,
                           DeviceSize               offset,
                           DeviceSize               size,
                           IndexType                indexType,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetRenderingAttachmentLocations, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocations.html
    void setRenderingAttachmentLocations( RenderingAttachmentLocationInfo const * pLocationInfo,
                                          DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetRenderingAttachmentLocations, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocations.html
    void setRenderingAttachmentLocations( RenderingAttachmentLocationInfo const & locationInfo,
                                          DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetRenderingInputAttachmentIndices, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndices.html
    void setRenderingInputAttachmentIndices( RenderingInputAttachmentIndexInfo const * pInputAttachmentIndexInfo,
                                             DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetRenderingInputAttachmentIndices, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndices.html
    void setRenderingInputAttachmentIndices( RenderingInputAttachmentIndexInfo const & inputAttachmentIndexInfo,
                                             DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_debug_marker ===

    // wrapper function for command vkCmdDebugMarkerBeginEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerBeginEXT.html
    void debugMarkerBeginEXT( DebugMarkerMarkerInfoEXT const * pMarkerInfo,
                              DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDebugMarkerBeginEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerBeginEXT.html
    void debugMarkerBeginEXT( DebugMarkerMarkerInfoEXT const & markerInfo,
                              DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDebugMarkerEndEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerEndEXT.html
    void debugMarkerEndEXT( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDebugMarkerInsertEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerInsertEXT.html
    void debugMarkerInsertEXT( DebugMarkerMarkerInfoEXT const * pMarkerInfo,
                               DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDebugMarkerInsertEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDebugMarkerInsertEXT.html
    void debugMarkerInsertEXT( DebugMarkerMarkerInfoEXT const & markerInfo,
                               DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_video_queue ===

    // wrapper function for command vkCmdBeginVideoCodingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginVideoCodingKHR.html
    void beginVideoCodingKHR( VideoBeginCodingInfoKHR const * pBeginInfo,
                              DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginVideoCodingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginVideoCodingKHR.html
    void beginVideoCodingKHR( VideoBeginCodingInfoKHR const & beginInfo,
                              DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndVideoCodingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndVideoCodingKHR.html
    void endVideoCodingKHR( VideoEndCodingInfoKHR const * pEndCodingInfo,
                            DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndVideoCodingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndVideoCodingKHR.html
    void endVideoCodingKHR( VideoEndCodingInfoKHR const & endCodingInfo,
                            DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdControlVideoCodingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdControlVideoCodingKHR.html
    void controlVideoCodingKHR( VideoCodingControlInfoKHR const * pCodingControlInfo,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdControlVideoCodingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdControlVideoCodingKHR.html
    void controlVideoCodingKHR( VideoCodingControlInfoKHR const & codingControlInfo,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_video_decode_queue ===

    // wrapper function for command vkCmdDecodeVideoKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecodeVideoKHR.html
    void decodeVideoKHR( VideoDecodeInfoKHR const * pDecodeInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDecodeVideoKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecodeVideoKHR.html
    void decodeVideoKHR( VideoDecodeInfoKHR const & decodeInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_transform_feedback ===

    // wrapper function for command vkCmdBindTransformFeedbackBuffersEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTransformFeedbackBuffersEXT.html
    void bindTransformFeedbackBuffersEXT( uint32_t                 firstBinding,
                                          uint32_t                 bindingCount,
                                          Buffer const *           pBuffers,
                                          DeviceSize const *       pOffsets,
                                          DeviceSize const *       pSizes,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindTransformFeedbackBuffersEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTransformFeedbackBuffersEXT.html
    void bindTransformFeedbackBuffersEXT( uint32_t                                   firstBinding,
                                          ArrayProxy<Buffer const> const &           buffers,
                                          ArrayProxy<DeviceSize const> const &       offsets,
                                          ArrayProxy<DeviceSize const> const & sizes VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBeginTransformFeedbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginTransformFeedbackEXT.html
    void beginTransformFeedbackEXT( uint32_t                 firstCounterBuffer,
                                    uint32_t                 counterBufferCount,
                                    Buffer const *           pCounterBuffers,
                                    DeviceSize const *       pCounterBufferOffsets,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginTransformFeedbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginTransformFeedbackEXT.html
    void beginTransformFeedbackEXT( uint32_t                                                  firstCounterBuffer,
                                    ArrayProxy<Buffer const> const &                          counterBuffers,
                                    ArrayProxy<DeviceSize const> const & counterBufferOffsets VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndTransformFeedbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndTransformFeedbackEXT.html
    void endTransformFeedbackEXT( uint32_t                 firstCounterBuffer,
                                  uint32_t                 counterBufferCount,
                                  Buffer const *           pCounterBuffers,
                                  DeviceSize const *       pCounterBufferOffsets,
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndTransformFeedbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndTransformFeedbackEXT.html
    void endTransformFeedbackEXT( uint32_t                                                  firstCounterBuffer,
                                  ArrayProxy<Buffer const> const &                          counterBuffers,
                                  ArrayProxy<DeviceSize const> const & counterBufferOffsets VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBeginQueryIndexedEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginQueryIndexedEXT.html
    void beginQueryIndexedEXT( QueryPool                queryPool,
                               uint32_t                 query,
                               QueryControlFlags        flags,
                               uint32_t                 index,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdEndQueryIndexedEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndQueryIndexedEXT.html
    void endQueryIndexedEXT( QueryPool                queryPool,
                             uint32_t                 query,
                             uint32_t                 index,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndirectByteCountEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectByteCountEXT.html
    void drawIndirectByteCountEXT( uint32_t                 instanceCount,
                                   uint32_t                 firstInstance,
                                   Buffer                   counterBuffer,
                                   DeviceSize               counterBufferOffset,
                                   uint32_t                 counterOffset,
                                   uint32_t                 vertexStride,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NVX_binary_import ===

    // wrapper function for command vkCmdCuLaunchKernelNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCuLaunchKernelNVX.html
    void cuLaunchKernelNVX( CuLaunchInfoNVX const * pLaunchInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCuLaunchKernelNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCuLaunchKernelNVX.html
    void cuLaunchKernelNVX( CuLaunchInfoNVX const & launchInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_AMD_draw_indirect_count ===

    // wrapper function for command vkCmdDrawIndirectCountAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCountAMD.html
    void drawIndirectCountAMD( Buffer                   buffer,
                               DeviceSize               offset,
                               Buffer                   countBuffer,
                               DeviceSize               countBufferOffset,
                               uint32_t                 maxDrawCount,
                               uint32_t                 stride,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndexedIndirectCountAMD, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCountAMD.html
    void drawIndexedIndirectCountAMD( Buffer                   buffer,
                                      DeviceSize               offset,
                                      Buffer                   countBuffer,
                                      DeviceSize               countBufferOffset,
                                      uint32_t                 maxDrawCount,
                                      uint32_t                 stride,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_dynamic_rendering ===

    // wrapper function for command vkCmdBeginRenderingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderingKHR.html
    void beginRenderingKHR( RenderingInfo const * pRenderingInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginRenderingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderingKHR.html
    void beginRenderingKHR( RenderingInfo const & renderingInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndRenderingKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderingKHR.html
    void endRenderingKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_device_group ===

    // wrapper function for command vkCmdSetDeviceMaskKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDeviceMaskKHR.html
    void setDeviceMaskKHR( uint32_t deviceMask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDispatchBaseKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchBaseKHR.html
    void dispatchBaseKHR( uint32_t                 baseGroupX,
                          uint32_t                 baseGroupY,
                          uint32_t                 baseGroupZ,
                          uint32_t                 groupCountX,
                          uint32_t                 groupCountY,
                          uint32_t                 groupCountZ,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_push_descriptor ===

    // wrapper function for command vkCmdPushDescriptorSetKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetKHR.html
    void pushDescriptorSetKHR( PipelineBindPoint          pipelineBindPoint,
                               PipelineLayout             layout,
                               uint32_t                   set,
                               uint32_t                   descriptorWriteCount,
                               WriteDescriptorSet const * pDescriptorWrites,
                               DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSetKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetKHR.html
    void pushDescriptorSetKHR( PipelineBindPoint                            pipelineBindPoint,
                               PipelineLayout                               layout,
                               uint32_t                                     set,
                               ArrayProxy<WriteDescriptorSet const> const & descriptorWrites,
                               DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDescriptorSetWithTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html
    void pushDescriptorSetWithTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate,
                                           PipelineLayout           layout,
                                           uint32_t                 set,
                                           void const *             pData,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSetWithTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html
    template <typename DataType>
    void pushDescriptorSetWithTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate,
                                           PipelineLayout           layout,
                                           uint32_t                 set,
                                           DataType const &         data,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_conditional_rendering ===

    // wrapper function for command vkCmdBeginConditionalRenderingEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginConditionalRenderingEXT.html
    void beginConditionalRenderingEXT( ConditionalRenderingBeginInfoEXT const * pConditionalRenderingBegin,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginConditionalRenderingEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginConditionalRenderingEXT.html
    void beginConditionalRenderingEXT( ConditionalRenderingBeginInfoEXT const & conditionalRenderingBegin,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndConditionalRenderingEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndConditionalRenderingEXT.html
    void endConditionalRenderingEXT( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_clip_space_w_scaling ===

    // wrapper function for command vkCmdSetViewportWScalingNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWScalingNV.html
    void setViewportWScalingNV( uint32_t                   firstViewport,
                                uint32_t                   viewportCount,
                                ViewportWScalingNV const * pViewportWScalings,
                                DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetViewportWScalingNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWScalingNV.html
    void setViewportWScalingNV( uint32_t                                     firstViewport,
                                ArrayProxy<ViewportWScalingNV const> const & viewportWScalings,
                                DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_discard_rectangles ===

    // wrapper function for command vkCmdSetDiscardRectangleEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleEXT.html
    void setDiscardRectangleEXT( uint32_t                 firstDiscardRectangle,
                                 uint32_t                 discardRectangleCount,
                                 Rect2D const *           pDiscardRectangles,
                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetDiscardRectangleEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleEXT.html
    void setDiscardRectangleEXT( uint32_t                         firstDiscardRectangle,
                                 ArrayProxy<Rect2D const> const & discardRectangles,
                                 DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetDiscardRectangleEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleEnableEXT.html
    void setDiscardRectangleEnableEXT( Bool32                   discardRectangleEnable,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDiscardRectangleModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDiscardRectangleModeEXT.html
    void setDiscardRectangleModeEXT( DiscardRectangleModeEXT  discardRectangleMode,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_create_renderpass2 ===

    // wrapper function for command vkCmdBeginRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2KHR.html
    void beginRenderPass2KHR( RenderPassBeginInfo const * pRenderPassBegin,
                              SubpassBeginInfo const *    pSubpassBeginInfo,
                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginRenderPass2KHR.html
    void beginRenderPass2KHR( RenderPassBeginInfo const & renderPassBegin,
                              SubpassBeginInfo const &    subpassBeginInfo,
                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdNextSubpass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2KHR.html
    void nextSubpass2KHR( SubpassBeginInfo const * pSubpassBeginInfo,
                          SubpassEndInfo const *   pSubpassEndInfo,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdNextSubpass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdNextSubpass2KHR.html
    void nextSubpass2KHR( SubpassBeginInfo const & subpassBeginInfo,
                          SubpassEndInfo const &   subpassEndInfo,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2KHR.html
    void endRenderPass2KHR( SubpassEndInfo const *   pSubpassEndInfo,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRenderPass2KHR.html
    void endRenderPass2KHR( SubpassEndInfo const &   subpassEndInfo,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_debug_utils ===

    // wrapper function for command vkCmdBeginDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginDebugUtilsLabelEXT.html
    void beginDebugUtilsLabelEXT( DebugUtilsLabelEXT const * pLabelInfo,
                                  DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginDebugUtilsLabelEXT.html
    void beginDebugUtilsLabelEXT( DebugUtilsLabelEXT const & labelInfo,
                                  DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndDebugUtilsLabelEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndDebugUtilsLabelEXT.html
    void endDebugUtilsLabelEXT( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdInsertDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdInsertDebugUtilsLabelEXT.html
    void insertDebugUtilsLabelEXT( DebugUtilsLabelEXT const * pLabelInfo,
                                   DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdInsertDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdInsertDebugUtilsLabelEXT.html
    void insertDebugUtilsLabelEXT( DebugUtilsLabelEXT const & labelInfo,
                                   DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_ENABLE_BETA_EXTENSIONS )
    //=== VK_AMDX_shader_enqueue ===

    // wrapper function for command vkCmdInitializeGraphScratchMemoryAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdInitializeGraphScratchMemoryAMDX.html
    void initializeGraphScratchMemoryAMDX( Pipeline                 executionGraph,
                                           DeviceAddress            scratch,
                                           DeviceSize               scratchSize,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDispatchGraphAMDX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchGraphAMDX.html
    void dispatchGraphAMDX( DeviceAddress                      scratch,
                            DeviceSize                         scratchSize,
                            DispatchGraphCountInfoAMDX const * pCountInfo,
                            DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDispatchGraphAMDX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchGraphAMDX.html
    void dispatchGraphAMDX( DeviceAddress                      scratch,
                            DeviceSize                         scratchSize,
                            DispatchGraphCountInfoAMDX const & countInfo,
                            DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDispatchGraphIndirectAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchGraphIndirectAMDX.html
    void dispatchGraphIndirectAMDX( DeviceAddress                      scratch,
                                    DeviceSize                         scratchSize,
                                    DispatchGraphCountInfoAMDX const * pCountInfo,
                                    DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDispatchGraphIndirectAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchGraphIndirectAMDX.html
    void dispatchGraphIndirectAMDX( DeviceAddress                      scratch,
                                    DeviceSize                         scratchSize,
                                    DispatchGraphCountInfoAMDX const & countInfo,
                                    DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDispatchGraphIndirectCountAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchGraphIndirectCountAMDX.html
    void dispatchGraphIndirectCountAMDX( DeviceAddress            scratch,
                                         DeviceSize               scratchSize,
                                         DeviceAddress            countInfo,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

    //=== VK_EXT_descriptor_heap ===

    // wrapper function for command vkCmdBindSamplerHeapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindSamplerHeapEXT.html
    void bindSamplerHeapEXT( BindHeapInfoEXT const * pBindInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindSamplerHeapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindSamplerHeapEXT.html
    void bindSamplerHeapEXT( BindHeapInfoEXT const & bindInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindResourceHeapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindResourceHeapEXT.html
    void bindResourceHeapEXT( BindHeapInfoEXT const * pBindInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindResourceHeapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindResourceHeapEXT.html
    void bindResourceHeapEXT( BindHeapInfoEXT const & bindInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDataEXT.html
    void pushDataEXT( PushDataInfoEXT const * pPushDataInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDataEXT.html
    void pushDataEXT( PushDataInfoEXT const & pushDataInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_sample_locations ===

    // wrapper function for command vkCmdSetSampleLocationsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleLocationsEXT.html
    void setSampleLocationsEXT( SampleLocationsInfoEXT const * pSampleLocationsInfo,
                                DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetSampleLocationsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleLocationsEXT.html
    void setSampleLocationsEXT( SampleLocationsInfoEXT const & sampleLocationsInfo,
                                DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_acceleration_structure ===

    // wrapper function for command vkCmdBuildAccelerationStructuresKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html
    void buildAccelerationStructuresKHR( uint32_t                                               infoCount,
                                         AccelerationStructureBuildGeometryInfoKHR const *      pInfos,
                                         AccelerationStructureBuildRangeInfoKHR const * const * ppBuildRangeInfos,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBuildAccelerationStructuresKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresKHR.html
    void buildAccelerationStructuresKHR( ArrayProxy<AccelerationStructureBuildGeometryInfoKHR const> const &      infos,
                                         ArrayProxy<AccelerationStructureBuildRangeInfoKHR const * const> const & pBuildRangeInfos,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBuildAccelerationStructuresIndirectKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html
    void buildAccelerationStructuresIndirectKHR( uint32_t                                          infoCount,
                                                 AccelerationStructureBuildGeometryInfoKHR const * pInfos,
                                                 DeviceAddress const *                             pIndirectDeviceAddresses,
                                                 uint32_t const *                                  pIndirectStrides,
                                                 uint32_t const * const *                          ppMaxPrimitiveCounts,
                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBuildAccelerationStructuresIndirectKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html
    void
      buildAccelerationStructuresIndirectKHR( ArrayProxy<AccelerationStructureBuildGeometryInfoKHR const> const & infos,
                                              ArrayProxy<DeviceAddress const> const &                             indirectDeviceAddresses,
                                              ArrayProxy<uint32_t const> const &                                  indirectStrides,
                                              ArrayProxy<uint32_t const * const> const &                          pMaxPrimitiveCounts,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureKHR.html
    void copyAccelerationStructureKHR( CopyAccelerationStructureInfoKHR const * pInfo,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureKHR.html
    void copyAccelerationStructureKHR( CopyAccelerationStructureInfoKHR const & info,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyAccelerationStructureToMemoryKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html
    void copyAccelerationStructureToMemoryKHR( CopyAccelerationStructureToMemoryInfoKHR const * pInfo,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyAccelerationStructureToMemoryKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html
    void copyAccelerationStructureToMemoryKHR( CopyAccelerationStructureToMemoryInfoKHR const & info,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyMemoryToAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html
    void copyMemoryToAccelerationStructureKHR( CopyMemoryToAccelerationStructureInfoKHR const * pInfo,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMemoryToAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html
    void copyMemoryToAccelerationStructureKHR( CopyMemoryToAccelerationStructureInfoKHR const & info,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdWriteAccelerationStructuresPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html
    void writeAccelerationStructuresPropertiesKHR( uint32_t                         accelerationStructureCount,
                                                   AccelerationStructureKHR const * pAccelerationStructures,
                                                   QueryType                        queryType,
                                                   QueryPool                        queryPool,
                                                   uint32_t                         firstQuery,
                                                   DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdWriteAccelerationStructuresPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html
    void writeAccelerationStructuresPropertiesKHR( ArrayProxy<AccelerationStructureKHR const> const & accelerationStructures,
                                                   QueryType                                          queryType,
                                                   QueryPool                                          queryPool,
                                                   uint32_t                                           firstQuery,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_ray_tracing_pipeline ===

    // wrapper function for command vkCmdTraceRaysKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html
    void traceRaysKHR( StridedDeviceAddressRegionKHR const * pRaygenShaderBindingTable,
                       StridedDeviceAddressRegionKHR const * pMissShaderBindingTable,
                       StridedDeviceAddressRegionKHR const * pHitShaderBindingTable,
                       StridedDeviceAddressRegionKHR const * pCallableShaderBindingTable,
                       uint32_t                              width,
                       uint32_t                              height,
                       uint32_t                              depth,
                       DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdTraceRaysKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysKHR.html
    void traceRaysKHR( StridedDeviceAddressRegionKHR const & raygenShaderBindingTable,
                       StridedDeviceAddressRegionKHR const & missShaderBindingTable,
                       StridedDeviceAddressRegionKHR const & hitShaderBindingTable,
                       StridedDeviceAddressRegionKHR const & callableShaderBindingTable,
                       uint32_t                              width,
                       uint32_t                              height,
                       uint32_t                              depth,
                       DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdTraceRaysIndirectKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysIndirectKHR.html
    void traceRaysIndirectKHR( StridedDeviceAddressRegionKHR const * pRaygenShaderBindingTable,
                               StridedDeviceAddressRegionKHR const * pMissShaderBindingTable,
                               StridedDeviceAddressRegionKHR const * pHitShaderBindingTable,
                               StridedDeviceAddressRegionKHR const * pCallableShaderBindingTable,
                               DeviceAddress                         indirectDeviceAddress,
                               DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdTraceRaysIndirectKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysIndirectKHR.html
    void traceRaysIndirectKHR( StridedDeviceAddressRegionKHR const & raygenShaderBindingTable,
                               StridedDeviceAddressRegionKHR const & missShaderBindingTable,
                               StridedDeviceAddressRegionKHR const & hitShaderBindingTable,
                               StridedDeviceAddressRegionKHR const & callableShaderBindingTable,
                               DeviceAddress                         indirectDeviceAddress,
                               DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetRayTracingPipelineStackSizeKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html
    void setRayTracingPipelineStackSizeKHR( uint32_t                 pipelineStackSize,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_shading_rate_image ===

    // wrapper function for command vkCmdBindShadingRateImageNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindShadingRateImageNV.html
    void bindShadingRateImageNV( ImageView                imageView,
                                 ImageLayout              imageLayout,
                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetViewportShadingRatePaletteNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportShadingRatePaletteNV.html
    void setViewportShadingRatePaletteNV( uint32_t                     firstViewport,
                                          uint32_t                     viewportCount,
                                          ShadingRatePaletteNV const * pShadingRatePalettes,
                                          DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetViewportShadingRatePaletteNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportShadingRatePaletteNV.html
    void setViewportShadingRatePaletteNV( uint32_t                                       firstViewport,
                                          ArrayProxy<ShadingRatePaletteNV const> const & shadingRatePalettes,
                                          DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetCoarseSampleOrderNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoarseSampleOrderNV.html
    void setCoarseSampleOrderNV( CoarseSampleOrderTypeNV           sampleOrderType,
                                 uint32_t                          customSampleOrderCount,
                                 CoarseSampleOrderCustomNV const * pCustomSampleOrders,
                                 DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetCoarseSampleOrderNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoarseSampleOrderNV.html
    void setCoarseSampleOrderNV( CoarseSampleOrderTypeNV                             sampleOrderType,
                                 ArrayProxy<CoarseSampleOrderCustomNV const> const & customSampleOrders,
                                 DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_ray_tracing ===

    // wrapper function for command vkCmdBuildAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructureNV.html
    void buildAccelerationStructureNV( AccelerationStructureInfoNV const * pInfo,
                                       Buffer                              instanceData,
                                       DeviceSize                          instanceOffset,
                                       Bool32                              update,
                                       AccelerationStructureNV             dst,
                                       AccelerationStructureNV             src,
                                       Buffer                              scratch,
                                       DeviceSize                          scratchOffset,
                                       DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBuildAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildAccelerationStructureNV.html
    void buildAccelerationStructureNV( AccelerationStructureInfoNV const & info,
                                       Buffer                              instanceData,
                                       DeviceSize                          instanceOffset,
                                       Bool32                              update,
                                       AccelerationStructureNV             dst,
                                       AccelerationStructureNV             src,
                                       Buffer                              scratch,
                                       DeviceSize                          scratchOffset,
                                       DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyAccelerationStructureNV.html
    void copyAccelerationStructureNV( AccelerationStructureNV          dst,
                                      AccelerationStructureNV          src,
                                      CopyAccelerationStructureModeKHR mode,
                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdTraceRaysNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysNV.html
    void traceRaysNV( Buffer                   raygenShaderBindingTableBuffer,
                      DeviceSize               raygenShaderBindingOffset,
                      Buffer                   missShaderBindingTableBuffer,
                      DeviceSize               missShaderBindingOffset,
                      DeviceSize               missShaderBindingStride,
                      Buffer                   hitShaderBindingTableBuffer,
                      DeviceSize               hitShaderBindingOffset,
                      DeviceSize               hitShaderBindingStride,
                      Buffer                   callableShaderBindingTableBuffer,
                      DeviceSize               callableShaderBindingOffset,
                      DeviceSize               callableShaderBindingStride,
                      uint32_t                 width,
                      uint32_t                 height,
                      uint32_t                 depth,
                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdWriteAccelerationStructuresPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html
    void writeAccelerationStructuresPropertiesNV( uint32_t                        accelerationStructureCount,
                                                  AccelerationStructureNV const * pAccelerationStructures,
                                                  QueryType                       queryType,
                                                  QueryPool                       queryPool,
                                                  uint32_t                        firstQuery,
                                                  DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdWriteAccelerationStructuresPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html
    void writeAccelerationStructuresPropertiesNV( ArrayProxy<AccelerationStructureNV const> const & accelerationStructures,
                                                  QueryType                                         queryType,
                                                  QueryPool                                         queryPool,
                                                  uint32_t                                          firstQuery,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_draw_indirect_count ===

    // wrapper function for command vkCmdDrawIndirectCountKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndirectCountKHR.html
    void drawIndirectCountKHR( Buffer                   buffer,
                               DeviceSize               offset,
                               Buffer                   countBuffer,
                               DeviceSize               countBufferOffset,
                               uint32_t                 maxDrawCount,
                               uint32_t                 stride,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawIndexedIndirectCountKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawIndexedIndirectCountKHR.html
    void drawIndexedIndirectCountKHR( Buffer                   buffer,
                                      DeviceSize               offset,
                                      Buffer                   countBuffer,
                                      DeviceSize               countBufferOffset,
                                      uint32_t                 maxDrawCount,
                                      uint32_t                 stride,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_AMD_buffer_marker ===

    // wrapper function for command vkCmdWriteBufferMarkerAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteBufferMarkerAMD.html
    void writeBufferMarkerAMD( PipelineStageFlagBits    pipelineStage,
                               Buffer                   dstBuffer,
                               DeviceSize               dstOffset,
                               uint32_t                 marker,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdWriteBufferMarker2AMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteBufferMarker2AMD.html
    void writeBufferMarker2AMD( PipelineStageFlags2      stage,
                                Buffer                   dstBuffer,
                                DeviceSize               dstOffset,
                                uint32_t                 marker,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_mesh_shader ===

    // wrapper function for command vkCmdDrawMeshTasksNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksNV.html
    void drawMeshTasksNV( uint32_t taskCount, uint32_t firstTask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawMeshTasksIndirectNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectNV.html
    void drawMeshTasksIndirectNV( Buffer                   buffer,
                                  DeviceSize               offset,
                                  uint32_t                 drawCount,
                                  uint32_t                 stride,
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawMeshTasksIndirectCountNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectCountNV.html
    void drawMeshTasksIndirectCountNV( Buffer                   buffer,
                                       DeviceSize               offset,
                                       Buffer                   countBuffer,
                                       DeviceSize               countBufferOffset,
                                       uint32_t                 maxDrawCount,
                                       uint32_t                 stride,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_scissor_exclusive ===

    // wrapper function for command vkCmdSetExclusiveScissorEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorEnableNV.html
    void setExclusiveScissorEnableNV( uint32_t                 firstExclusiveScissor,
                                      uint32_t                 exclusiveScissorCount,
                                      Bool32 const *           pExclusiveScissorEnables,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetExclusiveScissorEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorEnableNV.html
    void setExclusiveScissorEnableNV( uint32_t                         firstExclusiveScissor,
                                      ArrayProxy<Bool32 const> const & exclusiveScissorEnables,
                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetExclusiveScissorNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorNV.html
    void setExclusiveScissorNV( uint32_t                 firstExclusiveScissor,
                                uint32_t                 exclusiveScissorCount,
                                Rect2D const *           pExclusiveScissors,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetExclusiveScissorNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExclusiveScissorNV.html
    void setExclusiveScissorNV( uint32_t                         firstExclusiveScissor,
                                ArrayProxy<Rect2D const> const & exclusiveScissors,
                                DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_device_diagnostic_checkpoints ===

    // wrapper function for command vkCmdSetCheckpointNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCheckpointNV.html
    void setCheckpointNV( void const * pCheckpointMarker, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetCheckpointNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCheckpointNV.html
    template <typename CheckpointMarkerType>
    void setCheckpointNV( CheckpointMarkerType const & checkpointMarker,
                          DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_INTEL_performance_query ===

    // wrapper function for command vkCmdSetPerformanceMarkerINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceMarkerINTEL.html
    VULKAN_HPP_NODISCARD Result setPerformanceMarkerINTEL( PerformanceMarkerInfoINTEL const * pMarkerInfo,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetPerformanceMarkerINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceMarkerINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setPerformanceMarkerINTEL( PerformanceMarkerInfoINTEL const & markerInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetPerformanceStreamMarkerINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html
    VULKAN_HPP_NODISCARD Result setPerformanceStreamMarkerINTEL( PerformanceStreamMarkerInfoINTEL const * pMarkerInfo,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetPerformanceStreamMarkerINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setPerformanceStreamMarkerINTEL( PerformanceStreamMarkerInfoINTEL const & markerInfo,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetPerformanceOverrideINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceOverrideINTEL.html
    VULKAN_HPP_NODISCARD Result setPerformanceOverrideINTEL( PerformanceOverrideInfoINTEL const * pOverrideInfo,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetPerformanceOverrideINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPerformanceOverrideINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setPerformanceOverrideINTEL( PerformanceOverrideInfoINTEL const & overrideInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_fragment_shading_rate ===

    // wrapper function for command vkCmdSetFragmentShadingRateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html
    void setFragmentShadingRateKHR( Extent2D const *                       pFragmentSize,
                                    FragmentShadingRateCombinerOpKHR const combinerOps[2],
                                    DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetFragmentShadingRateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateKHR.html
    void setFragmentShadingRateKHR( Extent2D const &                       fragmentSize,
                                    FragmentShadingRateCombinerOpKHR const combinerOps[2],
                                    DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_dynamic_rendering_local_read ===

    // wrapper function for command vkCmdSetRenderingAttachmentLocationsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocationsKHR.html
    void setRenderingAttachmentLocationsKHR( RenderingAttachmentLocationInfo const * pLocationInfo,
                                             DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetRenderingAttachmentLocationsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingAttachmentLocationsKHR.html
    void setRenderingAttachmentLocationsKHR( RenderingAttachmentLocationInfo const & locationInfo,
                                             DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetRenderingInputAttachmentIndicesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndicesKHR.html
    void setRenderingInputAttachmentIndicesKHR( RenderingInputAttachmentIndexInfo const * pInputAttachmentIndexInfo,
                                                DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetRenderingInputAttachmentIndicesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRenderingInputAttachmentIndicesKHR.html
    void setRenderingInputAttachmentIndicesKHR( RenderingInputAttachmentIndexInfo const & inputAttachmentIndexInfo,
                                                DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_line_rasterization ===

    // wrapper function for command vkCmdSetLineStippleEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleEXT.html
    void setLineStippleEXT( uint32_t                 lineStippleFactor,
                            uint16_t                 lineStipplePattern,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_extended_dynamic_state ===

    // wrapper function for command vkCmdSetCullModeEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCullModeEXT.html
    void setCullModeEXT( CullModeFlags cullMode, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetFrontFaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFrontFaceEXT.html
    void setFrontFaceEXT( FrontFace frontFace, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetPrimitiveTopologyEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveTopologyEXT.html
    void setPrimitiveTopologyEXT( PrimitiveTopology        primitiveTopology,
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetViewportWithCountEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCountEXT.html
    void setViewportWithCountEXT( uint32_t                 viewportCount,
                                  Viewport const *         pViewports,
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetViewportWithCountEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWithCountEXT.html
    void setViewportWithCountEXT( ArrayProxy<Viewport const> const & viewports,
                                  DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetScissorWithCountEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCountEXT.html
    void setScissorWithCountEXT( uint32_t                 scissorCount,
                                 Rect2D const *           pScissors,
                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetScissorWithCountEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetScissorWithCountEXT.html
    void setScissorWithCountEXT( ArrayProxy<Rect2D const> const & scissors,
                                 DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindVertexBuffers2EXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2EXT.html
    void bindVertexBuffers2EXT( uint32_t                 firstBinding,
                                uint32_t                 bindingCount,
                                Buffer const *           pBuffers,
                                DeviceSize const *       pOffsets,
                                DeviceSize const *       pSizes,
                                DeviceSize const *       pStrides,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindVertexBuffers2EXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindVertexBuffers2EXT.html
    void bindVertexBuffers2EXT( uint32_t                                     firstBinding,
                                ArrayProxy<Buffer const> const &             buffers,
                                ArrayProxy<DeviceSize const> const &         offsets,
                                ArrayProxy<DeviceSize const> const & sizes   VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                ArrayProxy<DeviceSize const> const & strides VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetDepthTestEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthTestEnableEXT.html
    void setDepthTestEnableEXT( Bool32 depthTestEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthWriteEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthWriteEnableEXT.html
    void setDepthWriteEnableEXT( Bool32 depthWriteEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthCompareOpEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthCompareOpEXT.html
    void setDepthCompareOpEXT( CompareOp depthCompareOp, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthBoundsTestEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBoundsTestEnableEXT.html
    void setDepthBoundsTestEnableEXT( Bool32                   depthBoundsTestEnable,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilTestEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilTestEnableEXT.html
    void setStencilTestEnableEXT( Bool32 stencilTestEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetStencilOpEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetStencilOpEXT.html
    void setStencilOpEXT( StencilFaceFlags         faceMask,
                          StencilOp                failOp,
                          StencilOp                passOp,
                          StencilOp                depthFailOp,
                          CompareOp                compareOp,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_device_generated_commands ===

    // wrapper function for command vkCmdPreprocessGeneratedCommandsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPreprocessGeneratedCommandsNV.html
    void preprocessGeneratedCommandsNV( GeneratedCommandsInfoNV const * pGeneratedCommandsInfo,
                                        DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPreprocessGeneratedCommandsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPreprocessGeneratedCommandsNV.html
    void preprocessGeneratedCommandsNV( GeneratedCommandsInfoNV const & generatedCommandsInfo,
                                        DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdExecuteGeneratedCommandsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteGeneratedCommandsNV.html
    void executeGeneratedCommandsNV( Bool32                          isPreprocessed,
                                     GeneratedCommandsInfoNV const * pGeneratedCommandsInfo,
                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdExecuteGeneratedCommandsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteGeneratedCommandsNV.html
    void executeGeneratedCommandsNV( Bool32                          isPreprocessed,
                                     GeneratedCommandsInfoNV const & generatedCommandsInfo,
                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindPipelineShaderGroupNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindPipelineShaderGroupNV.html
    void bindPipelineShaderGroupNV( PipelineBindPoint        pipelineBindPoint,
                                    Pipeline                 pipeline,
                                    uint32_t                 groupIndex,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_depth_bias_control ===

    // wrapper function for command vkCmdSetDepthBias2EXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias2EXT.html
    void setDepthBias2EXT( DepthBiasInfoEXT const * pDepthBiasInfo,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetDepthBias2EXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBias2EXT.html
    void setDepthBias2EXT( DepthBiasInfoEXT const & depthBiasInfo,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_video_encode_queue ===

    // wrapper function for command vkCmdEncodeVideoKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEncodeVideoKHR.html
    void encodeVideoKHR( VideoEncodeInfoKHR const * pEncodeInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEncodeVideoKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEncodeVideoKHR.html
    void encodeVideoKHR( VideoEncodeInfoKHR const & encodeInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_ENABLE_BETA_EXTENSIONS )
    //=== VK_NV_cuda_kernel_launch ===

    // wrapper function for command vkCmdCudaLaunchKernelNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCudaLaunchKernelNV.html
    void cudaLaunchKernelNV( CudaLaunchInfoNV const * pLaunchInfo,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCudaLaunchKernelNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCudaLaunchKernelNV.html
    void cudaLaunchKernelNV( CudaLaunchInfoNV const & launchInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_ENABLE_BETA_EXTENSIONS*/

    //=== VK_QCOM_tile_shading ===

    // wrapper function for command vkCmdDispatchTileQCOM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchTileQCOM.html
    void dispatchTileQCOM( DispatchTileInfoQCOM const * pDispatchTileInfo,
                           DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDispatchTileQCOM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchTileQCOM.html
    void dispatchTileQCOM( DispatchTileInfoQCOM const & dispatchTileInfo,
                           DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBeginPerTileExecutionQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginPerTileExecutionQCOM.html
    void beginPerTileExecutionQCOM( PerTileBeginInfoQCOM const * pPerTileBeginInfo,
                                    DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginPerTileExecutionQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginPerTileExecutionQCOM.html
    void beginPerTileExecutionQCOM( PerTileBeginInfoQCOM const & perTileBeginInfo,
                                    DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdEndPerTileExecutionQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndPerTileExecutionQCOM.html
    void endPerTileExecutionQCOM( PerTileEndInfoQCOM const * pPerTileEndInfo,
                                  DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndPerTileExecutionQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndPerTileExecutionQCOM.html
    void endPerTileExecutionQCOM( PerTileEndInfoQCOM const & perTileEndInfo,
                                  DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_synchronization2 ===

    // wrapper function for command vkCmdSetEvent2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2KHR.html
    void setEvent2KHR( Event                    event,
                       DependencyInfo const *   pDependencyInfo,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetEvent2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetEvent2KHR.html
    void setEvent2KHR( Event                    event,
                       DependencyInfo const &   dependencyInfo,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdResetEvent2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResetEvent2KHR.html
    void
      resetEvent2KHR( Event event, PipelineStageFlags2 stageMask, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdWaitEvents2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2KHR.html
    void waitEvents2KHR( uint32_t                 eventCount,
                         Event const *            pEvents,
                         DependencyInfo const *   pDependencyInfos,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdWaitEvents2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWaitEvents2KHR.html
    void waitEvents2KHR( ArrayProxy<Event const> const &          events,
                         ArrayProxy<DependencyInfo const> const & dependencyInfos,
                         DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPipelineBarrier2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2KHR.html
    void pipelineBarrier2KHR( DependencyInfo const *   pDependencyInfo,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPipelineBarrier2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPipelineBarrier2KHR.html
    void pipelineBarrier2KHR( DependencyInfo const &   dependencyInfo,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdWriteTimestamp2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteTimestamp2KHR.html
    void writeTimestamp2KHR( PipelineStageFlags2      stage,
                             QueryPool                queryPool,
                             uint32_t                 query,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_descriptor_buffer ===

    // wrapper function for command vkCmdBindDescriptorBuffersEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBuffersEXT.html
    void bindDescriptorBuffersEXT( uint32_t                               bufferCount,
                                   DescriptorBufferBindingInfoEXT const * pBindingInfos,
                                   DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindDescriptorBuffersEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBuffersEXT.html
    void bindDescriptorBuffersEXT( ArrayProxy<DescriptorBufferBindingInfoEXT const> const & bindingInfos,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetDescriptorBufferOffsetsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html
    void setDescriptorBufferOffsetsEXT( PipelineBindPoint        pipelineBindPoint,
                                        PipelineLayout           layout,
                                        uint32_t                 firstSet,
                                        uint32_t                 setCount,
                                        uint32_t const *         pBufferIndices,
                                        DeviceSize const *       pOffsets,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetDescriptorBufferOffsetsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html
    void setDescriptorBufferOffsetsEXT( PipelineBindPoint                    pipelineBindPoint,
                                        PipelineLayout                       layout,
                                        uint32_t                             firstSet,
                                        ArrayProxy<uint32_t const> const &   bufferIndices,
                                        ArrayProxy<DeviceSize const> const & offsets,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindDescriptorBufferEmbeddedSamplersEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBufferEmbeddedSamplersEXT.html
    void bindDescriptorBufferEmbeddedSamplersEXT( PipelineBindPoint        pipelineBindPoint,
                                                  PipelineLayout           layout,
                                                  uint32_t                 set,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_fragment_shading_rate_enums ===

    // wrapper function for command vkCmdSetFragmentShadingRateEnumNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetFragmentShadingRateEnumNV.html
    void setFragmentShadingRateEnumNV( FragmentShadingRateNV                  shadingRate,
                                       FragmentShadingRateCombinerOpKHR const combinerOps[2],
                                       DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_mesh_shader ===

    // wrapper function for command vkCmdDrawMeshTasksEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksEXT.html
    void drawMeshTasksEXT( uint32_t                 groupCountX,
                           uint32_t                 groupCountY,
                           uint32_t                 groupCountZ,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawMeshTasksIndirectEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectEXT.html
    void drawMeshTasksIndirectEXT( Buffer                   buffer,
                                   DeviceSize               offset,
                                   uint32_t                 drawCount,
                                   uint32_t                 stride,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawMeshTasksIndirectCountEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMeshTasksIndirectCountEXT.html
    void drawMeshTasksIndirectCountEXT( Buffer                   buffer,
                                        DeviceSize               offset,
                                        Buffer                   countBuffer,
                                        DeviceSize               countBufferOffset,
                                        uint32_t                 maxDrawCount,
                                        uint32_t                 stride,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_copy_commands2 ===

    // wrapper function for command vkCmdCopyBuffer2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2KHR.html
    void copyBuffer2KHR( CopyBufferInfo2 const * pCopyBufferInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyBuffer2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBuffer2KHR.html
    void copyBuffer2KHR( CopyBufferInfo2 const & copyBufferInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2KHR.html
    void copyImage2KHR( CopyImageInfo2 const * pCopyImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImage2KHR.html
    void copyImage2KHR( CopyImageInfo2 const & copyImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyBufferToImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2KHR.html
    void copyBufferToImage2KHR( CopyBufferToImageInfo2 const * pCopyBufferToImageInfo,
                                DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyBufferToImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyBufferToImage2KHR.html
    void copyBufferToImage2KHR( CopyBufferToImageInfo2 const & copyBufferToImageInfo,
                                DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyImageToBuffer2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2KHR.html
    void copyImageToBuffer2KHR( CopyImageToBufferInfo2 const * pCopyImageToBufferInfo,
                                DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyImageToBuffer2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyImageToBuffer2KHR.html
    void copyImageToBuffer2KHR( CopyImageToBufferInfo2 const & copyImageToBufferInfo,
                                DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBlitImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2KHR.html
    void blitImage2KHR( BlitImageInfo2 const * pBlitImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBlitImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBlitImage2KHR.html
    void blitImage2KHR( BlitImageInfo2 const & blitImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdResolveImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2KHR.html
    void resolveImage2KHR( ResolveImageInfo2 const * pResolveImageInfo,
                           DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdResolveImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdResolveImage2KHR.html
    void resolveImage2KHR( ResolveImageInfo2 const & resolveImageInfo,
                           DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_vertex_input_dynamic_state ===

    // wrapper function for command vkCmdSetVertexInputEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetVertexInputEXT.html
    void setVertexInputEXT( uint32_t                                    vertexBindingDescriptionCount,
                            VertexInputBindingDescription2EXT const *   pVertexBindingDescriptions,
                            uint32_t                                    vertexAttributeDescriptionCount,
                            VertexInputAttributeDescription2EXT const * pVertexAttributeDescriptions,
                            DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetVertexInputEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetVertexInputEXT.html
    void setVertexInputEXT( ArrayProxy<VertexInputBindingDescription2EXT const> const &   vertexBindingDescriptions,
                            ArrayProxy<VertexInputAttributeDescription2EXT const> const & vertexAttributeDescriptions,
                            DispatchLoader const & d                                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_HUAWEI_subpass_shading ===

    // wrapper function for command vkCmdSubpassShadingHUAWEI, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSubpassShadingHUAWEI.html
    void subpassShadingHUAWEI( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_HUAWEI_invocation_mask ===

    // wrapper function for command vkCmdBindInvocationMaskHUAWEI, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindInvocationMaskHUAWEI.html
    void bindInvocationMaskHUAWEI( ImageView                imageView,
                                   ImageLayout              imageLayout,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_extended_dynamic_state2 ===

    // wrapper function for command vkCmdSetPatchControlPointsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPatchControlPointsEXT.html
    void setPatchControlPointsEXT( uint32_t patchControlPoints, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetRasterizerDiscardEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizerDiscardEnableEXT.html
    void setRasterizerDiscardEnableEXT( Bool32                   rasterizerDiscardEnable,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthBiasEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthBiasEnableEXT.html
    void setDepthBiasEnableEXT( Bool32 depthBiasEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetLogicOpEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLogicOpEXT.html
    void setLogicOpEXT( LogicOp logicOp, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetPrimitiveRestartEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPrimitiveRestartEnableEXT.html
    void setPrimitiveRestartEnableEXT( Bool32                   primitiveRestartEnable,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_color_write_enable ===

    // wrapper function for command vkCmdSetColorWriteEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteEnableEXT.html
    void setColorWriteEnableEXT( uint32_t                 attachmentCount,
                                 Bool32 const *           pColorWriteEnables,
                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetColorWriteEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteEnableEXT.html
    void setColorWriteEnableEXT( ArrayProxy<Bool32 const> const & colorWriteEnables,
                                 DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_ray_tracing_maintenance1 ===

    // wrapper function for command vkCmdTraceRaysIndirect2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdTraceRaysIndirect2KHR.html
    void traceRaysIndirect2KHR( DeviceAddress            indirectDeviceAddress,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_multi_draw ===

    // wrapper function for command vkCmdDrawMultiEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiEXT.html
    void drawMultiEXT( uint32_t                 drawCount,
                       MultiDrawInfoEXT const * pVertexInfo,
                       uint32_t                 instanceCount,
                       uint32_t                 firstInstance,
                       uint32_t                 stride,
                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDrawMultiEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiEXT.html
    void drawMultiEXT( StridedArrayProxy<MultiDrawInfoEXT const> const & vertexInfo,
                       uint32_t                                          instanceCount,
                       uint32_t                                          firstInstance,
                       DispatchLoader const & d                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDrawMultiIndexedEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiIndexedEXT.html
    void drawMultiIndexedEXT( uint32_t                        drawCount,
                              MultiDrawIndexedInfoEXT const * pIndexInfo,
                              uint32_t                        instanceCount,
                              uint32_t                        firstInstance,
                              uint32_t                        stride,
                              int32_t const *                 pVertexOffset,
                              DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDrawMultiIndexedEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawMultiIndexedEXT.html
    void drawMultiIndexedEXT( StridedArrayProxy<MultiDrawIndexedInfoEXT const> const & indexInfo,
                              uint32_t                                                 instanceCount,
                              uint32_t                                                 firstInstance,
                              Optional<int32_t const> vertexOffset                     VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_opacity_micromap ===

    // wrapper function for command vkCmdBuildMicromapsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildMicromapsEXT.html
    void buildMicromapsEXT( uint32_t                     infoCount,
                            MicromapBuildInfoEXT const * pInfos,
                            DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBuildMicromapsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildMicromapsEXT.html
    void buildMicromapsEXT( ArrayProxy<MicromapBuildInfoEXT const> const & infos,
                            DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMicromapEXT.html
    void copyMicromapEXT( CopyMicromapInfoEXT const * pInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMicromapEXT.html
    void copyMicromapEXT( CopyMicromapInfoEXT const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyMicromapToMemoryEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMicromapToMemoryEXT.html
    void copyMicromapToMemoryEXT( CopyMicromapToMemoryInfoEXT const * pInfo,
                                  DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMicromapToMemoryEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMicromapToMemoryEXT.html
    void copyMicromapToMemoryEXT( CopyMicromapToMemoryInfoEXT const & info,
                                  DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyMemoryToMicromapEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToMicromapEXT.html
    void copyMemoryToMicromapEXT( CopyMemoryToMicromapInfoEXT const * pInfo,
                                  DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMemoryToMicromapEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToMicromapEXT.html
    void copyMemoryToMicromapEXT( CopyMemoryToMicromapInfoEXT const & info,
                                  DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdWriteMicromapsPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteMicromapsPropertiesEXT.html
    void writeMicromapsPropertiesEXT( uint32_t                 micromapCount,
                                      MicromapEXT const *      pMicromaps,
                                      QueryType                queryType,
                                      QueryPool                queryPool,
                                      uint32_t                 firstQuery,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdWriteMicromapsPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdWriteMicromapsPropertiesEXT.html
    void writeMicromapsPropertiesEXT( ArrayProxy<MicromapEXT const> const & micromaps,
                                      QueryType                             queryType,
                                      QueryPool                             queryPool,
                                      uint32_t                              firstQuery,
                                      DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_HUAWEI_cluster_culling_shader ===

    // wrapper function for command vkCmdDrawClusterHUAWEI, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawClusterHUAWEI.html
    void drawClusterHUAWEI( uint32_t                 groupCountX,
                            uint32_t                 groupCountY,
                            uint32_t                 groupCountZ,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdDrawClusterIndirectHUAWEI, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDrawClusterIndirectHUAWEI.html
    void drawClusterIndirectHUAWEI( Buffer                   buffer,
                                    DeviceSize               offset,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_copy_memory_indirect ===

    // wrapper function for command vkCmdCopyMemoryIndirectNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryIndirectNV.html
    void copyMemoryIndirectNV( DeviceAddress            copyBufferAddress,
                               uint32_t                 copyCount,
                               uint32_t                 stride,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdCopyMemoryToImageIndirectNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToImageIndirectNV.html
    void copyMemoryToImageIndirectNV( DeviceAddress                  copyBufferAddress,
                                      uint32_t                       copyCount,
                                      uint32_t                       stride,
                                      Image                          dstImage,
                                      ImageLayout                    dstImageLayout,
                                      ImageSubresourceLayers const * pImageSubresources,
                                      DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMemoryToImageIndirectNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToImageIndirectNV.html
    void copyMemoryToImageIndirectNV( DeviceAddress                                    copyBufferAddress,
                                      uint32_t                                         stride,
                                      Image                                            dstImage,
                                      ImageLayout                                      dstImageLayout,
                                      ArrayProxy<ImageSubresourceLayers const> const & imageSubresources,
                                      DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_memory_decompression ===

    // wrapper function for command vkCmdDecompressMemoryNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryNV.html
    void decompressMemoryNV( uint32_t                         decompressRegionCount,
                             DecompressMemoryRegionNV const * pDecompressMemoryRegions,
                             DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDecompressMemoryNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryNV.html
    void decompressMemoryNV( ArrayProxy<DecompressMemoryRegionNV const> const & decompressMemoryRegions,
                             DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDecompressMemoryIndirectCountNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryIndirectCountNV.html
    void decompressMemoryIndirectCountNV( DeviceAddress            indirectCommandsAddress,
                                          DeviceAddress            indirectCommandsCountAddress,
                                          uint32_t                 stride,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_device_generated_commands_compute ===

    // wrapper function for command vkCmdUpdatePipelineIndirectBufferNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdUpdatePipelineIndirectBufferNV.html
    void updatePipelineIndirectBufferNV( PipelineBindPoint        pipelineBindPoint,
                                         Pipeline                 pipeline,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_extended_dynamic_state3 ===

    // wrapper function for command vkCmdSetDepthClampEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClampEnableEXT.html
    void setDepthClampEnableEXT( Bool32 depthClampEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetPolygonModeEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetPolygonModeEXT.html
    void setPolygonModeEXT( PolygonMode polygonMode, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetRasterizationSamplesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizationSamplesEXT.html
    void setRasterizationSamplesEXT( SampleCountFlagBits      rasterizationSamples,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetSampleMaskEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleMaskEXT.html
    void setSampleMaskEXT( SampleCountFlagBits      samples,
                           SampleMask const *       pSampleMask,
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetSampleMaskEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleMaskEXT.html
    void setSampleMaskEXT( SampleCountFlagBits                             samples,
                           ArrayProxy<SampleMask const> const & sampleMask VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetAlphaToCoverageEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAlphaToCoverageEnableEXT.html
    void setAlphaToCoverageEnableEXT( Bool32                   alphaToCoverageEnable,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetAlphaToOneEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAlphaToOneEnableEXT.html
    void setAlphaToOneEnableEXT( Bool32 alphaToOneEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetLogicOpEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLogicOpEnableEXT.html
    void setLogicOpEnableEXT( Bool32 logicOpEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetColorBlendEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendEnableEXT.html
    void setColorBlendEnableEXT( uint32_t                 firstAttachment,
                                 uint32_t                 attachmentCount,
                                 Bool32 const *           pColorBlendEnables,
                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetColorBlendEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendEnableEXT.html
    void setColorBlendEnableEXT( uint32_t                         firstAttachment,
                                 ArrayProxy<Bool32 const> const & colorBlendEnables,
                                 DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetColorBlendEquationEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendEquationEXT.html
    void setColorBlendEquationEXT( uint32_t                      firstAttachment,
                                   uint32_t                      attachmentCount,
                                   ColorBlendEquationEXT const * pColorBlendEquations,
                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetColorBlendEquationEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendEquationEXT.html
    void setColorBlendEquationEXT( uint32_t                                        firstAttachment,
                                   ArrayProxy<ColorBlendEquationEXT const> const & colorBlendEquations,
                                   DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetColorWriteMaskEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteMaskEXT.html
    void setColorWriteMaskEXT( uint32_t                    firstAttachment,
                               uint32_t                    attachmentCount,
                               ColorComponentFlags const * pColorWriteMasks,
                               DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetColorWriteMaskEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorWriteMaskEXT.html
    void setColorWriteMaskEXT( uint32_t                                      firstAttachment,
                               ArrayProxy<ColorComponentFlags const> const & colorWriteMasks,
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetTessellationDomainOriginEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetTessellationDomainOriginEXT.html
    void setTessellationDomainOriginEXT( TessellationDomainOrigin domainOrigin,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetRasterizationStreamEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRasterizationStreamEXT.html
    void setRasterizationStreamEXT( uint32_t rasterizationStream, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetConservativeRasterizationModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetConservativeRasterizationModeEXT.html
    void setConservativeRasterizationModeEXT( ConservativeRasterizationModeEXT conservativeRasterizationMode,
                                              DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetExtraPrimitiveOverestimationSizeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html
    void setExtraPrimitiveOverestimationSizeEXT( float                    extraPrimitiveOverestimationSize,
                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthClipEnableEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClipEnableEXT.html
    void setDepthClipEnableEXT( Bool32 depthClipEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetSampleLocationsEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetSampleLocationsEnableEXT.html
    void setSampleLocationsEnableEXT( Bool32                   sampleLocationsEnable,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetColorBlendAdvancedEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendAdvancedEXT.html
    void setColorBlendAdvancedEXT( uint32_t                      firstAttachment,
                                   uint32_t                      attachmentCount,
                                   ColorBlendAdvancedEXT const * pColorBlendAdvanced,
                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetColorBlendAdvancedEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetColorBlendAdvancedEXT.html
    void setColorBlendAdvancedEXT( uint32_t                                        firstAttachment,
                                   ArrayProxy<ColorBlendAdvancedEXT const> const & colorBlendAdvanced,
                                   DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetProvokingVertexModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetProvokingVertexModeEXT.html
    void setProvokingVertexModeEXT( ProvokingVertexModeEXT   provokingVertexMode,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetLineRasterizationModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineRasterizationModeEXT.html
    void setLineRasterizationModeEXT( LineRasterizationModeEXT lineRasterizationMode,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetLineStippleEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleEnableEXT.html
    void setLineStippleEnableEXT( Bool32 stippledLineEnable, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetDepthClipNegativeOneToOneEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html
    void setDepthClipNegativeOneToOneEXT( Bool32                   negativeOneToOne,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetViewportWScalingEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportWScalingEnableNV.html
    void setViewportWScalingEnableNV( Bool32                   viewportWScalingEnable,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetViewportSwizzleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportSwizzleNV.html
    void setViewportSwizzleNV( uint32_t                  firstViewport,
                               uint32_t                  viewportCount,
                               ViewportSwizzleNV const * pViewportSwizzles,
                               DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetViewportSwizzleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetViewportSwizzleNV.html
    void setViewportSwizzleNV( uint32_t                                    firstViewport,
                               ArrayProxy<ViewportSwizzleNV const> const & viewportSwizzles,
                               DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetCoverageToColorEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageToColorEnableNV.html
    void setCoverageToColorEnableNV( Bool32                   coverageToColorEnable,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetCoverageToColorLocationNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageToColorLocationNV.html
    void setCoverageToColorLocationNV( uint32_t                 coverageToColorLocation,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetCoverageModulationModeNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationModeNV.html
    void setCoverageModulationModeNV( CoverageModulationModeNV coverageModulationMode,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetCoverageModulationTableEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationTableEnableNV.html
    void setCoverageModulationTableEnableNV( Bool32                   coverageModulationTableEnable,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetCoverageModulationTableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationTableNV.html
    void setCoverageModulationTableNV( uint32_t                 coverageModulationTableCount,
                                       float const *            pCoverageModulationTable,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetCoverageModulationTableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageModulationTableNV.html
    void setCoverageModulationTableNV( ArrayProxy<float const> const & coverageModulationTable,
                                       DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetShadingRateImageEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetShadingRateImageEnableNV.html
    void setShadingRateImageEnableNV( Bool32                   shadingRateImageEnable,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetRepresentativeFragmentTestEnableNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html
    void setRepresentativeFragmentTestEnableNV( Bool32                   representativeFragmentTestEnable,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkCmdSetCoverageReductionModeNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetCoverageReductionModeNV.html
    void setCoverageReductionModeNV( CoverageReductionModeNV  coverageReductionMode,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_ARM_tensors ===

    // wrapper function for command vkCmdCopyTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyTensorARM.html
    void copyTensorARM( CopyTensorInfoARM const * pCopyTensorInfo,
                        DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyTensorARM.html
    void copyTensorARM( CopyTensorInfoARM const & copyTensorInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_optical_flow ===

    // wrapper function for command vkCmdOpticalFlowExecuteNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdOpticalFlowExecuteNV.html
    void opticalFlowExecuteNV( OpticalFlowSessionNV             session,
                               OpticalFlowExecuteInfoNV const * pExecuteInfo,
                               DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdOpticalFlowExecuteNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdOpticalFlowExecuteNV.html
    void opticalFlowExecuteNV( OpticalFlowSessionNV             session,
                               OpticalFlowExecuteInfoNV const & executeInfo,
                               DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_maintenance5 ===

    // wrapper function for command vkCmdBindIndexBuffer2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindIndexBuffer2KHR.html
    void bindIndexBuffer2KHR( Buffer                   buffer,
                              DeviceSize               offset,
                              DeviceSize               size,
                              IndexType                indexType,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_shader_object ===

    // wrapper function for command vkCmdBindShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindShadersEXT.html
    void bindShadersEXT( uint32_t                    stageCount,
                         ShaderStageFlagBits const * pStages,
                         ShaderEXT const *           pShaders,
                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindShadersEXT.html
    void bindShadersEXT( ArrayProxy<ShaderStageFlagBits const> const & stages,
                         ArrayProxy<ShaderEXT const> const &           shaders,
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetDepthClampRangeEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClampRangeEXT.html
    void setDepthClampRangeEXT( DepthClampModeEXT          depthClampMode,
                                DepthClampRangeEXT const * pDepthClampRange,
                                DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetDepthClampRangeEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDepthClampRangeEXT.html
    void setDepthClampRangeEXT( DepthClampModeEXT                                  depthClampMode,
                                Optional<DepthClampRangeEXT const> depthClampRange VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_cooperative_vector ===

    // wrapper function for command vkCmdConvertCooperativeVectorMatrixNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdConvertCooperativeVectorMatrixNV.html
    void convertCooperativeVectorMatrixNV( uint32_t                                     infoCount,
                                           ConvertCooperativeVectorMatrixInfoNV const * pInfos,
                                           DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdConvertCooperativeVectorMatrixNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdConvertCooperativeVectorMatrixNV.html
    void convertCooperativeVectorMatrixNV( ArrayProxy<ConvertCooperativeVectorMatrixInfoNV const> const & infos,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_ARM_data_graph ===

    // wrapper function for command vkCmdDispatchDataGraphARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchDataGraphARM.html
    void dispatchDataGraphARM( DataGraphPipelineSessionARM              session,
                               DataGraphPipelineDispatchInfoARM const * pInfo,
                               DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDispatchDataGraphARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDispatchDataGraphARM.html
    void dispatchDataGraphARM( DataGraphPipelineSessionARM                           session,
                               Optional<DataGraphPipelineDispatchInfoARM const> info VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_attachment_feedback_loop_dynamic_state ===

    // wrapper function for command vkCmdSetAttachmentFeedbackLoopEnableEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetAttachmentFeedbackLoopEnableEXT.html
    void setAttachmentFeedbackLoopEnableEXT( ImageAspectFlags         aspectMask,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_line_rasterization ===

    // wrapper function for command vkCmdSetLineStippleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetLineStippleKHR.html
    void setLineStippleKHR( uint32_t                 lineStippleFactor,
                            uint16_t                 lineStipplePattern,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_maintenance6 ===

    // wrapper function for command vkCmdBindDescriptorSets2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2KHR.html
    void bindDescriptorSets2KHR( BindDescriptorSetsInfo const * pBindDescriptorSetsInfo,
                                 DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindDescriptorSets2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorSets2KHR.html
    void bindDescriptorSets2KHR( BindDescriptorSetsInfo const & bindDescriptorSetsInfo,
                                 DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushConstants2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2KHR.html
    void pushConstants2KHR( PushConstantsInfo const * pPushConstantsInfo,
                            DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushConstants2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushConstants2KHR.html
    void pushConstants2KHR( PushConstantsInfo const & pushConstantsInfo,
                            DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDescriptorSet2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2KHR.html
    void pushDescriptorSet2KHR( PushDescriptorSetInfo const * pPushDescriptorSetInfo,
                                DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSet2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSet2KHR.html
    void pushDescriptorSet2KHR( PushDescriptorSetInfo const & pushDescriptorSetInfo,
                                DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdPushDescriptorSetWithTemplate2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2KHR.html
    void pushDescriptorSetWithTemplate2KHR( PushDescriptorSetWithTemplateInfo const * pPushDescriptorSetWithTemplateInfo,
                                            DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPushDescriptorSetWithTemplate2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPushDescriptorSetWithTemplate2KHR.html
    void pushDescriptorSetWithTemplate2KHR( PushDescriptorSetWithTemplateInfo const & pushDescriptorSetWithTemplateInfo,
                                            DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdSetDescriptorBufferOffsets2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDescriptorBufferOffsets2EXT.html
    void setDescriptorBufferOffsets2EXT( SetDescriptorBufferOffsetsInfoEXT const * pSetDescriptorBufferOffsetsInfo,
                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetDescriptorBufferOffsets2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetDescriptorBufferOffsets2EXT.html
    void setDescriptorBufferOffsets2EXT( SetDescriptorBufferOffsetsInfoEXT const & setDescriptorBufferOffsetsInfo,
                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdBindDescriptorBufferEmbeddedSamplers2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.html
    void bindDescriptorBufferEmbeddedSamplers2EXT( BindDescriptorBufferEmbeddedSamplersInfoEXT const * pBindDescriptorBufferEmbeddedSamplersInfo,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindDescriptorBufferEmbeddedSamplers2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.html
    void bindDescriptorBufferEmbeddedSamplers2EXT( BindDescriptorBufferEmbeddedSamplersInfoEXT const & bindDescriptorBufferEmbeddedSamplersInfo,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_QCOM_tile_memory_heap ===

    // wrapper function for command vkCmdBindTileMemoryQCOM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTileMemoryQCOM.html
    void bindTileMemoryQCOM( TileMemoryBindInfoQCOM const * pTileMemoryBindInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBindTileMemoryQCOM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBindTileMemoryQCOM.html
    void bindTileMemoryQCOM( Optional<TileMemoryBindInfoQCOM const> tileMemoryBindInfo VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_copy_memory_indirect ===

    // wrapper function for command vkCmdCopyMemoryIndirectKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryIndirectKHR.html
    void copyMemoryIndirectKHR( CopyMemoryIndirectInfoKHR const * pCopyMemoryIndirectInfo,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMemoryIndirectKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryIndirectKHR.html
    void copyMemoryIndirectKHR( CopyMemoryIndirectInfoKHR const & copyMemoryIndirectInfo,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdCopyMemoryToImageIndirectKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToImageIndirectKHR.html
    void copyMemoryToImageIndirectKHR( CopyMemoryToImageIndirectInfoKHR const * pCopyMemoryToImageIndirectInfo,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdCopyMemoryToImageIndirectKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdCopyMemoryToImageIndirectKHR.html
    void copyMemoryToImageIndirectKHR( CopyMemoryToImageIndirectInfoKHR const & copyMemoryToImageIndirectInfo,
                                       DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_memory_decompression ===

    // wrapper function for command vkCmdDecompressMemoryEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryEXT.html
    void decompressMemoryEXT( DecompressMemoryInfoEXT const * pDecompressMemoryInfoEXT,
                              DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdDecompressMemoryEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryEXT.html
    void decompressMemoryEXT( DecompressMemoryInfoEXT const & decompressMemoryInfoEXT,
                              DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdDecompressMemoryIndirectCountEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdDecompressMemoryIndirectCountEXT.html
    void decompressMemoryIndirectCountEXT( MemoryDecompressionMethodFlagsEXT decompressionMethod,
                                           DeviceAddress                     indirectCommandsAddress,
                                           DeviceAddress                     indirectCommandsCountAddress,
                                           uint32_t                          maxDecompressionCount,
                                           uint32_t                          stride,
                                           DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_NV_cluster_acceleration_structure ===

    // wrapper function for command vkCmdBuildClusterAccelerationStructureIndirectNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildClusterAccelerationStructureIndirectNV.html
    void buildClusterAccelerationStructureIndirectNV( ClusterAccelerationStructureCommandsInfoNV const * pCommandInfos,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBuildClusterAccelerationStructureIndirectNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildClusterAccelerationStructureIndirectNV.html
    void buildClusterAccelerationStructureIndirectNV( ClusterAccelerationStructureCommandsInfoNV const & commandInfos,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_partitioned_acceleration_structure ===

    // wrapper function for command vkCmdBuildPartitionedAccelerationStructuresNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildPartitionedAccelerationStructuresNV.html
    void buildPartitionedAccelerationStructuresNV( BuildPartitionedAccelerationStructureInfoNV const * pBuildInfo,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBuildPartitionedAccelerationStructuresNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBuildPartitionedAccelerationStructuresNV.html
    void buildPartitionedAccelerationStructuresNV( BuildPartitionedAccelerationStructureInfoNV const & buildInfo,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_device_generated_commands ===

    // wrapper function for command vkCmdPreprocessGeneratedCommandsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPreprocessGeneratedCommandsEXT.html
    void preprocessGeneratedCommandsEXT( GeneratedCommandsInfoEXT const * pGeneratedCommandsInfo,
                                         CommandBuffer                    stateCommandBuffer,
                                         DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdPreprocessGeneratedCommandsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdPreprocessGeneratedCommandsEXT.html
    void preprocessGeneratedCommandsEXT( GeneratedCommandsInfoEXT const & generatedCommandsInfo,
                                         CommandBuffer                    stateCommandBuffer,
                                         DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCmdExecuteGeneratedCommandsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteGeneratedCommandsEXT.html
    void executeGeneratedCommandsEXT( Bool32                           isPreprocessed,
                                      GeneratedCommandsInfoEXT const * pGeneratedCommandsInfo,
                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdExecuteGeneratedCommandsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdExecuteGeneratedCommandsEXT.html
    void executeGeneratedCommandsEXT( Bool32                           isPreprocessed,
                                      GeneratedCommandsInfoEXT const & generatedCommandsInfo,
                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_fragment_density_map_offset ===

    // wrapper function for command vkCmdEndRendering2EXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering2EXT.html
    void endRendering2EXT( RenderingEndInfoKHR const * pRenderingEndInfo,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndRendering2EXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering2EXT.html
    void endRendering2EXT( Optional<RenderingEndInfoKHR const> renderingEndInfo VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_custom_resolve ===

    // wrapper function for command vkCmdBeginCustomResolveEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginCustomResolveEXT.html
    void beginCustomResolveEXT( BeginCustomResolveInfoEXT const * pBeginCustomResolveInfo,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdBeginCustomResolveEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdBeginCustomResolveEXT.html
    void beginCustomResolveEXT( Optional<BeginCustomResolveInfoEXT const> beginCustomResolveInfo VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_maintenance10 ===

    // wrapper function for command vkCmdEndRendering2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering2KHR.html
    void endRendering2KHR( RenderingEndInfoKHR const * pRenderingEndInfo,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdEndRendering2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdEndRendering2KHR.html
    void endRendering2KHR( Optional<RenderingEndInfoKHR const> renderingEndInfo VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_compute_occupancy_priority ===

    // wrapper function for command vkCmdSetComputeOccupancyPriorityNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetComputeOccupancyPriorityNV.html
    void setComputeOccupancyPriorityNV( ComputeOccupancyPriorityParametersNV const * pParameters,
                                        DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCmdSetComputeOccupancyPriorityNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCmdSetComputeOccupancyPriorityNV.html
    void setComputeOccupancyPriorityNV( ComputeOccupancyPriorityParametersNV const & parameters,
                                        DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    operator VkCommandBuffer() const VULKAN_HPP_NOEXCEPT
    {
      return m_commandBuffer;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_commandBuffer != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_commandBuffer == VK_NULL_HANDLE;
    }

  private:
    VkCommandBuffer m_commandBuffer = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eCommandBuffer>
  {
    using Type = CommandBuffer;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eCommandBuffer>
  {
    using Type = CommandBuffer;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkCommandBuffer, VK_NULL_HANDLE>
  {
    using Type = CommandBuffer;
  };
#endif

  template <>
  struct isVulkanHandleType<CommandBuffer>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDeviceMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeviceMemory.html
  class DeviceMemory
  {
  public:
    using CType      = VkDeviceMemory;
    using NativeType = VkDeviceMemory;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDeviceMemory;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDeviceMemory;

  public:
    DeviceMemory() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DeviceMemory( DeviceMemory const & rhs )             = default;
    DeviceMemory & operator=( DeviceMemory const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DeviceMemory( DeviceMemory && rhs )             = default;
    DeviceMemory & operator=( DeviceMemory && rhs ) = default;
#else
    DeviceMemory( DeviceMemory && rhs ) VULKAN_HPP_NOEXCEPT : m_deviceMemory( exchange( rhs.m_deviceMemory, {} ) ) {}

    DeviceMemory & operator=( DeviceMemory && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_deviceMemory = exchange( rhs.m_deviceMemory, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DeviceMemory( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DeviceMemory( VkDeviceMemory deviceMemory ) VULKAN_HPP_NOEXCEPT : m_deviceMemory( deviceMemory ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DeviceMemory & operator=( VkDeviceMemory deviceMemory ) VULKAN_HPP_NOEXCEPT
    {
      m_deviceMemory = deviceMemory;
      return *this;
    }
#endif

    DeviceMemory & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_deviceMemory = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDeviceMemory() const VULKAN_HPP_NOEXCEPT
    {
      return m_deviceMemory;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_deviceMemory != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_deviceMemory == VK_NULL_HANDLE;
    }

  private:
    VkDeviceMemory m_deviceMemory = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDeviceMemory>
  {
    using Type = DeviceMemory;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDeviceMemory>
  {
    using Type = DeviceMemory;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDeviceMemory, VK_NULL_HANDLE>
  {
    using Type = DeviceMemory;
  };
#endif

  template <>
  struct isVulkanHandleType<DeviceMemory>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionKHR.html
  class VideoSessionKHR
  {
  public:
    using CType      = VkVideoSessionKHR;
    using NativeType = VkVideoSessionKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eVideoSessionKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    VideoSessionKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    VideoSessionKHR( VideoSessionKHR const & rhs )             = default;
    VideoSessionKHR & operator=( VideoSessionKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    VideoSessionKHR( VideoSessionKHR && rhs )             = default;
    VideoSessionKHR & operator=( VideoSessionKHR && rhs ) = default;
#else
    VideoSessionKHR( VideoSessionKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_videoSessionKHR( exchange( rhs.m_videoSessionKHR, {} ) ) {}

    VideoSessionKHR & operator=( VideoSessionKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_videoSessionKHR = exchange( rhs.m_videoSessionKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR VideoSessionKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT VideoSessionKHR( VkVideoSessionKHR videoSessionKHR ) VULKAN_HPP_NOEXCEPT : m_videoSessionKHR( videoSessionKHR ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    VideoSessionKHR & operator=( VkVideoSessionKHR videoSessionKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_videoSessionKHR = videoSessionKHR;
      return *this;
    }
#endif

    VideoSessionKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_videoSessionKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkVideoSessionKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_videoSessionKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_videoSessionKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_videoSessionKHR == VK_NULL_HANDLE;
    }

  private:
    VkVideoSessionKHR m_videoSessionKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eVideoSessionKHR>
  {
    using Type = VideoSessionKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkVideoSessionKHR, VK_NULL_HANDLE>
  {
    using Type = VideoSessionKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<VideoSessionKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDeferredOperationKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDeferredOperationKHR.html
  class DeferredOperationKHR
  {
  public:
    using CType      = VkDeferredOperationKHR;
    using NativeType = VkDeferredOperationKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDeferredOperationKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    DeferredOperationKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DeferredOperationKHR( DeferredOperationKHR const & rhs )             = default;
    DeferredOperationKHR & operator=( DeferredOperationKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DeferredOperationKHR( DeferredOperationKHR && rhs )             = default;
    DeferredOperationKHR & operator=( DeferredOperationKHR && rhs ) = default;
#else
    DeferredOperationKHR( DeferredOperationKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_deferredOperationKHR( exchange( rhs.m_deferredOperationKHR, {} ) ) {}

    DeferredOperationKHR & operator=( DeferredOperationKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_deferredOperationKHR = exchange( rhs.m_deferredOperationKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DeferredOperationKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DeferredOperationKHR( VkDeferredOperationKHR deferredOperationKHR ) VULKAN_HPP_NOEXCEPT
      : m_deferredOperationKHR( deferredOperationKHR )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DeferredOperationKHR & operator=( VkDeferredOperationKHR deferredOperationKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_deferredOperationKHR = deferredOperationKHR;
      return *this;
    }
#endif

    DeferredOperationKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_deferredOperationKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDeferredOperationKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_deferredOperationKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_deferredOperationKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_deferredOperationKHR == VK_NULL_HANDLE;
    }

  private:
    VkDeferredOperationKHR m_deferredOperationKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDeferredOperationKHR>
  {
    using Type = DeferredOperationKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDeferredOperationKHR, VK_NULL_HANDLE>
  {
    using Type = DeferredOperationKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<DeferredOperationKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkBufferCollectionFUCHSIA, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferCollectionFUCHSIA.html
#if defined( VK_USE_PLATFORM_FUCHSIA )
  class BufferCollectionFUCHSIA
  {
  public:
    using CType      = VkBufferCollectionFUCHSIA;
    using NativeType = VkBufferCollectionFUCHSIA;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eBufferCollectionFUCHSIA;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eBufferCollectionFUCHSIA;

  public:
    BufferCollectionFUCHSIA() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    BufferCollectionFUCHSIA( BufferCollectionFUCHSIA const & rhs )             = default;
    BufferCollectionFUCHSIA & operator=( BufferCollectionFUCHSIA const & rhs ) = default;

#  if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    BufferCollectionFUCHSIA( BufferCollectionFUCHSIA && rhs )             = default;
    BufferCollectionFUCHSIA & operator=( BufferCollectionFUCHSIA && rhs ) = default;
#  else
    BufferCollectionFUCHSIA( BufferCollectionFUCHSIA && rhs ) VULKAN_HPP_NOEXCEPT : m_bufferCollectionFUCHSIA( exchange( rhs.m_bufferCollectionFUCHSIA, {} ) )
    {
    }

    BufferCollectionFUCHSIA & operator=( BufferCollectionFUCHSIA && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_bufferCollectionFUCHSIA = exchange( rhs.m_bufferCollectionFUCHSIA, {} );
      return *this;
    }
#  endif

    VULKAN_HPP_CONSTEXPR BufferCollectionFUCHSIA( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT BufferCollectionFUCHSIA( VkBufferCollectionFUCHSIA bufferCollectionFUCHSIA ) VULKAN_HPP_NOEXCEPT
      : m_bufferCollectionFUCHSIA( bufferCollectionFUCHSIA )
    {
    }

#  if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    BufferCollectionFUCHSIA & operator=( VkBufferCollectionFUCHSIA bufferCollectionFUCHSIA ) VULKAN_HPP_NOEXCEPT
    {
      m_bufferCollectionFUCHSIA = bufferCollectionFUCHSIA;
      return *this;
    }
#  endif

    BufferCollectionFUCHSIA & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_bufferCollectionFUCHSIA = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkBufferCollectionFUCHSIA() const VULKAN_HPP_NOEXCEPT
    {
      return m_bufferCollectionFUCHSIA;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_bufferCollectionFUCHSIA != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_bufferCollectionFUCHSIA == VK_NULL_HANDLE;
    }

  private:
    VkBufferCollectionFUCHSIA m_bufferCollectionFUCHSIA = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eBufferCollectionFUCHSIA>
  {
    using Type = BufferCollectionFUCHSIA;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eBufferCollectionFUCHSIA>
  {
    using Type = BufferCollectionFUCHSIA;
  };

#  if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkBufferCollectionFUCHSIA, VK_NULL_HANDLE>
  {
    using Type = BufferCollectionFUCHSIA;
  };
#  endif

  template <>
  struct isVulkanHandleType<BufferCollectionFUCHSIA>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };
#endif /*VK_USE_PLATFORM_FUCHSIA*/

  // wrapper class for handle VkBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkBufferView.html
  class BufferView
  {
  public:
    using CType      = VkBufferView;
    using NativeType = VkBufferView;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eBufferView;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eBufferView;

  public:
    BufferView() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    BufferView( BufferView const & rhs )             = default;
    BufferView & operator=( BufferView const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    BufferView( BufferView && rhs )             = default;
    BufferView & operator=( BufferView && rhs ) = default;
#else
    BufferView( BufferView && rhs ) VULKAN_HPP_NOEXCEPT : m_bufferView( exchange( rhs.m_bufferView, {} ) ) {}

    BufferView & operator=( BufferView && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_bufferView = exchange( rhs.m_bufferView, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR BufferView( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT BufferView( VkBufferView bufferView ) VULKAN_HPP_NOEXCEPT : m_bufferView( bufferView ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    BufferView & operator=( VkBufferView bufferView ) VULKAN_HPP_NOEXCEPT
    {
      m_bufferView = bufferView;
      return *this;
    }
#endif

    BufferView & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_bufferView = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkBufferView() const VULKAN_HPP_NOEXCEPT
    {
      return m_bufferView;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_bufferView != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_bufferView == VK_NULL_HANDLE;
    }

  private:
    VkBufferView m_bufferView = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eBufferView>
  {
    using Type = BufferView;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eBufferView>
  {
    using Type = BufferView;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkBufferView, VK_NULL_HANDLE>
  {
    using Type = BufferView;
  };
#endif

  template <>
  struct isVulkanHandleType<BufferView>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkCommandPool.html
  class CommandPool
  {
  public:
    using CType      = VkCommandPool;
    using NativeType = VkCommandPool;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eCommandPool;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eCommandPool;

  public:
    CommandPool() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    CommandPool( CommandPool const & rhs )             = default;
    CommandPool & operator=( CommandPool const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    CommandPool( CommandPool && rhs )             = default;
    CommandPool & operator=( CommandPool && rhs ) = default;
#else
    CommandPool( CommandPool && rhs ) VULKAN_HPP_NOEXCEPT : m_commandPool( exchange( rhs.m_commandPool, {} ) ) {}

    CommandPool & operator=( CommandPool && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_commandPool = exchange( rhs.m_commandPool, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR CommandPool( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CommandPool( VkCommandPool commandPool ) VULKAN_HPP_NOEXCEPT : m_commandPool( commandPool ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    CommandPool & operator=( VkCommandPool commandPool ) VULKAN_HPP_NOEXCEPT
    {
      m_commandPool = commandPool;
      return *this;
    }
#endif

    CommandPool & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_commandPool = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCommandPool() const VULKAN_HPP_NOEXCEPT
    {
      return m_commandPool;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_commandPool != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_commandPool == VK_NULL_HANDLE;
    }

  private:
    VkCommandPool m_commandPool = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eCommandPool>
  {
    using Type = CommandPool;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eCommandPool>
  {
    using Type = CommandPool;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkCommandPool, VK_NULL_HANDLE>
  {
    using Type = CommandPool;
  };
#endif

  template <>
  struct isVulkanHandleType<CommandPool>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineCache.html
  class PipelineCache
  {
  public:
    using CType      = VkPipelineCache;
    using NativeType = VkPipelineCache;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePipelineCache;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::ePipelineCache;

  public:
    PipelineCache() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    PipelineCache( PipelineCache const & rhs )             = default;
    PipelineCache & operator=( PipelineCache const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    PipelineCache( PipelineCache && rhs )             = default;
    PipelineCache & operator=( PipelineCache && rhs ) = default;
#else
    PipelineCache( PipelineCache && rhs ) VULKAN_HPP_NOEXCEPT : m_pipelineCache( exchange( rhs.m_pipelineCache, {} ) ) {}

    PipelineCache & operator=( PipelineCache && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineCache = exchange( rhs.m_pipelineCache, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR PipelineCache( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PipelineCache( VkPipelineCache pipelineCache ) VULKAN_HPP_NOEXCEPT : m_pipelineCache( pipelineCache ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    PipelineCache & operator=( VkPipelineCache pipelineCache ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineCache = pipelineCache;
      return *this;
    }
#endif

    PipelineCache & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineCache = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipelineCache() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineCache;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineCache != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineCache == VK_NULL_HANDLE;
    }

  private:
    VkPipelineCache m_pipelineCache = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePipelineCache>
  {
    using Type = PipelineCache;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::ePipelineCache>
  {
    using Type = PipelineCache;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPipelineCache, VK_NULL_HANDLE>
  {
    using Type = PipelineCache;
  };
#endif

  template <>
  struct isVulkanHandleType<PipelineCache>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuFunctionNVX.html
  class CuFunctionNVX
  {
  public:
    using CType      = VkCuFunctionNVX;
    using NativeType = VkCuFunctionNVX;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eCuFunctionNVX;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eCuFunctionNVX;

  public:
    CuFunctionNVX() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    CuFunctionNVX( CuFunctionNVX const & rhs )             = default;
    CuFunctionNVX & operator=( CuFunctionNVX const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    CuFunctionNVX( CuFunctionNVX && rhs )             = default;
    CuFunctionNVX & operator=( CuFunctionNVX && rhs ) = default;
#else
    CuFunctionNVX( CuFunctionNVX && rhs ) VULKAN_HPP_NOEXCEPT : m_cuFunctionNVX( exchange( rhs.m_cuFunctionNVX, {} ) ) {}

    CuFunctionNVX & operator=( CuFunctionNVX && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_cuFunctionNVX = exchange( rhs.m_cuFunctionNVX, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR CuFunctionNVX( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CuFunctionNVX( VkCuFunctionNVX cuFunctionNVX ) VULKAN_HPP_NOEXCEPT : m_cuFunctionNVX( cuFunctionNVX ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    CuFunctionNVX & operator=( VkCuFunctionNVX cuFunctionNVX ) VULKAN_HPP_NOEXCEPT
    {
      m_cuFunctionNVX = cuFunctionNVX;
      return *this;
    }
#endif

    CuFunctionNVX & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_cuFunctionNVX = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCuFunctionNVX() const VULKAN_HPP_NOEXCEPT
    {
      return m_cuFunctionNVX;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_cuFunctionNVX != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_cuFunctionNVX == VK_NULL_HANDLE;
    }

  private:
    VkCuFunctionNVX m_cuFunctionNVX = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eCuFunctionNVX>
  {
    using Type = CuFunctionNVX;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eCuFunctionNVX>
  {
    using Type = CuFunctionNVX;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkCuFunctionNVX, VK_NULL_HANDLE>
  {
    using Type = CuFunctionNVX;
  };
#endif

  template <>
  struct isVulkanHandleType<CuFunctionNVX>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkCuModuleNVX.html
  class CuModuleNVX
  {
  public:
    using CType      = VkCuModuleNVX;
    using NativeType = VkCuModuleNVX;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eCuModuleNVX;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eCuModuleNVX;

  public:
    CuModuleNVX() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    CuModuleNVX( CuModuleNVX const & rhs )             = default;
    CuModuleNVX & operator=( CuModuleNVX const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    CuModuleNVX( CuModuleNVX && rhs )             = default;
    CuModuleNVX & operator=( CuModuleNVX && rhs ) = default;
#else
    CuModuleNVX( CuModuleNVX && rhs ) VULKAN_HPP_NOEXCEPT : m_cuModuleNVX( exchange( rhs.m_cuModuleNVX, {} ) ) {}

    CuModuleNVX & operator=( CuModuleNVX && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_cuModuleNVX = exchange( rhs.m_cuModuleNVX, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR CuModuleNVX( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CuModuleNVX( VkCuModuleNVX cuModuleNVX ) VULKAN_HPP_NOEXCEPT : m_cuModuleNVX( cuModuleNVX ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    CuModuleNVX & operator=( VkCuModuleNVX cuModuleNVX ) VULKAN_HPP_NOEXCEPT
    {
      m_cuModuleNVX = cuModuleNVX;
      return *this;
    }
#endif

    CuModuleNVX & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_cuModuleNVX = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCuModuleNVX() const VULKAN_HPP_NOEXCEPT
    {
      return m_cuModuleNVX;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_cuModuleNVX != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_cuModuleNVX == VK_NULL_HANDLE;
    }

  private:
    VkCuModuleNVX m_cuModuleNVX = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eCuModuleNVX>
  {
    using Type = CuModuleNVX;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eCuModuleNVX>
  {
    using Type = CuModuleNVX;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkCuModuleNVX, VK_NULL_HANDLE>
  {
    using Type = CuModuleNVX;
  };
#endif

  template <>
  struct isVulkanHandleType<CuModuleNVX>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkCudaFunctionNV.html
#if defined( VK_ENABLE_BETA_EXTENSIONS )
  class CudaFunctionNV
  {
  public:
    using CType      = VkCudaFunctionNV;
    using NativeType = VkCudaFunctionNV;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eCudaFunctionNV;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eCudaFunctionNV;

  public:
    CudaFunctionNV() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    CudaFunctionNV( CudaFunctionNV const & rhs )             = default;
    CudaFunctionNV & operator=( CudaFunctionNV const & rhs ) = default;

#  if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    CudaFunctionNV( CudaFunctionNV && rhs )             = default;
    CudaFunctionNV & operator=( CudaFunctionNV && rhs ) = default;
#  else
    CudaFunctionNV( CudaFunctionNV && rhs ) VULKAN_HPP_NOEXCEPT : m_cudaFunctionNV( exchange( rhs.m_cudaFunctionNV, {} ) ) {}

    CudaFunctionNV & operator=( CudaFunctionNV && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_cudaFunctionNV = exchange( rhs.m_cudaFunctionNV, {} );
      return *this;
    }
#  endif

    VULKAN_HPP_CONSTEXPR CudaFunctionNV( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CudaFunctionNV( VkCudaFunctionNV cudaFunctionNV ) VULKAN_HPP_NOEXCEPT : m_cudaFunctionNV( cudaFunctionNV ) {}

#  if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    CudaFunctionNV & operator=( VkCudaFunctionNV cudaFunctionNV ) VULKAN_HPP_NOEXCEPT
    {
      m_cudaFunctionNV = cudaFunctionNV;
      return *this;
    }
#  endif

    CudaFunctionNV & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_cudaFunctionNV = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCudaFunctionNV() const VULKAN_HPP_NOEXCEPT
    {
      return m_cudaFunctionNV;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_cudaFunctionNV != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_cudaFunctionNV == VK_NULL_HANDLE;
    }

  private:
    VkCudaFunctionNV m_cudaFunctionNV = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eCudaFunctionNV>
  {
    using Type = CudaFunctionNV;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eCudaFunctionNV>
  {
    using Type = CudaFunctionNV;
  };

#  if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkCudaFunctionNV, VK_NULL_HANDLE>
  {
    using Type = CudaFunctionNV;
  };
#  endif

  template <>
  struct isVulkanHandleType<CudaFunctionNV>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  // wrapper class for handle VkCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkCudaModuleNV.html
#if defined( VK_ENABLE_BETA_EXTENSIONS )
  class CudaModuleNV
  {
  public:
    using CType      = VkCudaModuleNV;
    using NativeType = VkCudaModuleNV;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eCudaModuleNV;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eCudaModuleNV;

  public:
    CudaModuleNV() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    CudaModuleNV( CudaModuleNV const & rhs )             = default;
    CudaModuleNV & operator=( CudaModuleNV const & rhs ) = default;

#  if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    CudaModuleNV( CudaModuleNV && rhs )             = default;
    CudaModuleNV & operator=( CudaModuleNV && rhs ) = default;
#  else
    CudaModuleNV( CudaModuleNV && rhs ) VULKAN_HPP_NOEXCEPT : m_cudaModuleNV( exchange( rhs.m_cudaModuleNV, {} ) ) {}

    CudaModuleNV & operator=( CudaModuleNV && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_cudaModuleNV = exchange( rhs.m_cudaModuleNV, {} );
      return *this;
    }
#  endif

    VULKAN_HPP_CONSTEXPR CudaModuleNV( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT CudaModuleNV( VkCudaModuleNV cudaModuleNV ) VULKAN_HPP_NOEXCEPT : m_cudaModuleNV( cudaModuleNV ) {}

#  if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    CudaModuleNV & operator=( VkCudaModuleNV cudaModuleNV ) VULKAN_HPP_NOEXCEPT
    {
      m_cudaModuleNV = cudaModuleNV;
      return *this;
    }
#  endif

    CudaModuleNV & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_cudaModuleNV = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkCudaModuleNV() const VULKAN_HPP_NOEXCEPT
    {
      return m_cudaModuleNV;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_cudaModuleNV != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_cudaModuleNV == VK_NULL_HANDLE;
    }

  private:
    VkCudaModuleNV m_cudaModuleNV = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eCudaModuleNV>
  {
    using Type = CudaModuleNV;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eCudaModuleNV>
  {
    using Type = CudaModuleNV;
  };

#  if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkCudaModuleNV, VK_NULL_HANDLE>
  {
    using Type = CudaModuleNV;
  };
#  endif

  template <>
  struct isVulkanHandleType<CudaModuleNV>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };
#endif /*VK_ENABLE_BETA_EXTENSIONS*/

  // wrapper class for handle VkDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorPool.html
  class DescriptorPool
  {
  public:
    using CType      = VkDescriptorPool;
    using NativeType = VkDescriptorPool;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDescriptorPool;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDescriptorPool;

  public:
    DescriptorPool() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DescriptorPool( DescriptorPool const & rhs )             = default;
    DescriptorPool & operator=( DescriptorPool const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DescriptorPool( DescriptorPool && rhs )             = default;
    DescriptorPool & operator=( DescriptorPool && rhs ) = default;
#else
    DescriptorPool( DescriptorPool && rhs ) VULKAN_HPP_NOEXCEPT : m_descriptorPool( exchange( rhs.m_descriptorPool, {} ) ) {}

    DescriptorPool & operator=( DescriptorPool && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorPool = exchange( rhs.m_descriptorPool, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DescriptorPool( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorPool( VkDescriptorPool descriptorPool ) VULKAN_HPP_NOEXCEPT : m_descriptorPool( descriptorPool ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DescriptorPool & operator=( VkDescriptorPool descriptorPool ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorPool = descriptorPool;
      return *this;
    }
#endif

    DescriptorPool & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorPool = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorPool() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorPool;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorPool != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorPool == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorPool m_descriptorPool = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDescriptorPool>
  {
    using Type = DescriptorPool;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDescriptorPool>
  {
    using Type = DescriptorPool;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDescriptorPool, VK_NULL_HANDLE>
  {
    using Type = DescriptorPool;
  };
#endif

  template <>
  struct isVulkanHandleType<DescriptorPool>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDescriptorSetLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDescriptorSetLayout.html
  class DescriptorSetLayout
  {
  public:
    using CType      = VkDescriptorSetLayout;
    using NativeType = VkDescriptorSetLayout;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDescriptorSetLayout;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDescriptorSetLayout;

  public:
    DescriptorSetLayout() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DescriptorSetLayout( DescriptorSetLayout const & rhs )             = default;
    DescriptorSetLayout & operator=( DescriptorSetLayout const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DescriptorSetLayout( DescriptorSetLayout && rhs )             = default;
    DescriptorSetLayout & operator=( DescriptorSetLayout && rhs ) = default;
#else
    DescriptorSetLayout( DescriptorSetLayout && rhs ) VULKAN_HPP_NOEXCEPT : m_descriptorSetLayout( exchange( rhs.m_descriptorSetLayout, {} ) ) {}

    DescriptorSetLayout & operator=( DescriptorSetLayout && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorSetLayout = exchange( rhs.m_descriptorSetLayout, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DescriptorSetLayout( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DescriptorSetLayout( VkDescriptorSetLayout descriptorSetLayout ) VULKAN_HPP_NOEXCEPT
      : m_descriptorSetLayout( descriptorSetLayout )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DescriptorSetLayout & operator=( VkDescriptorSetLayout descriptorSetLayout ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorSetLayout = descriptorSetLayout;
      return *this;
    }
#endif

    DescriptorSetLayout & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_descriptorSetLayout = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDescriptorSetLayout() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorSetLayout;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorSetLayout != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_descriptorSetLayout == VK_NULL_HANDLE;
    }

  private:
    VkDescriptorSetLayout m_descriptorSetLayout = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDescriptorSetLayout>
  {
    using Type = DescriptorSetLayout;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDescriptorSetLayout>
  {
    using Type = DescriptorSetLayout;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDescriptorSetLayout, VK_NULL_HANDLE>
  {
    using Type = DescriptorSetLayout;
  };
#endif

  template <>
  struct isVulkanHandleType<DescriptorSetLayout>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkExternalComputeQueueNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkExternalComputeQueueNV.html
  class ExternalComputeQueueNV
  {
  public:
    using CType      = VkExternalComputeQueueNV;
    using NativeType = VkExternalComputeQueueNV;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eExternalComputeQueueNV;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    ExternalComputeQueueNV() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    ExternalComputeQueueNV( ExternalComputeQueueNV const & rhs )             = default;
    ExternalComputeQueueNV & operator=( ExternalComputeQueueNV const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    ExternalComputeQueueNV( ExternalComputeQueueNV && rhs )             = default;
    ExternalComputeQueueNV & operator=( ExternalComputeQueueNV && rhs ) = default;
#else
    ExternalComputeQueueNV( ExternalComputeQueueNV && rhs ) VULKAN_HPP_NOEXCEPT : m_externalComputeQueueNV( exchange( rhs.m_externalComputeQueueNV, {} ) ) {}

    ExternalComputeQueueNV & operator=( ExternalComputeQueueNV && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_externalComputeQueueNV = exchange( rhs.m_externalComputeQueueNV, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR ExternalComputeQueueNV( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    ExternalComputeQueueNV( VkExternalComputeQueueNV externalComputeQueueNV ) VULKAN_HPP_NOEXCEPT : m_externalComputeQueueNV( externalComputeQueueNV ) {}

    ExternalComputeQueueNV & operator=( VkExternalComputeQueueNV externalComputeQueueNV ) VULKAN_HPP_NOEXCEPT
    {
      m_externalComputeQueueNV = externalComputeQueueNV;
      return *this;
    }

    ExternalComputeQueueNV & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_externalComputeQueueNV = {};
      return *this;
    }

    //=== VK_NV_external_compute_queue ===

    // wrapper function for command vkGetExternalComputeQueueDataNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExternalComputeQueueDataNV.html
    void getData( ExternalComputeQueueDataParamsNV * params,
                  void *                             pData,
                  DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetExternalComputeQueueDataNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExternalComputeQueueDataNV.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD std::pair<ExternalComputeQueueDataParamsNV, DataType>
                         getData( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    operator VkExternalComputeQueueNV() const VULKAN_HPP_NOEXCEPT
    {
      return m_externalComputeQueueNV;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_externalComputeQueueNV != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_externalComputeQueueNV == VK_NULL_HANDLE;
    }

  private:
    VkExternalComputeQueueNV m_externalComputeQueueNV = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eExternalComputeQueueNV>
  {
    using Type = ExternalComputeQueueNV;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkExternalComputeQueueNV, VK_NULL_HANDLE>
  {
    using Type = ExternalComputeQueueNV;
  };
#endif

  template <>
  struct isVulkanHandleType<ExternalComputeQueueNV>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkFramebuffer.html
  class Framebuffer
  {
  public:
    using CType      = VkFramebuffer;
    using NativeType = VkFramebuffer;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eFramebuffer;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eFramebuffer;

  public:
    Framebuffer() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Framebuffer( Framebuffer const & rhs )             = default;
    Framebuffer & operator=( Framebuffer const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Framebuffer( Framebuffer && rhs )             = default;
    Framebuffer & operator=( Framebuffer && rhs ) = default;
#else
    Framebuffer( Framebuffer && rhs ) VULKAN_HPP_NOEXCEPT : m_framebuffer( exchange( rhs.m_framebuffer, {} ) ) {}

    Framebuffer & operator=( Framebuffer && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_framebuffer = exchange( rhs.m_framebuffer, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Framebuffer( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Framebuffer( VkFramebuffer framebuffer ) VULKAN_HPP_NOEXCEPT : m_framebuffer( framebuffer ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Framebuffer & operator=( VkFramebuffer framebuffer ) VULKAN_HPP_NOEXCEPT
    {
      m_framebuffer = framebuffer;
      return *this;
    }
#endif

    Framebuffer & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_framebuffer = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkFramebuffer() const VULKAN_HPP_NOEXCEPT
    {
      return m_framebuffer;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_framebuffer != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_framebuffer == VK_NULL_HANDLE;
    }

  private:
    VkFramebuffer m_framebuffer = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eFramebuffer>
  {
    using Type = Framebuffer;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eFramebuffer>
  {
    using Type = Framebuffer;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkFramebuffer, VK_NULL_HANDLE>
  {
    using Type = Framebuffer;
  };
#endif

  template <>
  struct isVulkanHandleType<Framebuffer>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkIndirectCommandsLayoutEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutEXT.html
  class IndirectCommandsLayoutEXT
  {
  public:
    using CType      = VkIndirectCommandsLayoutEXT;
    using NativeType = VkIndirectCommandsLayoutEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eIndirectCommandsLayoutEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    IndirectCommandsLayoutEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    IndirectCommandsLayoutEXT( IndirectCommandsLayoutEXT const & rhs )             = default;
    IndirectCommandsLayoutEXT & operator=( IndirectCommandsLayoutEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    IndirectCommandsLayoutEXT( IndirectCommandsLayoutEXT && rhs )             = default;
    IndirectCommandsLayoutEXT & operator=( IndirectCommandsLayoutEXT && rhs ) = default;
#else
    IndirectCommandsLayoutEXT( IndirectCommandsLayoutEXT && rhs ) VULKAN_HPP_NOEXCEPT
      : m_indirectCommandsLayoutEXT( exchange( rhs.m_indirectCommandsLayoutEXT, {} ) )
    {
    }

    IndirectCommandsLayoutEXT & operator=( IndirectCommandsLayoutEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectCommandsLayoutEXT = exchange( rhs.m_indirectCommandsLayoutEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR IndirectCommandsLayoutEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT IndirectCommandsLayoutEXT( VkIndirectCommandsLayoutEXT indirectCommandsLayoutEXT ) VULKAN_HPP_NOEXCEPT
      : m_indirectCommandsLayoutEXT( indirectCommandsLayoutEXT )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    IndirectCommandsLayoutEXT & operator=( VkIndirectCommandsLayoutEXT indirectCommandsLayoutEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectCommandsLayoutEXT = indirectCommandsLayoutEXT;
      return *this;
    }
#endif

    IndirectCommandsLayoutEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectCommandsLayoutEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkIndirectCommandsLayoutEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectCommandsLayoutEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectCommandsLayoutEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectCommandsLayoutEXT == VK_NULL_HANDLE;
    }

  private:
    VkIndirectCommandsLayoutEXT m_indirectCommandsLayoutEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eIndirectCommandsLayoutEXT>
  {
    using Type = IndirectCommandsLayoutEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkIndirectCommandsLayoutEXT, VK_NULL_HANDLE>
  {
    using Type = IndirectCommandsLayoutEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<IndirectCommandsLayoutEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkIndirectCommandsLayoutNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectCommandsLayoutNV.html
  class IndirectCommandsLayoutNV
  {
  public:
    using CType      = VkIndirectCommandsLayoutNV;
    using NativeType = VkIndirectCommandsLayoutNV;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eIndirectCommandsLayoutNV;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    IndirectCommandsLayoutNV() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    IndirectCommandsLayoutNV( IndirectCommandsLayoutNV const & rhs )             = default;
    IndirectCommandsLayoutNV & operator=( IndirectCommandsLayoutNV const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    IndirectCommandsLayoutNV( IndirectCommandsLayoutNV && rhs )             = default;
    IndirectCommandsLayoutNV & operator=( IndirectCommandsLayoutNV && rhs ) = default;
#else
    IndirectCommandsLayoutNV( IndirectCommandsLayoutNV && rhs ) VULKAN_HPP_NOEXCEPT
      : m_indirectCommandsLayoutNV( exchange( rhs.m_indirectCommandsLayoutNV, {} ) )
    {
    }

    IndirectCommandsLayoutNV & operator=( IndirectCommandsLayoutNV && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectCommandsLayoutNV = exchange( rhs.m_indirectCommandsLayoutNV, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR IndirectCommandsLayoutNV( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT IndirectCommandsLayoutNV( VkIndirectCommandsLayoutNV indirectCommandsLayoutNV ) VULKAN_HPP_NOEXCEPT
      : m_indirectCommandsLayoutNV( indirectCommandsLayoutNV )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    IndirectCommandsLayoutNV & operator=( VkIndirectCommandsLayoutNV indirectCommandsLayoutNV ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectCommandsLayoutNV = indirectCommandsLayoutNV;
      return *this;
    }
#endif

    IndirectCommandsLayoutNV & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectCommandsLayoutNV = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkIndirectCommandsLayoutNV() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectCommandsLayoutNV;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectCommandsLayoutNV != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectCommandsLayoutNV == VK_NULL_HANDLE;
    }

  private:
    VkIndirectCommandsLayoutNV m_indirectCommandsLayoutNV = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eIndirectCommandsLayoutNV>
  {
    using Type = IndirectCommandsLayoutNV;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkIndirectCommandsLayoutNV, VK_NULL_HANDLE>
  {
    using Type = IndirectCommandsLayoutNV;
  };
#endif

  template <>
  struct isVulkanHandleType<IndirectCommandsLayoutNV>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkIndirectExecutionSetEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkIndirectExecutionSetEXT.html
  class IndirectExecutionSetEXT
  {
  public:
    using CType      = VkIndirectExecutionSetEXT;
    using NativeType = VkIndirectExecutionSetEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eIndirectExecutionSetEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    IndirectExecutionSetEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    IndirectExecutionSetEXT( IndirectExecutionSetEXT const & rhs )             = default;
    IndirectExecutionSetEXT & operator=( IndirectExecutionSetEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    IndirectExecutionSetEXT( IndirectExecutionSetEXT && rhs )             = default;
    IndirectExecutionSetEXT & operator=( IndirectExecutionSetEXT && rhs ) = default;
#else
    IndirectExecutionSetEXT( IndirectExecutionSetEXT && rhs ) VULKAN_HPP_NOEXCEPT : m_indirectExecutionSetEXT( exchange( rhs.m_indirectExecutionSetEXT, {} ) )
    {
    }

    IndirectExecutionSetEXT & operator=( IndirectExecutionSetEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectExecutionSetEXT = exchange( rhs.m_indirectExecutionSetEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR IndirectExecutionSetEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT IndirectExecutionSetEXT( VkIndirectExecutionSetEXT indirectExecutionSetEXT ) VULKAN_HPP_NOEXCEPT
      : m_indirectExecutionSetEXT( indirectExecutionSetEXT )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    IndirectExecutionSetEXT & operator=( VkIndirectExecutionSetEXT indirectExecutionSetEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectExecutionSetEXT = indirectExecutionSetEXT;
      return *this;
    }
#endif

    IndirectExecutionSetEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_indirectExecutionSetEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkIndirectExecutionSetEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectExecutionSetEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectExecutionSetEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_indirectExecutionSetEXT == VK_NULL_HANDLE;
    }

  private:
    VkIndirectExecutionSetEXT m_indirectExecutionSetEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eIndirectExecutionSetEXT>
  {
    using Type = IndirectExecutionSetEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkIndirectExecutionSetEXT, VK_NULL_HANDLE>
  {
    using Type = IndirectExecutionSetEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<IndirectExecutionSetEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkPrivateDataSlot.html
  class PrivateDataSlot
  {
  public:
    using CType      = VkPrivateDataSlot;
    using NativeType = VkPrivateDataSlot;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePrivateDataSlot;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    PrivateDataSlot() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    PrivateDataSlot( PrivateDataSlot const & rhs )             = default;
    PrivateDataSlot & operator=( PrivateDataSlot const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    PrivateDataSlot( PrivateDataSlot && rhs )             = default;
    PrivateDataSlot & operator=( PrivateDataSlot && rhs ) = default;
#else
    PrivateDataSlot( PrivateDataSlot && rhs ) VULKAN_HPP_NOEXCEPT : m_privateDataSlot( exchange( rhs.m_privateDataSlot, {} ) ) {}

    PrivateDataSlot & operator=( PrivateDataSlot && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_privateDataSlot = exchange( rhs.m_privateDataSlot, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR PrivateDataSlot( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PrivateDataSlot( VkPrivateDataSlot privateDataSlot ) VULKAN_HPP_NOEXCEPT : m_privateDataSlot( privateDataSlot ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    PrivateDataSlot & operator=( VkPrivateDataSlot privateDataSlot ) VULKAN_HPP_NOEXCEPT
    {
      m_privateDataSlot = privateDataSlot;
      return *this;
    }
#endif

    PrivateDataSlot & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_privateDataSlot = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPrivateDataSlot() const VULKAN_HPP_NOEXCEPT
    {
      return m_privateDataSlot;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_privateDataSlot != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_privateDataSlot == VK_NULL_HANDLE;
    }

  private:
    VkPrivateDataSlot m_privateDataSlot = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePrivateDataSlot>
  {
    using Type = PrivateDataSlot;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPrivateDataSlot, VK_NULL_HANDLE>
  {
    using Type = PrivateDataSlot;
  };
#endif

  template <>
  struct isVulkanHandleType<PrivateDataSlot>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  using PrivateDataSlotEXT = PrivateDataSlot;

  // wrapper class for handle VkRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkRenderPass.html
  class RenderPass
  {
  public:
    using CType      = VkRenderPass;
    using NativeType = VkRenderPass;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eRenderPass;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eRenderPass;

  public:
    RenderPass() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    RenderPass( RenderPass const & rhs )             = default;
    RenderPass & operator=( RenderPass const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    RenderPass( RenderPass && rhs )             = default;
    RenderPass & operator=( RenderPass && rhs ) = default;
#else
    RenderPass( RenderPass && rhs ) VULKAN_HPP_NOEXCEPT : m_renderPass( exchange( rhs.m_renderPass, {} ) ) {}

    RenderPass & operator=( RenderPass && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_renderPass = exchange( rhs.m_renderPass, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR RenderPass( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT RenderPass( VkRenderPass renderPass ) VULKAN_HPP_NOEXCEPT : m_renderPass( renderPass ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    RenderPass & operator=( VkRenderPass renderPass ) VULKAN_HPP_NOEXCEPT
    {
      m_renderPass = renderPass;
      return *this;
    }
#endif

    RenderPass & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_renderPass = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkRenderPass() const VULKAN_HPP_NOEXCEPT
    {
      return m_renderPass;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_renderPass != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_renderPass == VK_NULL_HANDLE;
    }

  private:
    VkRenderPass m_renderPass = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eRenderPass>
  {
    using Type = RenderPass;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eRenderPass>
  {
    using Type = RenderPass;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkRenderPass, VK_NULL_HANDLE>
  {
    using Type = RenderPass;
  };
#endif

  template <>
  struct isVulkanHandleType<RenderPass>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkSampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkSampler.html
  class Sampler
  {
  public:
    using CType      = VkSampler;
    using NativeType = VkSampler;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eSampler;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eSampler;

  public:
    Sampler() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Sampler( Sampler const & rhs )             = default;
    Sampler & operator=( Sampler const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Sampler( Sampler && rhs )             = default;
    Sampler & operator=( Sampler && rhs ) = default;
#else
    Sampler( Sampler && rhs ) VULKAN_HPP_NOEXCEPT : m_sampler( exchange( rhs.m_sampler, {} ) ) {}

    Sampler & operator=( Sampler && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_sampler = exchange( rhs.m_sampler, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Sampler( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT Sampler( VkSampler sampler ) VULKAN_HPP_NOEXCEPT : m_sampler( sampler ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    Sampler & operator=( VkSampler sampler ) VULKAN_HPP_NOEXCEPT
    {
      m_sampler = sampler;
      return *this;
    }
#endif

    Sampler & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_sampler = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSampler() const VULKAN_HPP_NOEXCEPT
    {
      return m_sampler;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_sampler != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_sampler == VK_NULL_HANDLE;
    }

  private:
    VkSampler m_sampler = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eSampler>
  {
    using Type = Sampler;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eSampler>
  {
    using Type = Sampler;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkSampler, VK_NULL_HANDLE>
  {
    using Type = Sampler;
  };
#endif

  template <>
  struct isVulkanHandleType<Sampler>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkSamplerYcbcrConversion, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkSamplerYcbcrConversion.html
  class SamplerYcbcrConversion
  {
  public:
    using CType      = VkSamplerYcbcrConversion;
    using NativeType = VkSamplerYcbcrConversion;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eSamplerYcbcrConversion;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eSamplerYcbcrConversion;

  public:
    SamplerYcbcrConversion() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    SamplerYcbcrConversion( SamplerYcbcrConversion const & rhs )             = default;
    SamplerYcbcrConversion & operator=( SamplerYcbcrConversion const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    SamplerYcbcrConversion( SamplerYcbcrConversion && rhs )             = default;
    SamplerYcbcrConversion & operator=( SamplerYcbcrConversion && rhs ) = default;
#else
    SamplerYcbcrConversion( SamplerYcbcrConversion && rhs ) VULKAN_HPP_NOEXCEPT : m_samplerYcbcrConversion( exchange( rhs.m_samplerYcbcrConversion, {} ) ) {}

    SamplerYcbcrConversion & operator=( SamplerYcbcrConversion && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_samplerYcbcrConversion = exchange( rhs.m_samplerYcbcrConversion, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR SamplerYcbcrConversion( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT SamplerYcbcrConversion( VkSamplerYcbcrConversion samplerYcbcrConversion ) VULKAN_HPP_NOEXCEPT
      : m_samplerYcbcrConversion( samplerYcbcrConversion )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    SamplerYcbcrConversion & operator=( VkSamplerYcbcrConversion samplerYcbcrConversion ) VULKAN_HPP_NOEXCEPT
    {
      m_samplerYcbcrConversion = samplerYcbcrConversion;
      return *this;
    }
#endif

    SamplerYcbcrConversion & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_samplerYcbcrConversion = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkSamplerYcbcrConversion() const VULKAN_HPP_NOEXCEPT
    {
      return m_samplerYcbcrConversion;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_samplerYcbcrConversion != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_samplerYcbcrConversion == VK_NULL_HANDLE;
    }

  private:
    VkSamplerYcbcrConversion m_samplerYcbcrConversion = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eSamplerYcbcrConversion>
  {
    using Type = SamplerYcbcrConversion;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eSamplerYcbcrConversion>
  {
    using Type = SamplerYcbcrConversion;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkSamplerYcbcrConversion, VK_NULL_HANDLE>
  {
    using Type = SamplerYcbcrConversion;
  };
#endif

  template <>
  struct isVulkanHandleType<SamplerYcbcrConversion>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  using SamplerYcbcrConversionKHR = SamplerYcbcrConversion;

  // wrapper class for handle VkShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkShaderModule.html
  class ShaderModule
  {
  public:
    using CType      = VkShaderModule;
    using NativeType = VkShaderModule;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eShaderModule;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eShaderModule;

  public:
    ShaderModule() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    ShaderModule( ShaderModule const & rhs )             = default;
    ShaderModule & operator=( ShaderModule const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    ShaderModule( ShaderModule && rhs )             = default;
    ShaderModule & operator=( ShaderModule && rhs ) = default;
#else
    ShaderModule( ShaderModule && rhs ) VULKAN_HPP_NOEXCEPT : m_shaderModule( exchange( rhs.m_shaderModule, {} ) ) {}

    ShaderModule & operator=( ShaderModule && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_shaderModule = exchange( rhs.m_shaderModule, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR ShaderModule( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ShaderModule( VkShaderModule shaderModule ) VULKAN_HPP_NOEXCEPT : m_shaderModule( shaderModule ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    ShaderModule & operator=( VkShaderModule shaderModule ) VULKAN_HPP_NOEXCEPT
    {
      m_shaderModule = shaderModule;
      return *this;
    }
#endif

    ShaderModule & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_shaderModule = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkShaderModule() const VULKAN_HPP_NOEXCEPT
    {
      return m_shaderModule;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_shaderModule != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_shaderModule == VK_NULL_HANDLE;
    }

  private:
    VkShaderModule m_shaderModule = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eShaderModule>
  {
    using Type = ShaderModule;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eShaderModule>
  {
    using Type = ShaderModule;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkShaderModule, VK_NULL_HANDLE>
  {
    using Type = ShaderModule;
  };
#endif

  template <>
  struct isVulkanHandleType<ShaderModule>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorARM.html
  class TensorARM
  {
  public:
    using CType      = VkTensorARM;
    using NativeType = VkTensorARM;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eTensorARM;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    TensorARM() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    TensorARM( TensorARM const & rhs )             = default;
    TensorARM & operator=( TensorARM const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    TensorARM( TensorARM && rhs )             = default;
    TensorARM & operator=( TensorARM && rhs ) = default;
#else
    TensorARM( TensorARM && rhs ) VULKAN_HPP_NOEXCEPT : m_tensorARM( exchange( rhs.m_tensorARM, {} ) ) {}

    TensorARM & operator=( TensorARM && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_tensorARM = exchange( rhs.m_tensorARM, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR TensorARM( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT TensorARM( VkTensorARM tensorARM ) VULKAN_HPP_NOEXCEPT : m_tensorARM( tensorARM ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    TensorARM & operator=( VkTensorARM tensorARM ) VULKAN_HPP_NOEXCEPT
    {
      m_tensorARM = tensorARM;
      return *this;
    }
#endif

    TensorARM & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_tensorARM = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkTensorARM() const VULKAN_HPP_NOEXCEPT
    {
      return m_tensorARM;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_tensorARM != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_tensorARM == VK_NULL_HANDLE;
    }

  private:
    VkTensorARM m_tensorARM = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eTensorARM>
  {
    using Type = TensorARM;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkTensorARM, VK_NULL_HANDLE>
  {
    using Type = TensorARM;
  };
#endif

  template <>
  struct isVulkanHandleType<TensorARM>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkTensorViewARM.html
  class TensorViewARM
  {
  public:
    using CType      = VkTensorViewARM;
    using NativeType = VkTensorViewARM;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eTensorViewARM;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    TensorViewARM() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    TensorViewARM( TensorViewARM const & rhs )             = default;
    TensorViewARM & operator=( TensorViewARM const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    TensorViewARM( TensorViewARM && rhs )             = default;
    TensorViewARM & operator=( TensorViewARM && rhs ) = default;
#else
    TensorViewARM( TensorViewARM && rhs ) VULKAN_HPP_NOEXCEPT : m_tensorViewARM( exchange( rhs.m_tensorViewARM, {} ) ) {}

    TensorViewARM & operator=( TensorViewARM && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_tensorViewARM = exchange( rhs.m_tensorViewARM, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR TensorViewARM( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT TensorViewARM( VkTensorViewARM tensorViewARM ) VULKAN_HPP_NOEXCEPT : m_tensorViewARM( tensorViewARM ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    TensorViewARM & operator=( VkTensorViewARM tensorViewARM ) VULKAN_HPP_NOEXCEPT
    {
      m_tensorViewARM = tensorViewARM;
      return *this;
    }
#endif

    TensorViewARM & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_tensorViewARM = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkTensorViewARM() const VULKAN_HPP_NOEXCEPT
    {
      return m_tensorViewARM;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_tensorViewARM != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_tensorViewARM == VK_NULL_HANDLE;
    }

  private:
    VkTensorViewARM m_tensorViewARM = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eTensorViewARM>
  {
    using Type = TensorViewARM;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkTensorViewARM, VK_NULL_HANDLE>
  {
    using Type = TensorViewARM;
  };
#endif

  template <>
  struct isVulkanHandleType<TensorViewARM>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkValidationCacheEXT.html
  class ValidationCacheEXT
  {
  public:
    using CType      = VkValidationCacheEXT;
    using NativeType = VkValidationCacheEXT;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eValidationCacheEXT;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eValidationCacheEXT;

  public:
    ValidationCacheEXT() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    ValidationCacheEXT( ValidationCacheEXT const & rhs )             = default;
    ValidationCacheEXT & operator=( ValidationCacheEXT const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    ValidationCacheEXT( ValidationCacheEXT && rhs )             = default;
    ValidationCacheEXT & operator=( ValidationCacheEXT && rhs ) = default;
#else
    ValidationCacheEXT( ValidationCacheEXT && rhs ) VULKAN_HPP_NOEXCEPT : m_validationCacheEXT( exchange( rhs.m_validationCacheEXT, {} ) ) {}

    ValidationCacheEXT & operator=( ValidationCacheEXT && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_validationCacheEXT = exchange( rhs.m_validationCacheEXT, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR ValidationCacheEXT( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT ValidationCacheEXT( VkValidationCacheEXT validationCacheEXT ) VULKAN_HPP_NOEXCEPT : m_validationCacheEXT( validationCacheEXT )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    ValidationCacheEXT & operator=( VkValidationCacheEXT validationCacheEXT ) VULKAN_HPP_NOEXCEPT
    {
      m_validationCacheEXT = validationCacheEXT;
      return *this;
    }
#endif

    ValidationCacheEXT & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_validationCacheEXT = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkValidationCacheEXT() const VULKAN_HPP_NOEXCEPT
    {
      return m_validationCacheEXT;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_validationCacheEXT != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_validationCacheEXT == VK_NULL_HANDLE;
    }

  private:
    VkValidationCacheEXT m_validationCacheEXT = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eValidationCacheEXT>
  {
    using Type = ValidationCacheEXT;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eValidationCacheEXT>
  {
    using Type = ValidationCacheEXT;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkValidationCacheEXT, VK_NULL_HANDLE>
  {
    using Type = ValidationCacheEXT;
  };
#endif

  template <>
  struct isVulkanHandleType<ValidationCacheEXT>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkVideoSessionParametersKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkVideoSessionParametersKHR.html
  class VideoSessionParametersKHR
  {
  public:
    using CType      = VkVideoSessionParametersKHR;
    using NativeType = VkVideoSessionParametersKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eVideoSessionParametersKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    VideoSessionParametersKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    VideoSessionParametersKHR( VideoSessionParametersKHR const & rhs )             = default;
    VideoSessionParametersKHR & operator=( VideoSessionParametersKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    VideoSessionParametersKHR( VideoSessionParametersKHR && rhs )             = default;
    VideoSessionParametersKHR & operator=( VideoSessionParametersKHR && rhs ) = default;
#else
    VideoSessionParametersKHR( VideoSessionParametersKHR && rhs ) VULKAN_HPP_NOEXCEPT
      : m_videoSessionParametersKHR( exchange( rhs.m_videoSessionParametersKHR, {} ) )
    {
    }

    VideoSessionParametersKHR & operator=( VideoSessionParametersKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_videoSessionParametersKHR = exchange( rhs.m_videoSessionParametersKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR VideoSessionParametersKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT VideoSessionParametersKHR( VkVideoSessionParametersKHR videoSessionParametersKHR ) VULKAN_HPP_NOEXCEPT
      : m_videoSessionParametersKHR( videoSessionParametersKHR )
    {
    }

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    VideoSessionParametersKHR & operator=( VkVideoSessionParametersKHR videoSessionParametersKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_videoSessionParametersKHR = videoSessionParametersKHR;
      return *this;
    }
#endif

    VideoSessionParametersKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_videoSessionParametersKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkVideoSessionParametersKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_videoSessionParametersKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_videoSessionParametersKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_videoSessionParametersKHR == VK_NULL_HANDLE;
    }

  private:
    VkVideoSessionParametersKHR m_videoSessionParametersKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eVideoSessionParametersKHR>
  {
    using Type = VideoSessionParametersKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkVideoSessionParametersKHR, VK_NULL_HANDLE>
  {
    using Type = VideoSessionParametersKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<VideoSessionParametersKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPipelineBinaryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkPipelineBinaryKHR.html
  class PipelineBinaryKHR
  {
  public:
    using CType      = VkPipelineBinaryKHR;
    using NativeType = VkPipelineBinaryKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePipelineBinaryKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eUnknown;

  public:
    PipelineBinaryKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    PipelineBinaryKHR( PipelineBinaryKHR const & rhs )             = default;
    PipelineBinaryKHR & operator=( PipelineBinaryKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    PipelineBinaryKHR( PipelineBinaryKHR && rhs )             = default;
    PipelineBinaryKHR & operator=( PipelineBinaryKHR && rhs ) = default;
#else
    PipelineBinaryKHR( PipelineBinaryKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_pipelineBinaryKHR( exchange( rhs.m_pipelineBinaryKHR, {} ) ) {}

    PipelineBinaryKHR & operator=( PipelineBinaryKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineBinaryKHR = exchange( rhs.m_pipelineBinaryKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR PipelineBinaryKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT PipelineBinaryKHR( VkPipelineBinaryKHR pipelineBinaryKHR ) VULKAN_HPP_NOEXCEPT : m_pipelineBinaryKHR( pipelineBinaryKHR ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    PipelineBinaryKHR & operator=( VkPipelineBinaryKHR pipelineBinaryKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineBinaryKHR = pipelineBinaryKHR;
      return *this;
    }
#endif

    PipelineBinaryKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_pipelineBinaryKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkPipelineBinaryKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineBinaryKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineBinaryKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_pipelineBinaryKHR == VK_NULL_HANDLE;
    }

  private:
    VkPipelineBinaryKHR m_pipelineBinaryKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePipelineBinaryKHR>
  {
    using Type = PipelineBinaryKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPipelineBinaryKHR, VK_NULL_HANDLE>
  {
    using Type = PipelineBinaryKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<PipelineBinaryKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkQueue, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkQueue.html
  class Queue
  {
  public:
    using CType      = VkQueue;
    using NativeType = VkQueue;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eQueue;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eQueue;

  public:
    Queue() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Queue( Queue const & rhs )             = default;
    Queue & operator=( Queue const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Queue( Queue && rhs )             = default;
    Queue & operator=( Queue && rhs ) = default;
#else
    Queue( Queue && rhs ) VULKAN_HPP_NOEXCEPT : m_queue( exchange( rhs.m_queue, {} ) ) {}

    Queue & operator=( Queue && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_queue = exchange( rhs.m_queue, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Queue( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    Queue( VkQueue queue ) VULKAN_HPP_NOEXCEPT : m_queue( queue ) {}

    Queue & operator=( VkQueue queue ) VULKAN_HPP_NOEXCEPT
    {
      m_queue = queue;
      return *this;
    }

    Queue & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_queue = {};
      return *this;
    }

    //=== VK_VERSION_1_0 ===

    // wrapper function for command vkQueueSubmit, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit.html
    VULKAN_HPP_NODISCARD Result submit( uint32_t                 submitCount,
                                        SubmitInfo const *       pSubmits,
                                        Fence                    fence,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueSubmit, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      submit( ArrayProxy<SubmitInfo const> const & submits,
              Fence fence                          VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
              DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueWaitIdle, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueWaitIdle.html
    VULKAN_HPP_NODISCARD Result waitIdle( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkQueueWaitIdle, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueWaitIdle.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      waitIdle( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkQueueBindSparse, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBindSparse.html
    VULKAN_HPP_NODISCARD Result bindSparse( uint32_t                 bindInfoCount,
                                            BindSparseInfo const *   pBindInfo,
                                            Fence                    fence,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueBindSparse, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBindSparse.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindSparse( ArrayProxy<BindSparseInfo const> const & bindInfo,
                  Fence fence                              VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                  DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_3 ===

    // wrapper function for command vkQueueSubmit2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2.html
    VULKAN_HPP_NODISCARD Result submit2( uint32_t                 submitCount,
                                         SubmitInfo2 const *      pSubmits,
                                         Fence                    fence,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueSubmit2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      submit2( ArrayProxy<SubmitInfo2 const> const & submits,
               Fence fence                           VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
               DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_swapchain ===

    // wrapper function for command vkQueuePresentKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueuePresentKHR.html
    VULKAN_HPP_NODISCARD Result presentKHR( PresentInfoKHR const *   pPresentInfo,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueuePresentKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueuePresentKHR.html
    VULKAN_HPP_NODISCARD Result presentKHR( PresentInfoKHR const & presentInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_debug_utils ===

    // wrapper function for command vkQueueBeginDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBeginDebugUtilsLabelEXT.html
    void beginDebugUtilsLabelEXT( DebugUtilsLabelEXT const * pLabelInfo,
                                  DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueBeginDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueBeginDebugUtilsLabelEXT.html
    void beginDebugUtilsLabelEXT( DebugUtilsLabelEXT const & labelInfo,
                                  DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkQueueEndDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueEndDebugUtilsLabelEXT.html
    void endDebugUtilsLabelEXT( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkQueueInsertDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueInsertDebugUtilsLabelEXT.html
    void insertDebugUtilsLabelEXT( DebugUtilsLabelEXT const * pLabelInfo,
                                   DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueInsertDebugUtilsLabelEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueInsertDebugUtilsLabelEXT.html
    void insertDebugUtilsLabelEXT( DebugUtilsLabelEXT const & labelInfo,
                                   DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_device_diagnostic_checkpoints ===

    // wrapper function for command vkGetQueueCheckpointDataNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointDataNV.html
    void getCheckpointDataNV( uint32_t *               pCheckpointDataCount,
                              CheckpointDataNV *       pCheckpointData,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetQueueCheckpointDataNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointDataNV.html
    template <typename CheckpointDataNVAllocator = std::allocator<CheckpointDataNV>>
    VULKAN_HPP_NODISCARD std::vector<CheckpointDataNV, CheckpointDataNVAllocator>
                         getCheckpointDataNV( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetQueueCheckpointDataNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointDataNV.html
    template <typename CheckpointDataNVAllocator = std::allocator<CheckpointDataNV>>
    VULKAN_HPP_NODISCARD std::vector<CheckpointDataNV, CheckpointDataNVAllocator>
                         getCheckpointDataNV( CheckpointDataNVAllocator const & checkpointDataNVAllocator,
                                              DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetQueueCheckpointData2NV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointData2NV.html
    void getCheckpointData2NV( uint32_t *               pCheckpointDataCount,
                               CheckpointData2NV *      pCheckpointData,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetQueueCheckpointData2NV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointData2NV.html
    template <typename CheckpointData2NVAllocator = std::allocator<CheckpointData2NV>>
    VULKAN_HPP_NODISCARD std::vector<CheckpointData2NV, CheckpointData2NVAllocator>
                         getCheckpointData2NV( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetQueueCheckpointData2NV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueueCheckpointData2NV.html
    template <typename CheckpointData2NVAllocator = std::allocator<CheckpointData2NV>>
    VULKAN_HPP_NODISCARD std::vector<CheckpointData2NV, CheckpointData2NVAllocator>
                         getCheckpointData2NV( CheckpointData2NVAllocator const & checkpointData2NVAllocator,
                                               DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_INTEL_performance_query ===

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueSetPerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSetPerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD Result setPerformanceConfigurationINTEL( PerformanceConfigurationINTEL configuration,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkQueueSetPerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSetPerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setPerformanceConfigurationINTEL( PerformanceConfigurationINTEL configuration, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    //=== VK_KHR_synchronization2 ===

    // wrapper function for command vkQueueSubmit2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2KHR.html
    VULKAN_HPP_NODISCARD Result submit2KHR( uint32_t                 submitCount,
                                            SubmitInfo2 const *      pSubmits,
                                            Fence                    fence,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueSubmit2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueSubmit2KHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      submit2KHR( ArrayProxy<SubmitInfo2 const> const & submits,
                  Fence fence                           VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                  DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_low_latency2 ===

    // wrapper function for command vkQueueNotifyOutOfBandNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueNotifyOutOfBandNV.html
    void notifyOutOfBandNV( OutOfBandQueueTypeInfoNV const * pQueueTypeInfo,
                            DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkQueueNotifyOutOfBandNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkQueueNotifyOutOfBandNV.html
    void notifyOutOfBandNV( OutOfBandQueueTypeInfoNV const & queueTypeInfo,
                            DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    operator VkQueue() const VULKAN_HPP_NOEXCEPT
    {
      return m_queue;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_queue != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_queue == VK_NULL_HANDLE;
    }

  private:
    VkQueue m_queue = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eQueue>
  {
    using Type = Queue;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eQueue>
  {
    using Type = Queue;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkQueue, VK_NULL_HANDLE>
  {
    using Type = Queue;
  };
#endif

  template <>
  struct isVulkanHandleType<Queue>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDevice.html
  class Device
  {
  public:
    using CType      = VkDevice;
    using NativeType = VkDevice;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDevice;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDevice;

  public:
    Device() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Device( Device const & rhs )             = default;
    Device & operator=( Device const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Device( Device && rhs )             = default;
    Device & operator=( Device && rhs ) = default;
#else
    Device( Device && rhs ) VULKAN_HPP_NOEXCEPT : m_device( exchange( rhs.m_device, {} ) ) {}

    Device & operator=( Device && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_device = exchange( rhs.m_device, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Device( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    Device( VkDevice device ) VULKAN_HPP_NOEXCEPT : m_device( device ) {}

    Device & operator=( VkDevice device ) VULKAN_HPP_NOEXCEPT
    {
      m_device = device;
      return *this;
    }

    Device & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_device = {};
      return *this;
    }

    //=== VK_VERSION_1_0 ===

    // wrapper function for command vkGetDeviceProcAddr, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html
    PFN_vkVoidFunction getProcAddr( char const * pName, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceProcAddr, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceProcAddr.html
    PFN_VoidFunction getProcAddr( std::string const & name, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDevice.html
    void destroy( AllocationCallbacks const * pAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDevice.html
    void destroy( Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceQueue, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue.html
    void getQueue( uint32_t                 queueFamilyIndex,
                   uint32_t                 queueIndex,
                   Queue *                  pQueue,
                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceQueue, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue.html
    VULKAN_HPP_NODISCARD Queue getQueue( uint32_t                 queueFamilyIndex,
                                         uint32_t                 queueIndex,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDeviceWaitIdle, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeviceWaitIdle.html
    VULKAN_HPP_NODISCARD Result waitIdle( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkDeviceWaitIdle, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeviceWaitIdle.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      waitIdle( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkAllocateMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateMemory.html
    VULKAN_HPP_NODISCARD Result allocateMemory( MemoryAllocateInfo const *  pAllocateInfo,
                                                AllocationCallbacks const * pAllocator,
                                                DeviceMemory *              pMemory,
                                                DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAllocateMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateMemory.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DeviceMemory>::type
      allocateMemory( MemoryAllocateInfo const &                    allocateInfo,
                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkAllocateMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateMemory.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DeviceMemory>>::type
      allocateMemoryUnique( MemoryAllocateInfo const &                    allocateInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkFreeMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeMemory.html
    void freeMemory( DeviceMemory                memory,
                     AllocationCallbacks const * pAllocator,
                     DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFreeMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeMemory.html
    void freeMemory( DeviceMemory memory                           VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkFreeMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeMemory.html
    void( free )( DeviceMemory                memory,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFreeMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeMemory.html
    void( free )( DeviceMemory                                  memory,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkMapMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory.html
    VULKAN_HPP_NODISCARD Result mapMemory( DeviceMemory             memory,
                                           DeviceSize               offset,
                                           DeviceSize               size,
                                           MemoryMapFlags           flags,
                                           void **                  ppData,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkMapMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory.html
    VULKAN_HPP_NODISCARD typename ResultValueType<void *>::type mapMemory( DeviceMemory             memory,
                                                                           DeviceSize               offset,
                                                                           DeviceSize               size,
                                                                           MemoryMapFlags flags     VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUnmapMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory.html
    void unmapMemory( DeviceMemory memory, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkFlushMappedMemoryRanges, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFlushMappedMemoryRanges.html
    VULKAN_HPP_NODISCARD Result flushMappedMemoryRanges( uint32_t                  memoryRangeCount,
                                                         MappedMemoryRange const * pMemoryRanges,
                                                         DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFlushMappedMemoryRanges, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFlushMappedMemoryRanges.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      flushMappedMemoryRanges( ArrayProxy<MappedMemoryRange const> const & memoryRanges,
                               DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkInvalidateMappedMemoryRanges, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkInvalidateMappedMemoryRanges.html
    VULKAN_HPP_NODISCARD Result invalidateMappedMemoryRanges( uint32_t                  memoryRangeCount,
                                                              MappedMemoryRange const * pMemoryRanges,
                                                              DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkInvalidateMappedMemoryRanges, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkInvalidateMappedMemoryRanges.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      invalidateMappedMemoryRanges( ArrayProxy<MappedMemoryRange const> const & memoryRanges,
                                    DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceMemoryCommitment, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryCommitment.html
    void getMemoryCommitment( DeviceMemory             memory,
                              DeviceSize *             pCommittedMemoryInBytes,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceMemoryCommitment, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryCommitment.html
    VULKAN_HPP_NODISCARD DeviceSize getMemoryCommitment( DeviceMemory             memory,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindBufferMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory.html
    VULKAN_HPP_NODISCARD Result bindBufferMemory( Buffer                   buffer,
                                                  DeviceMemory             memory,
                                                  DeviceSize               memoryOffset,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkBindBufferMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindBufferMemory( Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindImageMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory.html
    VULKAN_HPP_NODISCARD Result bindImageMemory( Image                    image,
                                                 DeviceMemory             memory,
                                                 DeviceSize               memoryOffset,
                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkBindImageMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindImageMemory( Image image, DeviceMemory memory, DeviceSize memoryOffset, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetBufferMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements.html
    void getBufferMemoryRequirements( Buffer                   buffer,
                                      MemoryRequirements *     pMemoryRequirements,
                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements.html
    VULKAN_HPP_NODISCARD MemoryRequirements
      getBufferMemoryRequirements( Buffer buffer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements.html
    void getImageMemoryRequirements( Image                    image,
                                     MemoryRequirements *     pMemoryRequirements,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements.html
    VULKAN_HPP_NODISCARD MemoryRequirements
      getImageMemoryRequirements( Image image, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSparseMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements.html
    void getImageSparseMemoryRequirements( Image                           image,
                                           uint32_t *                      pSparseMemoryRequirementCount,
                                           SparseImageMemoryRequirements * pSparseMemoryRequirements,
                                           DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSparseMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements.html
    template <typename SparseImageMemoryRequirementsAllocator = std::allocator<SparseImageMemoryRequirements>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements, SparseImageMemoryRequirementsAllocator>
                         getImageSparseMemoryRequirements( Image image, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetImageSparseMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements.html
    template <typename SparseImageMemoryRequirementsAllocator = std::allocator<SparseImageMemoryRequirements>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements, SparseImageMemoryRequirementsAllocator>
                         getImageSparseMemoryRequirements( Image                                          image,
                                                           SparseImageMemoryRequirementsAllocator const & sparseImageMemoryRequirementsAllocator,
                                                           DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFence.html
    VULKAN_HPP_NODISCARD Result createFence( FenceCreateInfo const *     pCreateInfo,
                                             AllocationCallbacks const * pAllocator,
                                             Fence *                     pFence,
                                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFence.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Fence>::type
      createFence( FenceCreateInfo const &                       createInfo,
                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFence.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Fence>>::type
      createFenceUnique( FenceCreateInfo const &                       createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFence.html
    void destroyFence( Fence                       fence,
                       AllocationCallbacks const * pAllocator,
                       DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFence.html
    void destroyFence( Fence fence                                   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFence.html
    void destroy( Fence                       fence,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyFence, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFence.html
    void destroy( Fence                                         fence,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkResetFences, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetFences.html
    VULKAN_HPP_NODISCARD Result resetFences( uint32_t                 fenceCount,
                                             Fence const *            pFences,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkResetFences, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetFences.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      resetFences( ArrayProxy<Fence const> const & fences, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetFenceStatus, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceStatus.html
    VULKAN_HPP_NODISCARD Result getFenceStatus( Fence fence, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkGetFenceStatus, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceStatus.html
    VULKAN_HPP_NODISCARD Result getFenceStatus( Fence fence, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkWaitForFences, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForFences.html
    VULKAN_HPP_NODISCARD Result waitForFences( uint32_t                 fenceCount,
                                               Fence const *            pFences,
                                               Bool32                   waitAll,
                                               uint64_t                 timeout,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWaitForFences, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForFences.html
    VULKAN_HPP_NODISCARD Result waitForFences( ArrayProxy<Fence const> const & fences,
                                               Bool32                          waitAll,
                                               uint64_t                        timeout,
                                               DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateSemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSemaphore.html
    VULKAN_HPP_NODISCARD Result createSemaphore( SemaphoreCreateInfo const * pCreateInfo,
                                                 AllocationCallbacks const * pAllocator,
                                                 Semaphore *                 pSemaphore,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSemaphore.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Semaphore>::type
      createSemaphore( SemaphoreCreateInfo const &                   createInfo,
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSemaphore.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Semaphore>>::type
      createSemaphoreUnique( SemaphoreCreateInfo const &                   createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySemaphore.html
    void destroySemaphore( Semaphore                   semaphore,
                           AllocationCallbacks const * pAllocator,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySemaphore.html
    void destroySemaphore( Semaphore semaphore                           VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySemaphore.html
    void destroy( Semaphore                   semaphore,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySemaphore.html
    void destroy( Semaphore                                     semaphore,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateQueryPool.html
    VULKAN_HPP_NODISCARD Result createQueryPool( QueryPoolCreateInfo const * pCreateInfo,
                                                 AllocationCallbacks const * pAllocator,
                                                 QueryPool *                 pQueryPool,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateQueryPool.html
    VULKAN_HPP_NODISCARD typename ResultValueType<QueryPool>::type
      createQueryPool( QueryPoolCreateInfo const &                   createInfo,
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateQueryPool.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<QueryPool>>::type
      createQueryPoolUnique( QueryPoolCreateInfo const &                   createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyQueryPool.html
    void destroyQueryPool( QueryPool                   queryPool,
                           AllocationCallbacks const * pAllocator,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyQueryPool.html
    void destroyQueryPool( QueryPool queryPool                           VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyQueryPool.html
    void destroy( QueryPool                   queryPool,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyQueryPool.html
    void destroy( QueryPool                                     queryPool,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetQueryPoolResults, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueryPoolResults.html
    VULKAN_HPP_NODISCARD Result getQueryPoolResults( QueryPool                queryPool,
                                                     uint32_t                 firstQuery,
                                                     uint32_t                 queryCount,
                                                     size_t                   dataSize,
                                                     void *                   pData,
                                                     DeviceSize               stride,
                                                     QueryResultFlags         flags,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetQueryPoolResults, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueryPoolResults.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<DataType, DataTypeAllocator>>
                         getQueryPoolResults( QueryPool                queryPool,
                                              uint32_t                 firstQuery,
                                              uint32_t                 queryCount,
                                              size_t                   dataSize,
                                              DeviceSize               stride,
                                              QueryResultFlags flags   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetQueryPoolResults, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetQueryPoolResults.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD ResultValue<DataType> getQueryPoolResult( QueryPool                queryPool,
                                                                   uint32_t                 firstQuery,
                                                                   uint32_t                 queryCount,
                                                                   DeviceSize               stride,
                                                                   QueryResultFlags flags   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBuffer.html
    VULKAN_HPP_NODISCARD Result createBuffer( BufferCreateInfo const *    pCreateInfo,
                                              AllocationCallbacks const * pAllocator,
                                              Buffer *                    pBuffer,
                                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBuffer.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Buffer>::type
      createBuffer( BufferCreateInfo const &                      createInfo,
                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBuffer.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Buffer>>::type
      createBufferUnique( BufferCreateInfo const &                      createInfo,
                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBuffer.html
    void destroyBuffer( Buffer                      buffer,
                        AllocationCallbacks const * pAllocator,
                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBuffer.html
    void destroyBuffer( Buffer buffer                                 VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBuffer.html
    void destroy( Buffer                      buffer,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyBuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBuffer.html
    void destroy( Buffer                                        buffer,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImage.html
    VULKAN_HPP_NODISCARD Result createImage( ImageCreateInfo const *     pCreateInfo,
                                             AllocationCallbacks const * pAllocator,
                                             Image *                     pImage,
                                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImage.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Image>::type
      createImage( ImageCreateInfo const &                       createInfo,
                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImage.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Image>>::type
      createImageUnique( ImageCreateInfo const &                       createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImage.html
    void destroyImage( Image                       image,
                       AllocationCallbacks const * pAllocator,
                       DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImage.html
    void destroyImage( Image image                                   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImage.html
    void destroy( Image                       image,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImage.html
    void destroy( Image                                         image,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSubresourceLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout.html
    void getImageSubresourceLayout( Image                    image,
                                    ImageSubresource const * pSubresource,
                                    SubresourceLayout *      pLayout,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSubresourceLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout.html
    VULKAN_HPP_NODISCARD SubresourceLayout getImageSubresourceLayout(
      Image image, ImageSubresource const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImageView.html
    VULKAN_HPP_NODISCARD Result createImageView( ImageViewCreateInfo const * pCreateInfo,
                                                 AllocationCallbacks const * pAllocator,
                                                 ImageView *                 pView,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImageView.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ImageView>::type
      createImageView( ImageViewCreateInfo const &                   createInfo,
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImageView.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<ImageView>>::type
      createImageViewUnique( ImageViewCreateInfo const &                   createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImageView.html
    void destroyImageView( ImageView                   imageView,
                           AllocationCallbacks const * pAllocator,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImageView.html
    void destroyImageView( ImageView imageView                           VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImageView.html
    void destroy( ImageView                   imageView,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyImageView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyImageView.html
    void destroy( ImageView                                     imageView,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html
    VULKAN_HPP_NODISCARD Result createCommandPool( CommandPoolCreateInfo const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   CommandPool *                 pCommandPool,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html
    VULKAN_HPP_NODISCARD typename ResultValueType<CommandPool>::type
      createCommandPool( CommandPoolCreateInfo const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCommandPool.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<CommandPool>>::type
      createCommandPoolUnique( CommandPoolCreateInfo const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCommandPool.html
    void destroyCommandPool( CommandPool                 commandPool,
                             AllocationCallbacks const * pAllocator,
                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCommandPool.html
    void destroyCommandPool( CommandPool commandPool                       VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCommandPool.html
    void destroy( CommandPool                 commandPool,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCommandPool.html
    void destroy( CommandPool                                   commandPool,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkResetCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandPool.html
    VULKAN_HPP_NODISCARD Result resetCommandPool( CommandPool              commandPool,
                                                  CommandPoolResetFlags    flags,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkResetCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetCommandPool.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      resetCommandPool( CommandPool                 commandPool,
                        CommandPoolResetFlags flags VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkAllocateCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html
    VULKAN_HPP_NODISCARD Result allocateCommandBuffers( CommandBufferAllocateInfo const * pAllocateInfo,
                                                        CommandBuffer *                   pCommandBuffers,
                                                        DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAllocateCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html
    template <typename CommandBufferAllocator = std::allocator<CommandBuffer>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CommandBuffer, CommandBufferAllocator>>::type
      allocateCommandBuffers( CommandBufferAllocateInfo const & allocateInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkAllocateCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html
    template <typename CommandBufferAllocator = std::allocator<CommandBuffer>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CommandBuffer, CommandBufferAllocator>>::type
      allocateCommandBuffers( CommandBufferAllocateInfo const & allocateInfo,
                              CommandBufferAllocator const &    commandBufferAllocator,
                              DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkAllocateCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html
    template <typename CommandBufferAllocator = std::allocator<UniqueHandle<CommandBuffer>>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<UniqueHandle<CommandBuffer>, CommandBufferAllocator>>::type
      allocateCommandBuffersUnique( CommandBufferAllocateInfo const & allocateInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkAllocateCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateCommandBuffers.html
    template <typename CommandBufferAllocator = std::allocator<UniqueHandle<CommandBuffer>>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<UniqueHandle<CommandBuffer>, CommandBufferAllocator>>::type
      allocateCommandBuffersUnique( CommandBufferAllocateInfo const & allocateInfo,
                                    CommandBufferAllocator const &    commandBufferAllocator,
                                    DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkFreeCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html
    void freeCommandBuffers( CommandPool              commandPool,
                             uint32_t                 commandBufferCount,
                             CommandBuffer const *    pCommandBuffers,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFreeCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html
    void freeCommandBuffers( CommandPool                             commandPool,
                             ArrayProxy<CommandBuffer const> const & commandBuffers,
                             DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkFreeCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html
    void( free )( CommandPool              commandPool,
                  uint32_t                 commandBufferCount,
                  CommandBuffer const *    pCommandBuffers,
                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFreeCommandBuffers, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeCommandBuffers.html
    void( free )( CommandPool                             commandPool,
                  ArrayProxy<CommandBuffer const> const & commandBuffers,
                  DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateEvent.html
    VULKAN_HPP_NODISCARD Result createEvent( EventCreateInfo const *     pCreateInfo,
                                             AllocationCallbacks const * pAllocator,
                                             Event *                     pEvent,
                                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateEvent.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Event>::type
      createEvent( EventCreateInfo const &                       createInfo,
                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateEvent.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Event>>::type
      createEventUnique( EventCreateInfo const &                       createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyEvent.html
    void destroyEvent( Event                       event,
                       AllocationCallbacks const * pAllocator,
                       DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyEvent.html
    void destroyEvent( Event event                                   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyEvent.html
    void destroy( Event                       event,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyEvent.html
    void destroy( Event                                         event,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetEventStatus, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEventStatus.html
    VULKAN_HPP_NODISCARD Result getEventStatus( Event event, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkGetEventStatus, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEventStatus.html
    VULKAN_HPP_NODISCARD Result getEventStatus( Event event, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetEvent.html
    VULKAN_HPP_NODISCARD Result setEvent( Event event, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkSetEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetEvent.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setEvent( Event event, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkResetEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetEvent.html
    VULKAN_HPP_NODISCARD Result resetEvent( Event event, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkResetEvent, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetEvent.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      resetEvent( Event event, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkCreateBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferView.html
    VULKAN_HPP_NODISCARD Result createBufferView( BufferViewCreateInfo const * pCreateInfo,
                                                  AllocationCallbacks const *  pAllocator,
                                                  BufferView *                 pView,
                                                  DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferView.html
    VULKAN_HPP_NODISCARD typename ResultValueType<BufferView>::type
      createBufferView( BufferViewCreateInfo const &                  createInfo,
                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferView.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<BufferView>>::type
      createBufferViewUnique( BufferViewCreateInfo const &                  createInfo,
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferView.html
    void destroyBufferView( BufferView                  bufferView,
                            AllocationCallbacks const * pAllocator,
                            DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferView.html
    void destroyBufferView( BufferView bufferView                         VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferView.html
    void destroy( BufferView                  bufferView,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyBufferView, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferView.html
    void destroy( BufferView                                    bufferView,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShaderModule.html
    VULKAN_HPP_NODISCARD Result createShaderModule( ShaderModuleCreateInfo const * pCreateInfo,
                                                    AllocationCallbacks const *    pAllocator,
                                                    ShaderModule *                 pShaderModule,
                                                    DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShaderModule.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ShaderModule>::type
      createShaderModule( ShaderModuleCreateInfo const &                createInfo,
                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShaderModule.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<ShaderModule>>::type
      createShaderModuleUnique( ShaderModuleCreateInfo const &                createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderModule.html
    void destroyShaderModule( ShaderModule                shaderModule,
                              AllocationCallbacks const * pAllocator,
                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderModule.html
    void destroyShaderModule( ShaderModule shaderModule                     VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderModule.html
    void destroy( ShaderModule                shaderModule,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyShaderModule, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderModule.html
    void destroy( ShaderModule                                  shaderModule,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreatePipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineCache.html
    VULKAN_HPP_NODISCARD Result createPipelineCache( PipelineCacheCreateInfo const * pCreateInfo,
                                                     AllocationCallbacks const *     pAllocator,
                                                     PipelineCache *                 pPipelineCache,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreatePipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineCache.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PipelineCache>::type
      createPipelineCache( PipelineCacheCreateInfo const &               createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreatePipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineCache.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<PipelineCache>>::type
      createPipelineCacheUnique( PipelineCacheCreateInfo const &               createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineCache.html
    void destroyPipelineCache( PipelineCache               pipelineCache,
                               AllocationCallbacks const * pAllocator,
                               DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineCache.html
    void destroyPipelineCache( PipelineCache pipelineCache                   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineCache.html
    void destroy( PipelineCache               pipelineCache,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipelineCache, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineCache.html
    void destroy( PipelineCache                                 pipelineCache,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPipelineCacheData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineCacheData.html
    VULKAN_HPP_NODISCARD Result getPipelineCacheData( PipelineCache            pipelineCache,
                                                      size_t *                 pDataSize,
                                                      void *                   pData,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineCacheData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineCacheData.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type
      getPipelineCacheData( PipelineCache pipelineCache, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPipelineCacheData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineCacheData.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type getPipelineCacheData(
      PipelineCache pipelineCache, Uint8_tAllocator const & uint8_tAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkMergePipelineCaches, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergePipelineCaches.html
    VULKAN_HPP_NODISCARD Result mergePipelineCaches( PipelineCache            dstCache,
                                                     uint32_t                 srcCacheCount,
                                                     PipelineCache const *    pSrcCaches,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkMergePipelineCaches, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergePipelineCaches.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type mergePipelineCaches(
      PipelineCache dstCache, ArrayProxy<PipelineCache const> const & srcCaches, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    VULKAN_HPP_NODISCARD Result createComputePipelines( PipelineCache                     pipelineCache,
                                                        uint32_t                          createInfoCount,
                                                        ComputePipelineCreateInfo const * pCreateInfos,
                                                        AllocationCallbacks const *       pAllocator,
                                                        Pipeline *                        pPipelines,
                                                        DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createComputePipelines( PipelineCache                                       pipelineCache,
                                                 ArrayProxy<ComputePipelineCreateInfo const> const & createInfos,
                                                 Optional<AllocationCallbacks const> allocator       VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                 DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createComputePipelines( PipelineCache                                       pipelineCache,
                                                 ArrayProxy<ComputePipelineCreateInfo const> const & createInfos,
                                                 Optional<AllocationCallbacks const>                 allocator,
                                                 PipelineAllocator const &                           pipelineAllocator,
                                                 DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    VULKAN_HPP_NODISCARD ResultValue<Pipeline> createComputePipeline( PipelineCache                                 pipelineCache,
                                                                      ComputePipelineCreateInfo const &             createInfo,
                                                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createComputePipelinesUnique( PipelineCache                                       pipelineCache,
                                                       ArrayProxy<ComputePipelineCreateInfo const> const & createInfos,
                                                       Optional<AllocationCallbacks const> allocator       VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                       DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createComputePipelinesUnique( PipelineCache                                       pipelineCache,
                                                       ArrayProxy<ComputePipelineCreateInfo const> const & createInfos,
                                                       Optional<AllocationCallbacks const>                 allocator,
                                                       PipelineAllocator const &                           pipelineAllocator,
                                                       DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateComputePipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateComputePipelines.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<Pipeline>>
                         createComputePipelineUnique( PipelineCache                                 pipelineCache,
                                                      ComputePipelineCreateInfo const &             createInfo,
                                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipeline, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipeline.html
    void destroyPipeline( Pipeline                    pipeline,
                          AllocationCallbacks const * pAllocator,
                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipeline, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipeline.html
    void destroyPipeline( Pipeline pipeline                             VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipeline, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipeline.html
    void destroy( Pipeline                    pipeline,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipeline, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipeline.html
    void destroy( Pipeline                                      pipeline,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreatePipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html
    VULKAN_HPP_NODISCARD Result createPipelineLayout( PipelineLayoutCreateInfo const * pCreateInfo,
                                                      AllocationCallbacks const *      pAllocator,
                                                      PipelineLayout *                 pPipelineLayout,
                                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreatePipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PipelineLayout>::type
      createPipelineLayout( PipelineLayoutCreateInfo const &              createInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreatePipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineLayout.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<PipelineLayout>>::type
      createPipelineLayoutUnique( PipelineLayoutCreateInfo const &              createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineLayout.html
    void destroyPipelineLayout( PipelineLayout              pipelineLayout,
                                AllocationCallbacks const * pAllocator,
                                DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineLayout.html
    void destroyPipelineLayout( PipelineLayout pipelineLayout                 VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineLayout.html
    void destroy( PipelineLayout              pipelineLayout,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipelineLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineLayout.html
    void destroy( PipelineLayout                                pipelineLayout,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateSampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html
    VULKAN_HPP_NODISCARD Result createSampler( SamplerCreateInfo const *   pCreateInfo,
                                               AllocationCallbacks const * pAllocator,
                                               Sampler *                   pSampler,
                                               DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Sampler>::type
      createSampler( SamplerCreateInfo const &                     createInfo,
                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSampler.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Sampler>>::type
      createSamplerUnique( SamplerCreateInfo const &                     createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySampler.html
    void destroySampler( Sampler                     sampler,
                         AllocationCallbacks const * pAllocator,
                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySampler.html
    void destroySampler( Sampler sampler                               VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySampler.html
    void destroy( Sampler                     sampler,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySampler, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySampler.html
    void destroy( Sampler                                       sampler,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateDescriptorSetLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html
    VULKAN_HPP_NODISCARD Result createDescriptorSetLayout( DescriptorSetLayoutCreateInfo const * pCreateInfo,
                                                           AllocationCallbacks const *           pAllocator,
                                                           DescriptorSetLayout *                 pSetLayout,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDescriptorSetLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DescriptorSetLayout>::type
      createDescriptorSetLayout( DescriptorSetLayoutCreateInfo const &         createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDescriptorSetLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorSetLayout.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DescriptorSetLayout>>::type
      createDescriptorSetLayoutUnique( DescriptorSetLayoutCreateInfo const &         createInfo,
                                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorSetLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorSetLayout.html
    void destroyDescriptorSetLayout( DescriptorSetLayout         descriptorSetLayout,
                                     AllocationCallbacks const * pAllocator,
                                     DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorSetLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorSetLayout.html
    void destroyDescriptorSetLayout( DescriptorSetLayout descriptorSetLayout       VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorSetLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorSetLayout.html
    void destroy( DescriptorSetLayout         descriptorSetLayout,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorSetLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorSetLayout.html
    void destroy( DescriptorSetLayout                           descriptorSetLayout,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorPool.html
    VULKAN_HPP_NODISCARD Result createDescriptorPool( DescriptorPoolCreateInfo const * pCreateInfo,
                                                      AllocationCallbacks const *      pAllocator,
                                                      DescriptorPool *                 pDescriptorPool,
                                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorPool.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DescriptorPool>::type
      createDescriptorPool( DescriptorPoolCreateInfo const &              createInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorPool.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DescriptorPool>>::type
      createDescriptorPoolUnique( DescriptorPoolCreateInfo const &              createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorPool.html
    void destroyDescriptorPool( DescriptorPool              descriptorPool,
                                AllocationCallbacks const * pAllocator,
                                DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorPool.html
    void destroyDescriptorPool( DescriptorPool descriptorPool                 VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorPool.html
    void destroy( DescriptorPool              descriptorPool,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorPool.html
    void destroy( DescriptorPool                                descriptorPool,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkResetDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetDescriptorPool.html
    VULKAN_HPP_NODISCARD Result resetDescriptorPool( DescriptorPool           descriptorPool,
                                                     DescriptorPoolResetFlags flags,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkResetDescriptorPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetDescriptorPool.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      resetDescriptorPool( DescriptorPool                 descriptorPool,
                           DescriptorPoolResetFlags flags VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                           DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkAllocateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html
    VULKAN_HPP_NODISCARD Result allocateDescriptorSets( DescriptorSetAllocateInfo const * pAllocateInfo,
                                                        DescriptorSet *                   pDescriptorSets,
                                                        DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAllocateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html
    template <typename DescriptorSetAllocator = std::allocator<DescriptorSet>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DescriptorSet, DescriptorSetAllocator>>::type
      allocateDescriptorSets( DescriptorSetAllocateInfo const & allocateInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkAllocateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html
    template <typename DescriptorSetAllocator = std::allocator<DescriptorSet>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DescriptorSet, DescriptorSetAllocator>>::type
      allocateDescriptorSets( DescriptorSetAllocateInfo const & allocateInfo,
                              DescriptorSetAllocator const &    descriptorSetAllocator,
                              DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkAllocateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html
    template <typename DescriptorSetAllocator = std::allocator<UniqueHandle<DescriptorSet>>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<UniqueHandle<DescriptorSet>, DescriptorSetAllocator>>::type
      allocateDescriptorSetsUnique( DescriptorSetAllocateInfo const & allocateInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkAllocateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAllocateDescriptorSets.html
    template <typename DescriptorSetAllocator = std::allocator<UniqueHandle<DescriptorSet>>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<UniqueHandle<DescriptorSet>, DescriptorSetAllocator>>::type
      allocateDescriptorSetsUnique( DescriptorSetAllocateInfo const & allocateInfo,
                                    DescriptorSetAllocator const &    descriptorSetAllocator,
                                    DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkFreeDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeDescriptorSets.html
    VULKAN_HPP_NODISCARD Result freeDescriptorSets( DescriptorPool           descriptorPool,
                                                    uint32_t                 descriptorSetCount,
                                                    DescriptorSet const *    pDescriptorSets,
                                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFreeDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeDescriptorSets.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      freeDescriptorSets( DescriptorPool                          descriptorPool,
                          ArrayProxy<DescriptorSet const> const & descriptorSets,
                          DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkFreeDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeDescriptorSets.html
    VULKAN_HPP_NODISCARD Result( free )( DescriptorPool           descriptorPool,
                                         uint32_t                 descriptorSetCount,
                                         DescriptorSet const *    pDescriptorSets,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkFreeDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkFreeDescriptorSets.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS
      typename ResultValueType<void>::type( free )( DescriptorPool                          descriptorPool,
                                                    ArrayProxy<DescriptorSet const> const & descriptorSets,
                                                    DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUpdateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html
    void updateDescriptorSets( uint32_t                   descriptorWriteCount,
                               WriteDescriptorSet const * pDescriptorWrites,
                               uint32_t                   descriptorCopyCount,
                               CopyDescriptorSet const *  pDescriptorCopies,
                               DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUpdateDescriptorSets, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSets.html
    void updateDescriptorSets( ArrayProxy<WriteDescriptorSet const> const & descriptorWrites,
                               ArrayProxy<CopyDescriptorSet const> const &  descriptorCopies,
                               DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    VULKAN_HPP_NODISCARD Result createGraphicsPipelines( PipelineCache                      pipelineCache,
                                                         uint32_t                           createInfoCount,
                                                         GraphicsPipelineCreateInfo const * pCreateInfos,
                                                         AllocationCallbacks const *        pAllocator,
                                                         Pipeline *                         pPipelines,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createGraphicsPipelines( PipelineCache                                        pipelineCache,
                                                  ArrayProxy<GraphicsPipelineCreateInfo const> const & createInfos,
                                                  Optional<AllocationCallbacks const> allocator        VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                  DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createGraphicsPipelines( PipelineCache                                        pipelineCache,
                                                  ArrayProxy<GraphicsPipelineCreateInfo const> const & createInfos,
                                                  Optional<AllocationCallbacks const>                  allocator,
                                                  PipelineAllocator const &                            pipelineAllocator,
                                                  DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    VULKAN_HPP_NODISCARD ResultValue<Pipeline> createGraphicsPipeline( PipelineCache                                 pipelineCache,
                                                                       GraphicsPipelineCreateInfo const &            createInfo,
                                                                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createGraphicsPipelinesUnique( PipelineCache                                        pipelineCache,
                                                        ArrayProxy<GraphicsPipelineCreateInfo const> const & createInfos,
                                                        Optional<AllocationCallbacks const> allocator        VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                        DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createGraphicsPipelinesUnique( PipelineCache                                        pipelineCache,
                                                        ArrayProxy<GraphicsPipelineCreateInfo const> const & createInfos,
                                                        Optional<AllocationCallbacks const>                  allocator,
                                                        PipelineAllocator const &                            pipelineAllocator,
                                                        DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateGraphicsPipelines, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateGraphicsPipelines.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<Pipeline>>
                         createGraphicsPipelineUnique( PipelineCache                                 pipelineCache,
                                                       GraphicsPipelineCreateInfo const &            createInfo,
                                                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFramebuffer.html
    VULKAN_HPP_NODISCARD Result createFramebuffer( FramebufferCreateInfo const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   Framebuffer *                 pFramebuffer,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFramebuffer.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Framebuffer>::type
      createFramebuffer( FramebufferCreateInfo const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateFramebuffer.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Framebuffer>>::type
      createFramebufferUnique( FramebufferCreateInfo const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFramebuffer.html
    void destroyFramebuffer( Framebuffer                 framebuffer,
                             AllocationCallbacks const * pAllocator,
                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFramebuffer.html
    void destroyFramebuffer( Framebuffer framebuffer                       VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFramebuffer.html
    void destroy( Framebuffer                 framebuffer,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyFramebuffer, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyFramebuffer.html
    void destroy( Framebuffer                                   framebuffer,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass.html
    VULKAN_HPP_NODISCARD Result createRenderPass( RenderPassCreateInfo const * pCreateInfo,
                                                  AllocationCallbacks const *  pAllocator,
                                                  RenderPass *                 pRenderPass,
                                                  DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass.html
    VULKAN_HPP_NODISCARD typename ResultValueType<RenderPass>::type
      createRenderPass( RenderPassCreateInfo const &                  createInfo,
                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<RenderPass>>::type
      createRenderPassUnique( RenderPassCreateInfo const &                  createInfo,
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyRenderPass.html
    void destroyRenderPass( RenderPass                  renderPass,
                            AllocationCallbacks const * pAllocator,
                            DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyRenderPass.html
    void destroyRenderPass( RenderPass renderPass                         VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyRenderPass.html
    void destroy( RenderPass                  renderPass,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyRenderPass, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyRenderPass.html
    void destroy( RenderPass                                    renderPass,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRenderAreaGranularity, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderAreaGranularity.html
    void getRenderAreaGranularity( RenderPass               renderPass,
                                   Extent2D *               pGranularity,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRenderAreaGranularity, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderAreaGranularity.html
    VULKAN_HPP_NODISCARD Extent2D getRenderAreaGranularity( RenderPass               renderPass,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_1 ===

    // wrapper function for command vkBindBufferMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2.html
    VULKAN_HPP_NODISCARD Result bindBufferMemory2( uint32_t                     bindInfoCount,
                                                   BindBufferMemoryInfo const * pBindInfos,
                                                   DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindBufferMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindBufferMemory2( ArrayProxy<BindBufferMemoryInfo const> const & bindInfos, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBindImageMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2.html
    VULKAN_HPP_NODISCARD Result bindImageMemory2( uint32_t                    bindInfoCount,
                                                  BindImageMemoryInfo const * pBindInfos,
                                                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindImageMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindImageMemory2( ArrayProxy<BindImageMemoryInfo const> const & bindInfos, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceGroupPeerMemoryFeatures, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
    void getGroupPeerMemoryFeatures( uint32_t                 heapIndex,
                                     uint32_t                 localDeviceIndex,
                                     uint32_t                 remoteDeviceIndex,
                                     PeerMemoryFeatureFlags * pPeerMemoryFeatures,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceGroupPeerMemoryFeatures, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
    VULKAN_HPP_NODISCARD PeerMemoryFeatureFlags
      getGroupPeerMemoryFeatures( uint32_t                 heapIndex,
                                  uint32_t                 localDeviceIndex,
                                  uint32_t                 remoteDeviceIndex,
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2.html
    void getImageMemoryRequirements2( ImageMemoryRequirementsInfo2 const * pInfo,
                                      MemoryRequirements2 *                pMemoryRequirements,
                                      DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getImageMemoryRequirements2(
      ImageMemoryRequirementsInfo2 const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetImageMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getImageMemoryRequirements2( ImageMemoryRequirementsInfo2 const & info,
                                                      DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2.html
    void getBufferMemoryRequirements2( BufferMemoryRequirementsInfo2 const * pInfo,
                                       MemoryRequirements2 *                 pMemoryRequirements,
                                       DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getBufferMemoryRequirements2(
      BufferMemoryRequirementsInfo2 const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetBufferMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getBufferMemoryRequirements2( BufferMemoryRequirementsInfo2 const & info,
                                                       DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSparseMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2.html
    void getImageSparseMemoryRequirements2( ImageSparseMemoryRequirementsInfo2 const * pInfo,
                                            uint32_t *                                 pSparseMemoryRequirementCount,
                                            SparseImageMemoryRequirements2 *           pSparseMemoryRequirements,
                                            DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSparseMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirements2( ImageSparseMemoryRequirementsInfo2 const & info,
                                                            DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetImageSparseMemoryRequirements2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirements2( ImageSparseMemoryRequirementsInfo2 const &      info,
                                                            SparseImageMemoryRequirements2Allocator const & sparseImageMemoryRequirements2Allocator,
                                                            DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkTrimCommandPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkTrimCommandPool.html
    void trimCommandPool( CommandPool              commandPool,
                          CommandPoolTrimFlags     flags,
                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkGetDeviceQueue2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue2.html
    void getQueue2( DeviceQueueInfo2 const * pQueueInfo,
                    Queue *                  pQueue,
                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceQueue2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceQueue2.html
    VULKAN_HPP_NODISCARD Queue getQueue2( DeviceQueueInfo2 const & queueInfo,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplate.html
    VULKAN_HPP_NODISCARD Result createDescriptorUpdateTemplate( DescriptorUpdateTemplateCreateInfo const * pCreateInfo,
                                                                AllocationCallbacks const *                pAllocator,
                                                                DescriptorUpdateTemplate *                 pDescriptorUpdateTemplate,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplate.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DescriptorUpdateTemplate>::type
      createDescriptorUpdateTemplate( DescriptorUpdateTemplateCreateInfo const &    createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplate.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DescriptorUpdateTemplate>>::type
      createDescriptorUpdateTemplateUnique( DescriptorUpdateTemplateCreateInfo const &    createInfo,
                                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplate.html
    void destroyDescriptorUpdateTemplate( DescriptorUpdateTemplate    descriptorUpdateTemplate,
                                          AllocationCallbacks const * pAllocator,
                                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplate.html
    void destroyDescriptorUpdateTemplate( DescriptorUpdateTemplate descriptorUpdateTemplate VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                          Optional<AllocationCallbacks const> allocator     VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplate.html
    void destroy( DescriptorUpdateTemplate    descriptorUpdateTemplate,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorUpdateTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplate.html
    void destroy( DescriptorUpdateTemplate                      descriptorUpdateTemplate,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUpdateDescriptorSetWithTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplate.html
    void updateDescriptorSetWithTemplate( DescriptorSet            descriptorSet,
                                          DescriptorUpdateTemplate descriptorUpdateTemplate,
                                          void const *             pData,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUpdateDescriptorSetWithTemplate, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplate.html
    template <typename DataType>
    void updateDescriptorSetWithTemplate( DescriptorSet            descriptorSet,
                                          DescriptorUpdateTemplate descriptorUpdateTemplate,
                                          DataType const &         data,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDescriptorSetLayoutSupport, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupport.html
    void getDescriptorSetLayoutSupport( DescriptorSetLayoutCreateInfo const * pCreateInfo,
                                        DescriptorSetLayoutSupport *          pSupport,
                                        DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorSetLayoutSupport, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupport.html
    VULKAN_HPP_NODISCARD DescriptorSetLayoutSupport getDescriptorSetLayoutSupport(
      DescriptorSetLayoutCreateInfo const & createInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDescriptorSetLayoutSupport, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupport.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getDescriptorSetLayoutSupport( DescriptorSetLayoutCreateInfo const & createInfo,
                                                        DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateSamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversion.html
    VULKAN_HPP_NODISCARD Result createSamplerYcbcrConversion( SamplerYcbcrConversionCreateInfo const * pCreateInfo,
                                                              AllocationCallbacks const *              pAllocator,
                                                              SamplerYcbcrConversion *                 pYcbcrConversion,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversion.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SamplerYcbcrConversion>::type
      createSamplerYcbcrConversion( SamplerYcbcrConversionCreateInfo const &      createInfo,
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversion.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SamplerYcbcrConversion>>::type
      createSamplerYcbcrConversionUnique( SamplerYcbcrConversionCreateInfo const &      createInfo,
                                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversion.html
    void destroySamplerYcbcrConversion( SamplerYcbcrConversion      ycbcrConversion,
                                        AllocationCallbacks const * pAllocator,
                                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversion.html
    void destroySamplerYcbcrConversion( SamplerYcbcrConversion ycbcrConversion        VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversion.html
    void destroy( SamplerYcbcrConversion      ycbcrConversion,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySamplerYcbcrConversion, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversion.html
    void destroy( SamplerYcbcrConversion                        ycbcrConversion,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_2 ===

    // wrapper function for command vkResetQueryPool, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetQueryPool.html
    void resetQueryPool( QueryPool                queryPool,
                         uint32_t                 firstQuery,
                         uint32_t                 queryCount,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkGetSemaphoreCounterValue, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValue.html
    VULKAN_HPP_NODISCARD Result getSemaphoreCounterValue( Semaphore                semaphore,
                                                          uint64_t *               pValue,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSemaphoreCounterValue, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValue.html
    VULKAN_HPP_NODISCARD typename ResultValueType<uint64_t>::type
      getSemaphoreCounterValue( Semaphore semaphore, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkWaitSemaphores, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphores.html
    VULKAN_HPP_NODISCARD Result waitSemaphores( SemaphoreWaitInfo const * pWaitInfo,
                                                uint64_t                  timeout,
                                                DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWaitSemaphores, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphores.html
    VULKAN_HPP_NODISCARD Result waitSemaphores( SemaphoreWaitInfo const & waitInfo,
                                                uint64_t                  timeout,
                                                DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSignalSemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphore.html
    VULKAN_HPP_NODISCARD Result signalSemaphore( SemaphoreSignalInfo const * pSignalInfo,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSignalSemaphore, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphore.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      signalSemaphore( SemaphoreSignalInfo const & signalInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferDeviceAddress, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddress.html
    DeviceAddress getBufferAddress( BufferDeviceAddressInfo const * pInfo,
                                    DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferDeviceAddress, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddress.html
    DeviceAddress getBufferAddress( BufferDeviceAddressInfo const & info,
                                    DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferOpaqueCaptureAddress, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddress.html
    uint64_t getBufferOpaqueCaptureAddress( BufferDeviceAddressInfo const * pInfo,
                                            DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferOpaqueCaptureAddress, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddress.html
    uint64_t getBufferOpaqueCaptureAddress( BufferDeviceAddressInfo const & info,
                                            DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceMemoryOpaqueCaptureAddress, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
    uint64_t getMemoryOpaqueCaptureAddress( DeviceMemoryOpaqueCaptureAddressInfo const * pInfo,
                                            DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceMemoryOpaqueCaptureAddress, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
    uint64_t getMemoryOpaqueCaptureAddress( DeviceMemoryOpaqueCaptureAddressInfo const & info,
                                            DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2.html
    VULKAN_HPP_NODISCARD Result createRenderPass2( RenderPassCreateInfo2 const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   RenderPass *                  pRenderPass,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2.html
    VULKAN_HPP_NODISCARD typename ResultValueType<RenderPass>::type
      createRenderPass2( RenderPassCreateInfo2 const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateRenderPass2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<RenderPass>>::type
      createRenderPass2Unique( RenderPassCreateInfo2 const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_3 ===

    // wrapper function for command vkCreatePrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlot.html
    VULKAN_HPP_NODISCARD Result createPrivateDataSlot( PrivateDataSlotCreateInfo const * pCreateInfo,
                                                       AllocationCallbacks const *       pAllocator,
                                                       PrivateDataSlot *                 pPrivateDataSlot,
                                                       DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreatePrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlot.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PrivateDataSlot>::type
      createPrivateDataSlot( PrivateDataSlotCreateInfo const &             createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreatePrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlot.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<PrivateDataSlot>>::type
      createPrivateDataSlotUnique( PrivateDataSlotCreateInfo const &             createInfo,
                                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlot.html
    void destroyPrivateDataSlot( PrivateDataSlot             privateDataSlot,
                                 AllocationCallbacks const * pAllocator,
                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlot.html
    void destroyPrivateDataSlot( PrivateDataSlot privateDataSlot               VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlot.html
    void destroy( PrivateDataSlot             privateDataSlot,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPrivateDataSlot, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlot.html
    void destroy( PrivateDataSlot                               privateDataSlot,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetPrivateData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateData.html
    VULKAN_HPP_NODISCARD Result setPrivateData( ObjectType               objectType,
                                                uint64_t                 objectHandle,
                                                PrivateDataSlot          privateDataSlot,
                                                uint64_t                 data,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkSetPrivateData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateData.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setPrivateData( ObjectType               objectType,
                      uint64_t                 objectHandle,
                      PrivateDataSlot          privateDataSlot,
                      uint64_t                 data,
                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetPrivateData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateData.html
    void getPrivateData( ObjectType               objectType,
                         uint64_t                 objectHandle,
                         PrivateDataSlot          privateDataSlot,
                         uint64_t *               pData,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPrivateData, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateData.html
    VULKAN_HPP_NODISCARD uint64_t getPrivateData( ObjectType               objectType,
                                                  uint64_t                 objectHandle,
                                                  PrivateDataSlot          privateDataSlot,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceBufferMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirements.html
    void getBufferMemoryRequirements( DeviceBufferMemoryRequirements const * pInfo,
                                      MemoryRequirements2 *                  pMemoryRequirements,
                                      DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceBufferMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirements.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getBufferMemoryRequirements(
      DeviceBufferMemoryRequirements const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceBufferMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirements.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getBufferMemoryRequirements( DeviceBufferMemoryRequirements const & info,
                                                      DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceImageMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirements.html
    void getImageMemoryRequirements( DeviceImageMemoryRequirements const * pInfo,
                                     MemoryRequirements2 *                 pMemoryRequirements,
                                     DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceImageMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirements.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getImageMemoryRequirements(
      DeviceImageMemoryRequirements const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceImageMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirements.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getImageMemoryRequirements( DeviceImageMemoryRequirements const & info,
                                                     DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceImageSparseMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirements.html
    void getImageSparseMemoryRequirements( DeviceImageMemoryRequirements const * pInfo,
                                           uint32_t *                            pSparseMemoryRequirementCount,
                                           SparseImageMemoryRequirements2 *      pSparseMemoryRequirements,
                                           DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceImageSparseMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirements.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
      getImageSparseMemoryRequirements( DeviceImageMemoryRequirements const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDeviceImageSparseMemoryRequirements, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirements.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirements( DeviceImageMemoryRequirements const &           info,
                                                           SparseImageMemoryRequirements2Allocator const & sparseImageMemoryRequirements2Allocator,
                                                           DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_4 ===

    // wrapper function for command vkMapMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2.html
    VULKAN_HPP_NODISCARD Result mapMemory2( MemoryMapInfo const *    pMemoryMapInfo,
                                            void **                  ppData,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkMapMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2.html
    VULKAN_HPP_NODISCARD typename ResultValueType<void *>::type mapMemory2( MemoryMapInfo const &    memoryMapInfo,
                                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUnmapMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2.html
    VULKAN_HPP_NODISCARD Result unmapMemory2( MemoryUnmapInfo const *  pMemoryUnmapInfo,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUnmapMemory2, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      unmapMemory2( MemoryUnmapInfo const & memoryUnmapInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceImageSubresourceLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayout.html
    void getImageSubresourceLayout( DeviceImageSubresourceInfo const * pInfo,
                                    SubresourceLayout2 *               pLayout,
                                    DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceImageSubresourceLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayout.html
    VULKAN_HPP_NODISCARD SubresourceLayout2 getImageSubresourceLayout(
      DeviceImageSubresourceInfo const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceImageSubresourceLayout, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayout.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getImageSubresourceLayout( DeviceImageSubresourceInfo const & info,
                                                    DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSubresourceLayout2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2.html
    void getImageSubresourceLayout2( Image                     image,
                                     ImageSubresource2 const * pSubresource,
                                     SubresourceLayout2 *      pLayout,
                                     DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSubresourceLayout2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2.html
    VULKAN_HPP_NODISCARD SubresourceLayout2 getImageSubresourceLayout2(
      Image image, ImageSubresource2 const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetImageSubresourceLayout2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...> getImageSubresourceLayout2(
      Image image, ImageSubresource2 const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyMemoryToImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html
    VULKAN_HPP_NODISCARD Result copyMemoryToImage( CopyMemoryToImageInfo const * pCopyMemoryToImageInfo,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyMemoryToImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImage.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      copyMemoryToImage( CopyMemoryToImageInfo const & copyMemoryToImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyImageToMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html
    VULKAN_HPP_NODISCARD Result copyImageToMemory( CopyImageToMemoryInfo const * pCopyImageToMemoryInfo,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyImageToMemory, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemory.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      copyImageToMemory( CopyImageToMemoryInfo const & copyImageToMemoryInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyImageToImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImage.html
    VULKAN_HPP_NODISCARD Result copyImageToImage( CopyImageToImageInfo const * pCopyImageToImageInfo,
                                                  DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyImageToImage, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImage.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      copyImageToImage( CopyImageToImageInfo const & copyImageToImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkTransitionImageLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayout.html
    VULKAN_HPP_NODISCARD Result transitionImageLayout( uint32_t                              transitionCount,
                                                       HostImageLayoutTransitionInfo const * pTransitions,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkTransitionImageLayout, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayout.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      transitionImageLayout( ArrayProxy<HostImageLayoutTransitionInfo const> const & transitions,
                             DispatchLoader const & d                                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRenderingAreaGranularity, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularity.html
    void getRenderingAreaGranularity( RenderingAreaInfo const * pRenderingAreaInfo,
                                      Extent2D *                pGranularity,
                                      DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRenderingAreaGranularity, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularity.html
    VULKAN_HPP_NODISCARD Extent2D getRenderingAreaGranularity( RenderingAreaInfo const & renderingAreaInfo,
                                                               DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_swapchain ===

    // wrapper function for command vkCreateSwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html
    VULKAN_HPP_NODISCARD Result createSwapchainKHR( SwapchainCreateInfoKHR const * pCreateInfo,
                                                    AllocationCallbacks const *    pAllocator,
                                                    SwapchainKHR *                 pSwapchain,
                                                    DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SwapchainKHR>::type
      createSwapchainKHR( SwapchainCreateInfoKHR const &                createInfo,
                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSwapchainKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SwapchainKHR>>::type
      createSwapchainKHRUnique( SwapchainCreateInfoKHR const &                createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySwapchainKHR.html
    void destroySwapchainKHR( SwapchainKHR                swapchain,
                              AllocationCallbacks const * pAllocator,
                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySwapchainKHR.html
    void destroySwapchainKHR( SwapchainKHR swapchain                        VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySwapchainKHR.html
    void destroy( SwapchainKHR                swapchain,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySwapchainKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySwapchainKHR.html
    void destroy( SwapchainKHR                                  swapchain,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSwapchainImagesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainImagesKHR.html
    VULKAN_HPP_NODISCARD Result getSwapchainImagesKHR( SwapchainKHR             swapchain,
                                                       uint32_t *               pSwapchainImageCount,
                                                       Image *                  pSwapchainImages,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSwapchainImagesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainImagesKHR.html
    template <typename ImageAllocator = std::allocator<Image>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<Image, ImageAllocator>>::type
      getSwapchainImagesKHR( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetSwapchainImagesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainImagesKHR.html
    template <typename ImageAllocator = std::allocator<Image>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<Image, ImageAllocator>>::type getSwapchainImagesKHR(
      SwapchainKHR swapchain, ImageAllocator const & imageAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkAcquireNextImageKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireNextImageKHR.html
    VULKAN_HPP_NODISCARD Result acquireNextImageKHR( SwapchainKHR             swapchain,
                                                     uint64_t                 timeout,
                                                     Semaphore                semaphore,
                                                     Fence                    fence,
                                                     uint32_t *               pImageIndex,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireNextImageKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireNextImageKHR.html
    VULKAN_HPP_NODISCARD ResultValue<uint32_t> acquireNextImageKHR( SwapchainKHR             swapchain,
                                                                    uint64_t                 timeout,
                                                                    Semaphore semaphore      VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                                                    Fence fence              VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceGroupPresentCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD Result getGroupPresentCapabilitiesKHR( DeviceGroupPresentCapabilitiesKHR * pDeviceGroupPresentCapabilities,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceGroupPresentCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DeviceGroupPresentCapabilitiesKHR>::type
      getGroupPresentCapabilitiesKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceGroupSurfacePresentModesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
    VULKAN_HPP_NODISCARD Result getGroupSurfacePresentModesKHR( SurfaceKHR                       surface,
                                                                DeviceGroupPresentModeFlagsKHR * pModes,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceGroupSurfacePresentModesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DeviceGroupPresentModeFlagsKHR>::type
      getGroupSurfacePresentModesKHR( SurfaceKHR surface, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkAcquireNextImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireNextImage2KHR.html
    VULKAN_HPP_NODISCARD Result acquireNextImage2KHR( AcquireNextImageInfoKHR const * pAcquireInfo,
                                                      uint32_t *                      pImageIndex,
                                                      DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireNextImage2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireNextImage2KHR.html
    VULKAN_HPP_NODISCARD ResultValue<uint32_t> acquireNextImage2KHR( AcquireNextImageInfoKHR const & acquireInfo,
                                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_display_swapchain ===

    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    VULKAN_HPP_NODISCARD Result createSharedSwapchainsKHR( uint32_t                       swapchainCount,
                                                           SwapchainCreateInfoKHR const * pCreateInfos,
                                                           AllocationCallbacks const *    pAllocator,
                                                           SwapchainKHR *                 pSwapchains,
                                                           DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    template <typename SwapchainKHRAllocator = std::allocator<SwapchainKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<SwapchainKHR, SwapchainKHRAllocator>>::type
      createSharedSwapchainsKHR( ArrayProxy<SwapchainCreateInfoKHR const> const & createInfos,
                                 Optional<AllocationCallbacks const> allocator    VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    template <typename SwapchainKHRAllocator = std::allocator<SwapchainKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<SwapchainKHR, SwapchainKHRAllocator>>::type
      createSharedSwapchainsKHR( ArrayProxy<SwapchainCreateInfoKHR const> const & createInfos,
                                 Optional<AllocationCallbacks const>              allocator,
                                 SwapchainKHRAllocator const &                    swapchainKHRAllocator,
                                 DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SwapchainKHR>::type
      createSharedSwapchainKHR( SwapchainCreateInfoKHR const &                createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    template <typename SwapchainKHRAllocator = std::allocator<UniqueHandle<SwapchainKHR>>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<UniqueHandle<SwapchainKHR>, SwapchainKHRAllocator>>::type
      createSharedSwapchainsKHRUnique( ArrayProxy<SwapchainCreateInfoKHR const> const & createInfos,
                                       Optional<AllocationCallbacks const> allocator    VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                       DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    template <typename SwapchainKHRAllocator = std::allocator<UniqueHandle<SwapchainKHR>>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<UniqueHandle<SwapchainKHR>, SwapchainKHRAllocator>>::type
      createSharedSwapchainsKHRUnique( ArrayProxy<SwapchainCreateInfoKHR const> const & createInfos,
                                       Optional<AllocationCallbacks const>              allocator,
                                       SwapchainKHRAllocator const &                    swapchainKHRAllocator,
                                       DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateSharedSwapchainsKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSharedSwapchainsKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SwapchainKHR>>::type
      createSharedSwapchainKHRUnique( SwapchainCreateInfoKHR const &                createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_debug_marker ===

    // wrapper function for command vkDebugMarkerSetObjectTagEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectTagEXT.html
    VULKAN_HPP_NODISCARD Result debugMarkerSetObjectTagEXT( DebugMarkerObjectTagInfoEXT const * pTagInfo,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDebugMarkerSetObjectTagEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectTagEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      debugMarkerSetObjectTagEXT( DebugMarkerObjectTagInfoEXT const & tagInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDebugMarkerSetObjectNameEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectNameEXT.html
    VULKAN_HPP_NODISCARD Result debugMarkerSetObjectNameEXT( DebugMarkerObjectNameInfoEXT const * pNameInfo,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDebugMarkerSetObjectNameEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugMarkerSetObjectNameEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      debugMarkerSetObjectNameEXT( DebugMarkerObjectNameInfoEXT const & nameInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_video_queue ===

    // wrapper function for command vkCreateVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionKHR.html
    VULKAN_HPP_NODISCARD Result createVideoSessionKHR( VideoSessionCreateInfoKHR const * pCreateInfo,
                                                       AllocationCallbacks const *       pAllocator,
                                                       VideoSessionKHR *                 pVideoSession,
                                                       DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<VideoSessionKHR>::type
      createVideoSessionKHR( VideoSessionCreateInfoKHR const &             createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<VideoSessionKHR>>::type
      createVideoSessionKHRUnique( VideoSessionCreateInfoKHR const &             createInfo,
                                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionKHR.html
    void destroyVideoSessionKHR( VideoSessionKHR             videoSession,
                                 AllocationCallbacks const * pAllocator,
                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionKHR.html
    void destroyVideoSessionKHR( VideoSessionKHR videoSession                  VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionKHR.html
    void destroy( VideoSessionKHR             videoSession,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyVideoSessionKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionKHR.html
    void destroy( VideoSessionKHR                               videoSession,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetVideoSessionMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetVideoSessionMemoryRequirementsKHR.html
    VULKAN_HPP_NODISCARD Result
      getVideoSessionMemoryRequirementsKHR( VideoSessionKHR                     videoSession,
                                            uint32_t *                          pMemoryRequirementsCount,
                                            VideoSessionMemoryRequirementsKHR * pMemoryRequirements,
                                            DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetVideoSessionMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetVideoSessionMemoryRequirementsKHR.html
    template <typename VideoSessionMemoryRequirementsKHRAllocator = std::allocator<VideoSessionMemoryRequirementsKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<VideoSessionMemoryRequirementsKHR, VideoSessionMemoryRequirementsKHRAllocator>>::type
      getVideoSessionMemoryRequirementsKHR( VideoSessionKHR videoSession, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetVideoSessionMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetVideoSessionMemoryRequirementsKHR.html
    template <typename VideoSessionMemoryRequirementsKHRAllocator = std::allocator<VideoSessionMemoryRequirementsKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<VideoSessionMemoryRequirementsKHR, VideoSessionMemoryRequirementsKHRAllocator>>::type
      getVideoSessionMemoryRequirementsKHR( VideoSessionKHR                                    videoSession,
                                            VideoSessionMemoryRequirementsKHRAllocator const & videoSessionMemoryRequirementsKHRAllocator,
                                            DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBindVideoSessionMemoryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindVideoSessionMemoryKHR.html
    VULKAN_HPP_NODISCARD Result bindVideoSessionMemoryKHR( VideoSessionKHR                       videoSession,
                                                           uint32_t                              bindSessionMemoryInfoCount,
                                                           BindVideoSessionMemoryInfoKHR const * pBindSessionMemoryInfos,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindVideoSessionMemoryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindVideoSessionMemoryKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindVideoSessionMemoryKHR( VideoSessionKHR                                         videoSession,
                                 ArrayProxy<BindVideoSessionMemoryInfoKHR const> const & bindSessionMemoryInfos,
                                 DispatchLoader const & d                                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionParametersKHR.html
    VULKAN_HPP_NODISCARD Result createVideoSessionParametersKHR( VideoSessionParametersCreateInfoKHR const * pCreateInfo,
                                                                 AllocationCallbacks const *                 pAllocator,
                                                                 VideoSessionParametersKHR *                 pVideoSessionParameters,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionParametersKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<VideoSessionParametersKHR>::type
      createVideoSessionParametersKHR( VideoSessionParametersCreateInfoKHR const &   createInfo,
                                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateVideoSessionParametersKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<VideoSessionParametersKHR>>::type
      createVideoSessionParametersKHRUnique( VideoSessionParametersCreateInfoKHR const &   createInfo,
                                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUpdateVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateVideoSessionParametersKHR.html
    VULKAN_HPP_NODISCARD Result updateVideoSessionParametersKHR( VideoSessionParametersKHR                   videoSessionParameters,
                                                                 VideoSessionParametersUpdateInfoKHR const * pUpdateInfo,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUpdateVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateVideoSessionParametersKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      updateVideoSessionParametersKHR( VideoSessionParametersKHR                   videoSessionParameters,
                                       VideoSessionParametersUpdateInfoKHR const & updateInfo,
                                       DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionParametersKHR.html
    void destroyVideoSessionParametersKHR( VideoSessionParametersKHR   videoSessionParameters,
                                           AllocationCallbacks const * pAllocator,
                                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionParametersKHR.html
    void destroyVideoSessionParametersKHR( VideoSessionParametersKHR videoSessionParameters VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                           Optional<AllocationCallbacks const> allocator    VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionParametersKHR.html
    void destroy( VideoSessionParametersKHR   videoSessionParameters,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyVideoSessionParametersKHR.html
    void destroy( VideoSessionParametersKHR                     videoSessionParameters,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NVX_binary_import ===

    // wrapper function for command vkCreateCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuModuleNVX.html
    VULKAN_HPP_NODISCARD Result createCuModuleNVX( CuModuleCreateInfoNVX const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   CuModuleNVX *                 pModule,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuModuleNVX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<CuModuleNVX>::type
      createCuModuleNVX( CuModuleCreateInfoNVX const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuModuleNVX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<CuModuleNVX>>::type
      createCuModuleNVXUnique( CuModuleCreateInfoNVX const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuFunctionNVX.html
    VULKAN_HPP_NODISCARD Result createCuFunctionNVX( CuFunctionCreateInfoNVX const * pCreateInfo,
                                                     AllocationCallbacks const *     pAllocator,
                                                     CuFunctionNVX *                 pFunction,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuFunctionNVX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<CuFunctionNVX>::type
      createCuFunctionNVX( CuFunctionCreateInfoNVX const &               createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCuFunctionNVX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<CuFunctionNVX>>::type
      createCuFunctionNVXUnique( CuFunctionCreateInfoNVX const &               createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuModuleNVX.html
    void destroyCuModuleNVX( CuModuleNVX                 module,
                             AllocationCallbacks const * pAllocator,
                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuModuleNVX.html
    void destroyCuModuleNVX( CuModuleNVX                                   module,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuModuleNVX.html
    void destroy( CuModuleNVX                 module,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCuModuleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuModuleNVX.html
    void destroy( CuModuleNVX                                   module,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuFunctionNVX.html
    void destroyCuFunctionNVX( CuFunctionNVX               function,
                               AllocationCallbacks const * pAllocator,
                               DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuFunctionNVX.html
    void destroyCuFunctionNVX( CuFunctionNVX                                 function,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuFunctionNVX.html
    void destroy( CuFunctionNVX               function,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCuFunctionNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCuFunctionNVX.html
    void destroy( CuFunctionNVX                                 function,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NVX_image_view_handle ===

    // wrapper function for command vkGetImageViewHandleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandleNVX.html
    uint32_t getImageViewHandleNVX( ImageViewHandleInfoNVX const * pInfo,
                                    DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageViewHandleNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandleNVX.html
    uint32_t getImageViewHandleNVX( ImageViewHandleInfoNVX const & info,
                                    DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageViewHandle64NVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandle64NVX.html
    uint64_t getImageViewHandle64NVX( ImageViewHandleInfoNVX const * pInfo,
                                      DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageViewHandle64NVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewHandle64NVX.html
    uint64_t getImageViewHandle64NVX( ImageViewHandleInfoNVX const & info,
                                      DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageViewAddressNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewAddressNVX.html
    VULKAN_HPP_NODISCARD Result getImageViewAddressNVX( ImageView                       imageView,
                                                        ImageViewAddressPropertiesNVX * pProperties,
                                                        DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageViewAddressNVX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewAddressNVX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ImageViewAddressPropertiesNVX>::type
      getImageViewAddressNVX( ImageView imageView, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceCombinedImageSamplerIndexNVX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceCombinedImageSamplerIndexNVX.html
    uint64_t getCombinedImageSamplerIndexNVX( uint64_t                 imageViewIndex,
                                              uint64_t                 samplerIndex,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_AMD_shader_info ===

    // wrapper function for command vkGetShaderInfoAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderInfoAMD.html
    VULKAN_HPP_NODISCARD Result getShaderInfoAMD( Pipeline                 pipeline,
                                                  ShaderStageFlagBits      shaderStage,
                                                  ShaderInfoTypeAMD        infoType,
                                                  size_t *                 pInfoSize,
                                                  void *                   pInfo,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetShaderInfoAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderInfoAMD.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type getShaderInfoAMD(
      Pipeline pipeline, ShaderStageFlagBits shaderStage, ShaderInfoTypeAMD infoType, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetShaderInfoAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderInfoAMD.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type
      getShaderInfoAMD( Pipeline                 pipeline,
                        ShaderStageFlagBits      shaderStage,
                        ShaderInfoTypeAMD        infoType,
                        Uint8_tAllocator const & uint8_tAllocator,
                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_NV_external_memory_win32 ===

    // wrapper function for command vkGetMemoryWin32HandleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryWin32HandleNV.html
    VULKAN_HPP_NODISCARD Result getMemoryWin32HandleNV( DeviceMemory                    memory,
                                                        ExternalMemoryHandleTypeFlagsNV handleType,
                                                        HANDLE *                        pHandle,
                                                        DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryWin32HandleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryWin32HandleNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<HANDLE>::type getMemoryWin32HandleNV(
      DeviceMemory memory, ExternalMemoryHandleTypeFlagsNV handleType, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_KHR_device_group ===

    // wrapper function for command vkGetDeviceGroupPeerMemoryFeaturesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeaturesKHR.html
    void getGroupPeerMemoryFeaturesKHR( uint32_t                 heapIndex,
                                        uint32_t                 localDeviceIndex,
                                        uint32_t                 remoteDeviceIndex,
                                        PeerMemoryFeatureFlags * pPeerMemoryFeatures,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceGroupPeerMemoryFeaturesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupPeerMemoryFeaturesKHR.html
    VULKAN_HPP_NODISCARD PeerMemoryFeatureFlags
      getGroupPeerMemoryFeaturesKHR( uint32_t                 heapIndex,
                                     uint32_t                 localDeviceIndex,
                                     uint32_t                 remoteDeviceIndex,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_maintenance1 ===

    // wrapper function for command vkTrimCommandPoolKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkTrimCommandPoolKHR.html
    void trimCommandPoolKHR( CommandPool              commandPool,
                             CommandPoolTrimFlags     flags,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_KHR_external_memory_win32 ===

    // wrapper function for command vkGetMemoryWin32HandleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryWin32HandleKHR.html
    VULKAN_HPP_NODISCARD Result getMemoryWin32HandleKHR( MemoryGetWin32HandleInfoKHR const * pGetWin32HandleInfo,
                                                         HANDLE *                            pHandle,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryWin32HandleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryWin32HandleKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<HANDLE>::type
      getMemoryWin32HandleKHR( MemoryGetWin32HandleInfoKHR const & getWin32HandleInfo,
                               DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMemoryWin32HandlePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryWin32HandlePropertiesKHR.html
    VULKAN_HPP_NODISCARD Result
      getMemoryWin32HandlePropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType,
                                         HANDLE                           handle,
                                         MemoryWin32HandlePropertiesKHR * pMemoryWin32HandleProperties,
                                         DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryWin32HandlePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryWin32HandlePropertiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<MemoryWin32HandlePropertiesKHR>::type getMemoryWin32HandlePropertiesKHR(
      ExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_KHR_external_memory_fd ===

    // wrapper function for command vkGetMemoryFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdKHR.html
    VULKAN_HPP_NODISCARD Result getMemoryFdKHR( MemoryGetFdInfoKHR const * pGetFdInfo,
                                                int *                      pFd,
                                                DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<int>::type getMemoryFdKHR( MemoryGetFdInfoKHR const & getFdInfo,
                                                                             DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMemoryFdPropertiesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdPropertiesKHR.html
    VULKAN_HPP_NODISCARD Result getMemoryFdPropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType,
                                                          int                              fd,
                                                          MemoryFdPropertiesKHR *          pMemoryFdProperties,
                                                          DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryFdPropertiesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryFdPropertiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<MemoryFdPropertiesKHR>::type
      getMemoryFdPropertiesKHR( ExternalMemoryHandleTypeFlagBits handleType, int fd, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_KHR_external_semaphore_win32 ===

    // wrapper function for command vkImportSemaphoreWin32HandleKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreWin32HandleKHR.html
    VULKAN_HPP_NODISCARD Result importSemaphoreWin32HandleKHR( ImportSemaphoreWin32HandleInfoKHR const * pImportSemaphoreWin32HandleInfo,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkImportSemaphoreWin32HandleKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreWin32HandleKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      importSemaphoreWin32HandleKHR( ImportSemaphoreWin32HandleInfoKHR const & importSemaphoreWin32HandleInfo,
                                     DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSemaphoreWin32HandleKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreWin32HandleKHR.html
    VULKAN_HPP_NODISCARD Result getSemaphoreWin32HandleKHR( SemaphoreGetWin32HandleInfoKHR const * pGetWin32HandleInfo,
                                                            HANDLE *                               pHandle,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSemaphoreWin32HandleKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreWin32HandleKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<HANDLE>::type
      getSemaphoreWin32HandleKHR( SemaphoreGetWin32HandleInfoKHR const & getWin32HandleInfo,
                                  DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_KHR_external_semaphore_fd ===

    // wrapper function for command vkImportSemaphoreFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreFdKHR.html
    VULKAN_HPP_NODISCARD Result importSemaphoreFdKHR( ImportSemaphoreFdInfoKHR const * pImportSemaphoreFdInfo,
                                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkImportSemaphoreFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreFdKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      importSemaphoreFdKHR( ImportSemaphoreFdInfoKHR const & importSemaphoreFdInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSemaphoreFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreFdKHR.html
    VULKAN_HPP_NODISCARD Result getSemaphoreFdKHR( SemaphoreGetFdInfoKHR const * pGetFdInfo,
                                                   int *                         pFd,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSemaphoreFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreFdKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<int>::type getSemaphoreFdKHR( SemaphoreGetFdInfoKHR const & getFdInfo,
                                                                                DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_descriptor_update_template ===

    // wrapper function for command vkCreateDescriptorUpdateTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplateKHR.html
    VULKAN_HPP_NODISCARD Result
      createDescriptorUpdateTemplateKHR( DescriptorUpdateTemplateCreateInfo const * pCreateInfo,
                                         AllocationCallbacks const *                pAllocator,
                                         DescriptorUpdateTemplate *                 pDescriptorUpdateTemplate,
                                         DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDescriptorUpdateTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplateKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DescriptorUpdateTemplate>::type
      createDescriptorUpdateTemplateKHR( DescriptorUpdateTemplateCreateInfo const &    createInfo,
                                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDescriptorUpdateTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDescriptorUpdateTemplateKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DescriptorUpdateTemplate>>::type
      createDescriptorUpdateTemplateKHRUnique( DescriptorUpdateTemplateCreateInfo const &    createInfo,
                                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDescriptorUpdateTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplateKHR.html
    void destroyDescriptorUpdateTemplateKHR( DescriptorUpdateTemplate    descriptorUpdateTemplate,
                                             AllocationCallbacks const * pAllocator,
                                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDescriptorUpdateTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDescriptorUpdateTemplateKHR.html
    void destroyDescriptorUpdateTemplateKHR( DescriptorUpdateTemplate descriptorUpdateTemplate VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                             Optional<AllocationCallbacks const> allocator     VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUpdateDescriptorSetWithTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplateKHR.html
    void updateDescriptorSetWithTemplateKHR( DescriptorSet            descriptorSet,
                                             DescriptorUpdateTemplate descriptorUpdateTemplate,
                                             void const *             pData,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUpdateDescriptorSetWithTemplateKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateDescriptorSetWithTemplateKHR.html
    template <typename DataType>
    void updateDescriptorSetWithTemplateKHR( DescriptorSet            descriptorSet,
                                             DescriptorUpdateTemplate descriptorUpdateTemplate,
                                             DataType const &         data,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_display_control ===

    // wrapper function for command vkDisplayPowerControlEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDisplayPowerControlEXT.html
    VULKAN_HPP_NODISCARD Result displayPowerControlEXT( DisplayKHR                  display,
                                                        DisplayPowerInfoEXT const * pDisplayPowerInfo,
                                                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDisplayPowerControlEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDisplayPowerControlEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type displayPowerControlEXT(
      DisplayKHR display, DisplayPowerInfoEXT const & displayPowerInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkRegisterDeviceEventEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDeviceEventEXT.html
    VULKAN_HPP_NODISCARD Result registerEventEXT( DeviceEventInfoEXT const *  pDeviceEventInfo,
                                                  AllocationCallbacks const * pAllocator,
                                                  Fence *                     pFence,
                                                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkRegisterDeviceEventEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDeviceEventEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Fence>::type
      registerEventEXT( DeviceEventInfoEXT const &                    deviceEventInfo,
                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkRegisterDeviceEventEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDeviceEventEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Fence>>::type
      registerEventEXTUnique( DeviceEventInfoEXT const &                    deviceEventInfo,
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkRegisterDisplayEventEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDisplayEventEXT.html
    VULKAN_HPP_NODISCARD Result registerDisplayEventEXT( DisplayKHR                  display,
                                                         DisplayEventInfoEXT const * pDisplayEventInfo,
                                                         AllocationCallbacks const * pAllocator,
                                                         Fence *                     pFence,
                                                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkRegisterDisplayEventEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDisplayEventEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Fence>::type
      registerDisplayEventEXT( DisplayKHR                                    display,
                               DisplayEventInfoEXT const &                   displayEventInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkRegisterDisplayEventEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterDisplayEventEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Fence>>::type
      registerDisplayEventEXTUnique( DisplayKHR                                    display,
                                     DisplayEventInfoEXT const &                   displayEventInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSwapchainCounterEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainCounterEXT.html
    VULKAN_HPP_NODISCARD Result getSwapchainCounterEXT( SwapchainKHR              swapchain,
                                                        SurfaceCounterFlagBitsEXT counter,
                                                        uint64_t *                pCounterValue,
                                                        DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSwapchainCounterEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainCounterEXT.html
    VULKAN_HPP_NODISCARD
#  if defined( VULKAN_HPP_HANDLE_ERROR_OUT_OF_DATE_AS_SUCCESS )
    ResultValue<uint64_t>
#  else
    typename ResultValueType<uint64_t>::type
#  endif
      getSwapchainCounterEXT( SwapchainKHR              swapchain,
                              SurfaceCounterFlagBitsEXT counter,
                              DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_GOOGLE_display_timing ===

    // wrapper function for command vkGetRefreshCycleDurationGOOGLE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRefreshCycleDurationGOOGLE.html
    VULKAN_HPP_NODISCARD Result getRefreshCycleDurationGOOGLE( SwapchainKHR                 swapchain,
                                                               RefreshCycleDurationGOOGLE * pDisplayTimingProperties,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRefreshCycleDurationGOOGLE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRefreshCycleDurationGOOGLE.html
    VULKAN_HPP_NODISCARD typename ResultValueType<RefreshCycleDurationGOOGLE>::type
      getRefreshCycleDurationGOOGLE( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPastPresentationTimingGOOGLE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPastPresentationTimingGOOGLE.html
    VULKAN_HPP_NODISCARD Result getPastPresentationTimingGOOGLE( SwapchainKHR                   swapchain,
                                                                 uint32_t *                     pPresentationTimingCount,
                                                                 PastPresentationTimingGOOGLE * pPresentationTimings,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPastPresentationTimingGOOGLE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPastPresentationTimingGOOGLE.html
    template <typename PastPresentationTimingGOOGLEAllocator = std::allocator<PastPresentationTimingGOOGLE>>
    VULKAN_HPP_NODISCARD
#  if defined( VULKAN_HPP_HANDLE_ERROR_OUT_OF_DATE_AS_SUCCESS )
      ResultValue<std::vector<PastPresentationTimingGOOGLE, PastPresentationTimingGOOGLEAllocator>>
#  else
      typename ResultValueType<std::vector<PastPresentationTimingGOOGLE, PastPresentationTimingGOOGLEAllocator>>::type
#  endif
      getPastPresentationTimingGOOGLE( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPastPresentationTimingGOOGLE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPastPresentationTimingGOOGLE.html
    template <typename PastPresentationTimingGOOGLEAllocator = std::allocator<PastPresentationTimingGOOGLE>>
    VULKAN_HPP_NODISCARD
#  if defined( VULKAN_HPP_HANDLE_ERROR_OUT_OF_DATE_AS_SUCCESS )
      ResultValue<std::vector<PastPresentationTimingGOOGLE, PastPresentationTimingGOOGLEAllocator>>
#  else
      typename ResultValueType<std::vector<PastPresentationTimingGOOGLE, PastPresentationTimingGOOGLEAllocator>>::type
#  endif
      getPastPresentationTimingGOOGLE( SwapchainKHR                                  swapchain,
                                       PastPresentationTimingGOOGLEAllocator const & pastPresentationTimingGOOGLEAllocator,
                                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_hdr_metadata ===

    // wrapper function for command vkSetHdrMetadataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetHdrMetadataEXT.html
    void setHdrMetadataEXT( uint32_t                 swapchainCount,
                            SwapchainKHR const *     pSwapchains,
                            HdrMetadataEXT const *   pMetadata,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetHdrMetadataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetHdrMetadataEXT.html
    void setHdrMetadataEXT( ArrayProxy<SwapchainKHR const> const &   swapchains,
                            ArrayProxy<HdrMetadataEXT const> const & metadata,
                            DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_create_renderpass2 ===

    // wrapper function for command vkCreateRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2KHR.html
    VULKAN_HPP_NODISCARD Result createRenderPass2KHR( RenderPassCreateInfo2 const * pCreateInfo,
                                                      AllocationCallbacks const *   pAllocator,
                                                      RenderPass *                  pRenderPass,
                                                      DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2KHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<RenderPass>::type
      createRenderPass2KHR( RenderPassCreateInfo2 const &                 createInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateRenderPass2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRenderPass2KHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<RenderPass>>::type
      createRenderPass2KHRUnique( RenderPassCreateInfo2 const &                 createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_shared_presentable_image ===

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSwapchainStatusKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainStatusKHR.html
    VULKAN_HPP_NODISCARD Result getSwapchainStatusKHR( SwapchainKHR             swapchain,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkGetSwapchainStatusKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainStatusKHR.html
    VULKAN_HPP_NODISCARD Result getSwapchainStatusKHR( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_KHR_external_fence_win32 ===

    // wrapper function for command vkImportFenceWin32HandleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportFenceWin32HandleKHR.html
    VULKAN_HPP_NODISCARD Result importFenceWin32HandleKHR( ImportFenceWin32HandleInfoKHR const * pImportFenceWin32HandleInfo,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkImportFenceWin32HandleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportFenceWin32HandleKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      importFenceWin32HandleKHR( ImportFenceWin32HandleInfoKHR const & importFenceWin32HandleInfo,
                                 DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetFenceWin32HandleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceWin32HandleKHR.html
    VULKAN_HPP_NODISCARD Result getFenceWin32HandleKHR( FenceGetWin32HandleInfoKHR const * pGetWin32HandleInfo,
                                                        HANDLE *                           pHandle,
                                                        DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetFenceWin32HandleKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceWin32HandleKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<HANDLE>::type
      getFenceWin32HandleKHR( FenceGetWin32HandleInfoKHR const & getWin32HandleInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_KHR_external_fence_fd ===

    // wrapper function for command vkImportFenceFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportFenceFdKHR.html
    VULKAN_HPP_NODISCARD Result importFenceFdKHR( ImportFenceFdInfoKHR const * pImportFenceFdInfo,
                                                  DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkImportFenceFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportFenceFdKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      importFenceFdKHR( ImportFenceFdInfoKHR const & importFenceFdInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetFenceFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceFdKHR.html
    VULKAN_HPP_NODISCARD Result getFenceFdKHR( FenceGetFdInfoKHR const * pGetFdInfo,
                                               int *                     pFd,
                                               DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetFenceFdKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFenceFdKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<int>::type getFenceFdKHR( FenceGetFdInfoKHR const & getFdInfo,
                                                                            DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_performance_query ===

    // wrapper function for command vkAcquireProfilingLockKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireProfilingLockKHR.html
    VULKAN_HPP_NODISCARD Result acquireProfilingLockKHR( AcquireProfilingLockInfoKHR const * pInfo,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireProfilingLockKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireProfilingLockKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      acquireProfilingLockKHR( AcquireProfilingLockInfoKHR const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkReleaseProfilingLockKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseProfilingLockKHR.html
    void releaseProfilingLockKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_debug_utils ===

    // wrapper function for command vkSetDebugUtilsObjectNameEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectNameEXT.html
    VULKAN_HPP_NODISCARD Result setDebugUtilsObjectNameEXT( DebugUtilsObjectNameInfoEXT const * pNameInfo,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetDebugUtilsObjectNameEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectNameEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setDebugUtilsObjectNameEXT( DebugUtilsObjectNameInfoEXT const & nameInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkSetDebugUtilsObjectNameEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectNameEXT.html
    template <typename HandleType>
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type setDebugUtilsObjectNameEXT(
      HandleType const & handle, std::string const & name, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSetDebugUtilsObjectTagEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectTagEXT.html
    VULKAN_HPP_NODISCARD Result setDebugUtilsObjectTagEXT( DebugUtilsObjectTagInfoEXT const * pTagInfo,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetDebugUtilsObjectTagEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectTagEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setDebugUtilsObjectTagEXT( DebugUtilsObjectTagInfoEXT const & tagInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkSetDebugUtilsObjectTagEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDebugUtilsObjectTagEXT.html
    template <typename HandleType, typename TagType>
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type setDebugUtilsObjectTagEXT(
      HandleType const & handle, uint64_t name, TagType const & tag, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
    //=== VK_ANDROID_external_memory_android_hardware_buffer ===

    // wrapper function for command vkGetAndroidHardwareBufferPropertiesANDROID, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAndroidHardwareBufferPropertiesANDROID.html
    VULKAN_HPP_NODISCARD Result
      getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer *           buffer,
                                                 AndroidHardwareBufferPropertiesANDROID * pProperties,
                                                 DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetAndroidHardwareBufferPropertiesANDROID, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAndroidHardwareBufferPropertiesANDROID.html
    VULKAN_HPP_NODISCARD typename ResultValueType<AndroidHardwareBufferPropertiesANDROID>::type
      getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer & buffer,
                                                 DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetAndroidHardwareBufferPropertiesANDROID, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAndroidHardwareBufferPropertiesANDROID.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getAndroidHardwareBufferPropertiesANDROID( const struct AHardwareBuffer & buffer,
                                                 DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMemoryAndroidHardwareBufferANDROID, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryAndroidHardwareBufferANDROID.html
    VULKAN_HPP_NODISCARD Result
      getMemoryAndroidHardwareBufferANDROID( MemoryGetAndroidHardwareBufferInfoANDROID const * pInfo,
                                             struct AHardwareBuffer **                         pBuffer,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryAndroidHardwareBufferANDROID, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryAndroidHardwareBufferANDROID.html
    VULKAN_HPP_NODISCARD typename ResultValueType<struct AHardwareBuffer *>::type
      getMemoryAndroidHardwareBufferANDROID( MemoryGetAndroidHardwareBufferInfoANDROID const & info,
                                             DispatchLoader const & d                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_ENABLE_BETA_EXTENSIONS )
    //=== VK_AMDX_shader_enqueue ===

    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    VULKAN_HPP_NODISCARD Result
      createExecutionGraphPipelinesAMDX( PipelineCache                                pipelineCache,
                                         uint32_t                                     createInfoCount,
                                         ExecutionGraphPipelineCreateInfoAMDX const * pCreateInfos,
                                         AllocationCallbacks const *                  pAllocator,
                                         Pipeline *                                   pPipelines,
                                         DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createExecutionGraphPipelinesAMDX( PipelineCache                                                  pipelineCache,
                                                            ArrayProxy<ExecutionGraphPipelineCreateInfoAMDX const> const & createInfos,
                                                            Optional<AllocationCallbacks const> allocator                  VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                            DispatchLoader const & d                                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createExecutionGraphPipelinesAMDX( PipelineCache                                                  pipelineCache,
                                                            ArrayProxy<ExecutionGraphPipelineCreateInfoAMDX const> const & createInfos,
                                                            Optional<AllocationCallbacks const>                            allocator,
                                                            PipelineAllocator const &                                      pipelineAllocator,
                                                            DispatchLoader const & d                                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    VULKAN_HPP_NODISCARD ResultValue<Pipeline>
                         createExecutionGraphPipelineAMDX( PipelineCache                                 pipelineCache,
                                                           ExecutionGraphPipelineCreateInfoAMDX const &  createInfo,
                                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createExecutionGraphPipelinesAMDXUnique( PipelineCache                                                  pipelineCache,
                                                                  ArrayProxy<ExecutionGraphPipelineCreateInfoAMDX const> const & createInfos,
                                                                  Optional<AllocationCallbacks const> allocator                  VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                                  DispatchLoader const & d                                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createExecutionGraphPipelinesAMDXUnique( PipelineCache                                                  pipelineCache,
                                                                  ArrayProxy<ExecutionGraphPipelineCreateInfoAMDX const> const & createInfos,
                                                                  Optional<AllocationCallbacks const>                            allocator,
                                                                  PipelineAllocator const &                                      pipelineAllocator,
                                                                  DispatchLoader const & d                                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateExecutionGraphPipelinesAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExecutionGraphPipelinesAMDX.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<Pipeline>>
                         createExecutionGraphPipelineAMDXUnique( PipelineCache                                 pipelineCache,
                                                                 ExecutionGraphPipelineCreateInfoAMDX const &  createInfo,
                                                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetExecutionGraphPipelineScratchSizeAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExecutionGraphPipelineScratchSizeAMDX.html
    VULKAN_HPP_NODISCARD Result
      getExecutionGraphPipelineScratchSizeAMDX( Pipeline                                executionGraph,
                                                ExecutionGraphPipelineScratchSizeAMDX * pSizeInfo,
                                                DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetExecutionGraphPipelineScratchSizeAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExecutionGraphPipelineScratchSizeAMDX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ExecutionGraphPipelineScratchSizeAMDX>::type
      getExecutionGraphPipelineScratchSizeAMDX( Pipeline executionGraph, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetExecutionGraphPipelineNodeIndexAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExecutionGraphPipelineNodeIndexAMDX.html
    VULKAN_HPP_NODISCARD Result
      getExecutionGraphPipelineNodeIndexAMDX( Pipeline                                      executionGraph,
                                              PipelineShaderStageNodeCreateInfoAMDX const * pNodeInfo,
                                              uint32_t *                                    pNodeIndex,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetExecutionGraphPipelineNodeIndexAMDX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetExecutionGraphPipelineNodeIndexAMDX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<uint32_t>::type
      getExecutionGraphPipelineNodeIndexAMDX( Pipeline                                      executionGraph,
                                              PipelineShaderStageNodeCreateInfoAMDX const & nodeInfo,
                                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_ENABLE_BETA_EXTENSIONS*/

    //=== VK_EXT_descriptor_heap ===

    // wrapper function for command vkWriteSamplerDescriptorsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteSamplerDescriptorsEXT.html
    VULKAN_HPP_NODISCARD Result writeSamplerDescriptorsEXT( uint32_t                    samplerCount,
                                                            SamplerCreateInfo const *   pSamplers,
                                                            HostAddressRangeEXT const * pDescriptors,
                                                            DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWriteSamplerDescriptorsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteSamplerDescriptorsEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      writeSamplerDescriptorsEXT( ArrayProxy<SamplerCreateInfo const> const &   samplers,
                                  ArrayProxy<HostAddressRangeEXT const> const & descriptors,
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkWriteResourceDescriptorsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteResourceDescriptorsEXT.html
    VULKAN_HPP_NODISCARD Result writeResourceDescriptorsEXT( uint32_t                          resourceCount,
                                                             ResourceDescriptorInfoEXT const * pResources,
                                                             HostAddressRangeEXT const *       pDescriptors,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWriteResourceDescriptorsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteResourceDescriptorsEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      writeResourceDescriptorsEXT( ArrayProxy<ResourceDescriptorInfoEXT const> const & resources,
                                   ArrayProxy<HostAddressRangeEXT const> const &       descriptors,
                                   DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageOpaqueCaptureDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageOpaqueCaptureDataEXT.html
    VULKAN_HPP_NODISCARD Result getImageOpaqueCaptureDataEXT( uint32_t                 imageCount,
                                                              Image const *            pImages,
                                                              HostAddressRangeEXT *    pDatas,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkRegisterCustomBorderColorEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterCustomBorderColorEXT.html
    VULKAN_HPP_NODISCARD Result registerCustomBorderColorEXT( SamplerCustomBorderColorCreateInfoEXT const * pBorderColor,
                                                              Bool32                                        requestIndex,
                                                              uint32_t *                                    pIndex,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkRegisterCustomBorderColorEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkRegisterCustomBorderColorEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<uint32_t>::type registerCustomBorderColorEXT(
      SamplerCustomBorderColorCreateInfoEXT const & borderColor, Bool32 requestIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUnregisterCustomBorderColorEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnregisterCustomBorderColorEXT.html
    void unregisterCustomBorderColorEXT( uint32_t index, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkGetTensorOpaqueCaptureDataARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorOpaqueCaptureDataARM.html
    VULKAN_HPP_NODISCARD Result getTensorOpaqueCaptureDataARM( uint32_t                 tensorCount,
                                                               TensorARM const *        pTensors,
                                                               HostAddressRangeEXT *    pDatas,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_get_memory_requirements2 ===

    // wrapper function for command vkGetImageMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2KHR.html
    void getImageMemoryRequirements2KHR( ImageMemoryRequirementsInfo2 const * pInfo,
                                         MemoryRequirements2 *                pMemoryRequirements,
                                         DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2KHR.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getImageMemoryRequirements2KHR(
      ImageMemoryRequirementsInfo2 const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetImageMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageMemoryRequirements2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getImageMemoryRequirements2KHR( ImageMemoryRequirementsInfo2 const & info,
                                                         DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2KHR.html
    void getBufferMemoryRequirements2KHR( BufferMemoryRequirementsInfo2 const * pInfo,
                                          MemoryRequirements2 *                 pMemoryRequirements,
                                          DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2KHR.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getBufferMemoryRequirements2KHR(
      BufferMemoryRequirementsInfo2 const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetBufferMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferMemoryRequirements2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getBufferMemoryRequirements2KHR( BufferMemoryRequirementsInfo2 const & info,
                                                          DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSparseMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2KHR.html
    void getImageSparseMemoryRequirements2KHR( ImageSparseMemoryRequirementsInfo2 const * pInfo,
                                               uint32_t *                                 pSparseMemoryRequirementCount,
                                               SparseImageMemoryRequirements2 *           pSparseMemoryRequirements,
                                               DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSparseMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2KHR.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirements2KHR( ImageSparseMemoryRequirementsInfo2 const & info,
                                                               DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetImageSparseMemoryRequirements2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSparseMemoryRequirements2KHR.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirements2KHR( ImageSparseMemoryRequirementsInfo2 const &      info,
                                                               SparseImageMemoryRequirements2Allocator const & sparseImageMemoryRequirements2Allocator,
                                                               DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_acceleration_structure ===

    // wrapper function for command vkCreateAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD Result createAccelerationStructureKHR( AccelerationStructureCreateInfoKHR const * pCreateInfo,
                                                                AllocationCallbacks const *                pAllocator,
                                                                AccelerationStructureKHR *                 pAccelerationStructure,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<AccelerationStructureKHR>::type
      createAccelerationStructureKHR( AccelerationStructureCreateInfoKHR const &    createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<AccelerationStructureKHR>>::type
      createAccelerationStructureKHRUnique( AccelerationStructureCreateInfoKHR const &    createInfo,
                                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureKHR.html
    void destroyAccelerationStructureKHR( AccelerationStructureKHR    accelerationStructure,
                                          AllocationCallbacks const * pAllocator,
                                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureKHR.html
    void destroyAccelerationStructureKHR( AccelerationStructureKHR accelerationStructure VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                          Optional<AllocationCallbacks const> allocator  VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureKHR.html
    void destroy( AccelerationStructureKHR    accelerationStructure,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureKHR.html
    void destroy( AccelerationStructureKHR                      accelerationStructure,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBuildAccelerationStructuresKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBuildAccelerationStructuresKHR.html
    VULKAN_HPP_NODISCARD Result buildAccelerationStructuresKHR( DeferredOperationKHR                                   deferredOperation,
                                                                uint32_t                                               infoCount,
                                                                AccelerationStructureBuildGeometryInfoKHR const *      pInfos,
                                                                AccelerationStructureBuildRangeInfoKHR const * const * ppBuildRangeInfos,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBuildAccelerationStructuresKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBuildAccelerationStructuresKHR.html
    VULKAN_HPP_NODISCARD Result buildAccelerationStructuresKHR( DeferredOperationKHR                                                     deferredOperation,
                                                                ArrayProxy<AccelerationStructureBuildGeometryInfoKHR const> const &      infos,
                                                                ArrayProxy<AccelerationStructureBuildRangeInfoKHR const * const> const & pBuildRangeInfos,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD Result copyAccelerationStructureKHR( DeferredOperationKHR                     deferredOperation,
                                                              CopyAccelerationStructureInfoKHR const * pInfo,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD Result copyAccelerationStructureKHR( DeferredOperationKHR                     deferredOperation,
                                                              CopyAccelerationStructureInfoKHR const & info,
                                                              DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyAccelerationStructureToMemoryKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyAccelerationStructureToMemoryKHR.html
    VULKAN_HPP_NODISCARD Result
      copyAccelerationStructureToMemoryKHR( DeferredOperationKHR                             deferredOperation,
                                            CopyAccelerationStructureToMemoryInfoKHR const * pInfo,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyAccelerationStructureToMemoryKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyAccelerationStructureToMemoryKHR.html
    VULKAN_HPP_NODISCARD Result copyAccelerationStructureToMemoryKHR( DeferredOperationKHR                             deferredOperation,
                                                                      CopyAccelerationStructureToMemoryInfoKHR const & info,
                                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyMemoryToAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD Result
      copyMemoryToAccelerationStructureKHR( DeferredOperationKHR                             deferredOperation,
                                            CopyMemoryToAccelerationStructureInfoKHR const * pInfo,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyMemoryToAccelerationStructureKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToAccelerationStructureKHR.html
    VULKAN_HPP_NODISCARD Result copyMemoryToAccelerationStructureKHR( DeferredOperationKHR                             deferredOperation,
                                                                      CopyMemoryToAccelerationStructureInfoKHR const & info,
                                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkWriteAccelerationStructuresPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteAccelerationStructuresPropertiesKHR.html
    VULKAN_HPP_NODISCARD Result
      writeAccelerationStructuresPropertiesKHR( uint32_t                         accelerationStructureCount,
                                                AccelerationStructureKHR const * pAccelerationStructures,
                                                QueryType                        queryType,
                                                size_t                           dataSize,
                                                void *                           pData,
                                                size_t                           stride,
                                                DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWriteAccelerationStructuresPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteAccelerationStructuresPropertiesKHR.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataType, DataTypeAllocator>>::type
      writeAccelerationStructuresPropertiesKHR( ArrayProxy<AccelerationStructureKHR const> const & accelerationStructures,
                                                QueryType                                          queryType,
                                                size_t                                             dataSize,
                                                size_t                                             stride,
                                                DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkWriteAccelerationStructuresPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteAccelerationStructuresPropertiesKHR.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      writeAccelerationStructuresPropertyKHR( ArrayProxy<AccelerationStructureKHR const> const & accelerationStructures,
                                              QueryType                                          queryType,
                                              size_t                                             stride,
                                              DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetAccelerationStructureDeviceAddressKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureDeviceAddressKHR.html
    DeviceAddress getAccelerationStructureAddressKHR( AccelerationStructureDeviceAddressInfoKHR const * pInfo,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetAccelerationStructureDeviceAddressKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureDeviceAddressKHR.html
    DeviceAddress getAccelerationStructureAddressKHR( AccelerationStructureDeviceAddressInfoKHR const & info,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceAccelerationStructureCompatibilityKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html
    void getAccelerationStructureCompatibilityKHR( AccelerationStructureVersionInfoKHR const * pVersionInfo,
                                                   AccelerationStructureCompatibilityKHR *     pCompatibility,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceAccelerationStructureCompatibilityKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html
    VULKAN_HPP_NODISCARD AccelerationStructureCompatibilityKHR getAccelerationStructureCompatibilityKHR(
      AccelerationStructureVersionInfoKHR const & versionInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetAccelerationStructureBuildSizesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html
    void getAccelerationStructureBuildSizesKHR( AccelerationStructureBuildTypeKHR                 buildType,
                                                AccelerationStructureBuildGeometryInfoKHR const * pBuildInfo,
                                                uint32_t const *                                  pMaxPrimitiveCounts,
                                                AccelerationStructureBuildSizesInfoKHR *          pSizeInfo,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetAccelerationStructureBuildSizesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureBuildSizesKHR.html
    VULKAN_HPP_NODISCARD AccelerationStructureBuildSizesInfoKHR
      getAccelerationStructureBuildSizesKHR( AccelerationStructureBuildTypeKHR                     buildType,
                                             AccelerationStructureBuildGeometryInfoKHR const &     buildInfo,
                                             ArrayProxy<uint32_t const> const & maxPrimitiveCounts VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_ray_tracing_pipeline ===

    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    VULKAN_HPP_NODISCARD Result createRayTracingPipelinesKHR( DeferredOperationKHR                    deferredOperation,
                                                              PipelineCache                           pipelineCache,
                                                              uint32_t                                createInfoCount,
                                                              RayTracingPipelineCreateInfoKHR const * pCreateInfos,
                                                              AllocationCallbacks const *             pAllocator,
                                                              Pipeline *                              pPipelines,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createRayTracingPipelinesKHR( DeferredOperationKHR                                      deferredOperation,
                                                       PipelineCache                                             pipelineCache,
                                                       ArrayProxy<RayTracingPipelineCreateInfoKHR const> const & createInfos,
                                                       Optional<AllocationCallbacks const> allocator             VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                       DispatchLoader const & d                                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createRayTracingPipelinesKHR( DeferredOperationKHR                                      deferredOperation,
                                                       PipelineCache                                             pipelineCache,
                                                       ArrayProxy<RayTracingPipelineCreateInfoKHR const> const & createInfos,
                                                       Optional<AllocationCallbacks const>                       allocator,
                                                       PipelineAllocator const &                                 pipelineAllocator,
                                                       DispatchLoader const & d                                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    VULKAN_HPP_NODISCARD ResultValue<Pipeline>
                         createRayTracingPipelineKHR( DeferredOperationKHR                          deferredOperation,
                                                      PipelineCache                                 pipelineCache,
                                                      RayTracingPipelineCreateInfoKHR const &       createInfo,
                                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createRayTracingPipelinesKHRUnique( DeferredOperationKHR                                      deferredOperation,
                                                             PipelineCache                                             pipelineCache,
                                                             ArrayProxy<RayTracingPipelineCreateInfoKHR const> const & createInfos,
                                                             Optional<AllocationCallbacks const> allocator             VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                             DispatchLoader const & d                                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createRayTracingPipelinesKHRUnique( DeferredOperationKHR                                      deferredOperation,
                                                             PipelineCache                                             pipelineCache,
                                                             ArrayProxy<RayTracingPipelineCreateInfoKHR const> const & createInfos,
                                                             Optional<AllocationCallbacks const>                       allocator,
                                                             PipelineAllocator const &                                 pipelineAllocator,
                                                             DispatchLoader const & d                                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesKHR.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<Pipeline>>
                         createRayTracingPipelineKHRUnique( DeferredOperationKHR                          deferredOperation,
                                                            PipelineCache                                 pipelineCache,
                                                            RayTracingPipelineCreateInfoKHR const &       createInfo,
                                                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRayTracingShaderGroupHandlesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesKHR.html
    VULKAN_HPP_NODISCARD Result
      getRayTracingShaderGroupHandlesKHR( Pipeline                 pipeline,
                                          uint32_t                 firstGroup,
                                          uint32_t                 groupCount,
                                          size_t                   dataSize,
                                          void *                   pData,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRayTracingShaderGroupHandlesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesKHR.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataType, DataTypeAllocator>>::type getRayTracingShaderGroupHandlesKHR(
      Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetRayTracingShaderGroupHandlesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesKHR.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type getRayTracingShaderGroupHandleKHR(
      Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html
    VULKAN_HPP_NODISCARD Result
      getRayTracingCaptureReplayShaderGroupHandlesKHR( Pipeline                 pipeline,
                                                       uint32_t                 firstGroup,
                                                       uint32_t                 groupCount,
                                                       size_t                   dataSize,
                                                       void *                   pData,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataType, DataTypeAllocator>>::type getRayTracingCaptureReplayShaderGroupHandlesKHR(
      Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type getRayTracingCaptureReplayShaderGroupHandleKHR(
      Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRayTracingShaderGroupStackSizeKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html
    DeviceSize getRayTracingShaderGroupStackSizeKHR( Pipeline                 pipeline,
                                                     uint32_t                 group,
                                                     ShaderGroupShaderKHR     groupShader,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_sampler_ycbcr_conversion ===

    // wrapper function for command vkCreateSamplerYcbcrConversionKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversionKHR.html
    VULKAN_HPP_NODISCARD Result createSamplerYcbcrConversionKHR( SamplerYcbcrConversionCreateInfo const * pCreateInfo,
                                                                 AllocationCallbacks const *              pAllocator,
                                                                 SamplerYcbcrConversion *                 pYcbcrConversion,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSamplerYcbcrConversionKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversionKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SamplerYcbcrConversion>::type
      createSamplerYcbcrConversionKHR( SamplerYcbcrConversionCreateInfo const &      createInfo,
                                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSamplerYcbcrConversionKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSamplerYcbcrConversionKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SamplerYcbcrConversion>>::type
      createSamplerYcbcrConversionKHRUnique( SamplerYcbcrConversionCreateInfo const &      createInfo,
                                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySamplerYcbcrConversionKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversionKHR.html
    void destroySamplerYcbcrConversionKHR( SamplerYcbcrConversion      ycbcrConversion,
                                           AllocationCallbacks const * pAllocator,
                                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySamplerYcbcrConversionKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySamplerYcbcrConversionKHR.html
    void destroySamplerYcbcrConversionKHR( SamplerYcbcrConversion ycbcrConversion        VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_bind_memory2 ===

    // wrapper function for command vkBindBufferMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2KHR.html
    VULKAN_HPP_NODISCARD Result bindBufferMemory2KHR( uint32_t                     bindInfoCount,
                                                      BindBufferMemoryInfo const * pBindInfos,
                                                      DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindBufferMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindBufferMemory2KHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindBufferMemory2KHR( ArrayProxy<BindBufferMemoryInfo const> const & bindInfos, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBindImageMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2KHR.html
    VULKAN_HPP_NODISCARD Result bindImageMemory2KHR( uint32_t                    bindInfoCount,
                                                     BindImageMemoryInfo const * pBindInfos,
                                                     DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindImageMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindImageMemory2KHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindImageMemory2KHR( ArrayProxy<BindImageMemoryInfo const> const & bindInfos, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_image_drm_format_modifier ===

    // wrapper function for command vkGetImageDrmFormatModifierPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html
    VULKAN_HPP_NODISCARD Result
      getImageDrmFormatModifierPropertiesEXT( Image                                 image,
                                              ImageDrmFormatModifierPropertiesEXT * pProperties,
                                              DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageDrmFormatModifierPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ImageDrmFormatModifierPropertiesEXT>::type
      getImageDrmFormatModifierPropertiesEXT( Image image, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_validation_cache ===

    // wrapper function for command vkCreateValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateValidationCacheEXT.html
    VULKAN_HPP_NODISCARD Result createValidationCacheEXT( ValidationCacheCreateInfoEXT const * pCreateInfo,
                                                          AllocationCallbacks const *          pAllocator,
                                                          ValidationCacheEXT *                 pValidationCache,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateValidationCacheEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ValidationCacheEXT>::type
      createValidationCacheEXT( ValidationCacheCreateInfoEXT const &          createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateValidationCacheEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<ValidationCacheEXT>>::type
      createValidationCacheEXTUnique( ValidationCacheCreateInfoEXT const &          createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyValidationCacheEXT.html
    void destroyValidationCacheEXT( ValidationCacheEXT          validationCache,
                                    AllocationCallbacks const * pAllocator,
                                    DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyValidationCacheEXT.html
    void destroyValidationCacheEXT( ValidationCacheEXT validationCache            VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyValidationCacheEXT.html
    void destroy( ValidationCacheEXT          validationCache,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyValidationCacheEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyValidationCacheEXT.html
    void destroy( ValidationCacheEXT                            validationCache,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkMergeValidationCachesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergeValidationCachesEXT.html
    VULKAN_HPP_NODISCARD Result mergeValidationCachesEXT( ValidationCacheEXT         dstCache,
                                                          uint32_t                   srcCacheCount,
                                                          ValidationCacheEXT const * pSrcCaches,
                                                          DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkMergeValidationCachesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMergeValidationCachesEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      mergeValidationCachesEXT( ValidationCacheEXT                           dstCache,
                                ArrayProxy<ValidationCacheEXT const> const & srcCaches,
                                DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetValidationCacheDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetValidationCacheDataEXT.html
    VULKAN_HPP_NODISCARD Result getValidationCacheDataEXT( ValidationCacheEXT       validationCache,
                                                           size_t *                 pDataSize,
                                                           void *                   pData,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetValidationCacheDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetValidationCacheDataEXT.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type
      getValidationCacheDataEXT( ValidationCacheEXT validationCache, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetValidationCacheDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetValidationCacheDataEXT.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type getValidationCacheDataEXT(
      ValidationCacheEXT validationCache, Uint8_tAllocator const & uint8_tAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_ray_tracing ===

    // wrapper function for command vkCreateAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureNV.html
    VULKAN_HPP_NODISCARD Result createAccelerationStructureNV( AccelerationStructureCreateInfoNV const * pCreateInfo,
                                                               AllocationCallbacks const *               pAllocator,
                                                               AccelerationStructureNV *                 pAccelerationStructure,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<AccelerationStructureNV>::type
      createAccelerationStructureNV( AccelerationStructureCreateInfoNV const &     createInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAccelerationStructureNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<AccelerationStructureNV>>::type
      createAccelerationStructureNVUnique( AccelerationStructureCreateInfoNV const &     createInfo,
                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureNV.html
    void destroyAccelerationStructureNV( AccelerationStructureNV     accelerationStructure,
                                         AllocationCallbacks const * pAllocator,
                                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureNV.html
    void destroyAccelerationStructureNV( AccelerationStructureNV accelerationStructure VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureNV.html
    void destroy( AccelerationStructureNV     accelerationStructure,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyAccelerationStructureNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyAccelerationStructureNV.html
    void destroy( AccelerationStructureNV                       accelerationStructure,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetAccelerationStructureMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html
    void getAccelerationStructureMemoryRequirementsNV( AccelerationStructureMemoryRequirementsInfoNV const * pInfo,
                                                       MemoryRequirements2KHR *                              pMemoryRequirements,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetAccelerationStructureMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html
    VULKAN_HPP_NODISCARD MemoryRequirements2KHR getAccelerationStructureMemoryRequirementsNV(
      AccelerationStructureMemoryRequirementsInfoNV const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetAccelerationStructureMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getAccelerationStructureMemoryRequirementsNV( AccelerationStructureMemoryRequirementsInfoNV const & info,
                                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBindAccelerationStructureMemoryNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindAccelerationStructureMemoryNV.html
    VULKAN_HPP_NODISCARD Result
      bindAccelerationStructureMemoryNV( uint32_t                                      bindInfoCount,
                                         BindAccelerationStructureMemoryInfoNV const * pBindInfos,
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindAccelerationStructureMemoryNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindAccelerationStructureMemoryNV.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindAccelerationStructureMemoryNV( ArrayProxy<BindAccelerationStructureMemoryInfoNV const> const & bindInfos,
                                         DispatchLoader const & d                                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    VULKAN_HPP_NODISCARD Result createRayTracingPipelinesNV( PipelineCache                          pipelineCache,
                                                             uint32_t                               createInfoCount,
                                                             RayTracingPipelineCreateInfoNV const * pCreateInfos,
                                                             AllocationCallbacks const *            pAllocator,
                                                             Pipeline *                             pPipelines,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createRayTracingPipelinesNV( PipelineCache                                            pipelineCache,
                                                      ArrayProxy<RayTracingPipelineCreateInfoNV const> const & createInfos,
                                                      Optional<AllocationCallbacks const> allocator            VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                      DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createRayTracingPipelinesNV( PipelineCache                                            pipelineCache,
                                                      ArrayProxy<RayTracingPipelineCreateInfoNV const> const & createInfos,
                                                      Optional<AllocationCallbacks const>                      allocator,
                                                      PipelineAllocator const &                                pipelineAllocator,
                                                      DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    VULKAN_HPP_NODISCARD ResultValue<Pipeline>
                         createRayTracingPipelineNV( PipelineCache                                 pipelineCache,
                                                     RayTracingPipelineCreateInfoNV const &        createInfo,
                                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createRayTracingPipelinesNVUnique( PipelineCache                                            pipelineCache,
                                                            ArrayProxy<RayTracingPipelineCreateInfoNV const> const & createInfos,
                                                            Optional<AllocationCallbacks const> allocator            VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                            DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createRayTracingPipelinesNVUnique( PipelineCache                                            pipelineCache,
                                                            ArrayProxy<RayTracingPipelineCreateInfoNV const> const & createInfos,
                                                            Optional<AllocationCallbacks const>                      allocator,
                                                            PipelineAllocator const &                                pipelineAllocator,
                                                            DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateRayTracingPipelinesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateRayTracingPipelinesNV.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<Pipeline>>
                         createRayTracingPipelineNVUnique( PipelineCache                                 pipelineCache,
                                                           RayTracingPipelineCreateInfoNV const &        createInfo,
                                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRayTracingShaderGroupHandlesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html
    VULKAN_HPP_NODISCARD Result
      getRayTracingShaderGroupHandlesNV( Pipeline                 pipeline,
                                         uint32_t                 firstGroup,
                                         uint32_t                 groupCount,
                                         size_t                   dataSize,
                                         void *                   pData,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRayTracingShaderGroupHandlesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataType, DataTypeAllocator>>::type getRayTracingShaderGroupHandlesNV(
      Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetRayTracingShaderGroupHandlesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRayTracingShaderGroupHandlesNV.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type getRayTracingShaderGroupHandleNV(
      Pipeline pipeline, uint32_t firstGroup, uint32_t groupCount, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetAccelerationStructureHandleNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureHandleNV.html
    VULKAN_HPP_NODISCARD Result getAccelerationStructureHandleNV( AccelerationStructureNV  accelerationStructure,
                                                                  size_t                   dataSize,
                                                                  void *                   pData,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetAccelerationStructureHandleNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureHandleNV.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataType, DataTypeAllocator>>::type getAccelerationStructureHandleNV(
      AccelerationStructureNV accelerationStructure, size_t dataSize, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetAccelerationStructureHandleNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureHandleNV.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getAccelerationStructureHandleNV( AccelerationStructureNV  accelerationStructure,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCompileDeferredNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCompileDeferredNV.html
    VULKAN_HPP_NODISCARD Result compileDeferredNV( Pipeline                 pipeline,
                                                   uint32_t                 shader,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkCompileDeferredNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCompileDeferredNV.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      compileDeferredNV( Pipeline pipeline, uint32_t shader, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    //=== VK_KHR_maintenance3 ===

    // wrapper function for command vkGetDescriptorSetLayoutSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupportKHR.html
    void getDescriptorSetLayoutSupportKHR( DescriptorSetLayoutCreateInfo const * pCreateInfo,
                                           DescriptorSetLayoutSupport *          pSupport,
                                           DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorSetLayoutSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupportKHR.html
    VULKAN_HPP_NODISCARD DescriptorSetLayoutSupport getDescriptorSetLayoutSupportKHR(
      DescriptorSetLayoutCreateInfo const & createInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDescriptorSetLayoutSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSupportKHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getDescriptorSetLayoutSupportKHR( DescriptorSetLayoutCreateInfo const & createInfo,
                                                           DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_external_memory_host ===

    // wrapper function for command vkGetMemoryHostPointerPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryHostPointerPropertiesEXT.html
    VULKAN_HPP_NODISCARD Result
      getMemoryHostPointerPropertiesEXT( ExternalMemoryHandleTypeFlagBits handleType,
                                         void const *                     pHostPointer,
                                         MemoryHostPointerPropertiesEXT * pMemoryHostPointerProperties,
                                         DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryHostPointerPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryHostPointerPropertiesEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<MemoryHostPointerPropertiesEXT>::type getMemoryHostPointerPropertiesEXT(
      ExternalMemoryHandleTypeFlagBits handleType, void const * pHostPointer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_calibrated_timestamps ===

    // wrapper function for command vkGetCalibratedTimestampsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsEXT.html
    VULKAN_HPP_NODISCARD Result getCalibratedTimestampsEXT( uint32_t                           timestampCount,
                                                            CalibratedTimestampInfoKHR const * pTimestampInfos,
                                                            uint64_t *                         pTimestamps,
                                                            uint64_t *                         pMaxDeviation,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetCalibratedTimestampsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsEXT.html
    template <typename Uint64_tAllocator = std::allocator<uint64_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<uint64_t, Uint64_tAllocator>, uint64_t>>::type
      getCalibratedTimestampsEXT( ArrayProxy<CalibratedTimestampInfoKHR const> const & timestampInfos,
                                  DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetCalibratedTimestampsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsEXT.html
    template <typename Uint64_tAllocator = std::allocator<uint64_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<uint64_t, Uint64_tAllocator>, uint64_t>>::type
      getCalibratedTimestampsEXT( ArrayProxy<CalibratedTimestampInfoKHR const> const & timestampInfos,
                                  Uint64_tAllocator const &                            uint64_tAllocator,
                                  DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetCalibratedTimestampsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<uint64_t, uint64_t>>::type
      getCalibratedTimestampEXT( CalibratedTimestampInfoKHR const & timestampInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_timeline_semaphore ===

    // wrapper function for command vkGetSemaphoreCounterValueKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValueKHR.html
    VULKAN_HPP_NODISCARD Result getSemaphoreCounterValueKHR( Semaphore                semaphore,
                                                             uint64_t *               pValue,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSemaphoreCounterValueKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreCounterValueKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<uint64_t>::type
      getSemaphoreCounterValueKHR( Semaphore semaphore, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkWaitSemaphoresKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphoresKHR.html
    VULKAN_HPP_NODISCARD Result waitSemaphoresKHR( SemaphoreWaitInfo const * pWaitInfo,
                                                   uint64_t                  timeout,
                                                   DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWaitSemaphoresKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitSemaphoresKHR.html
    VULKAN_HPP_NODISCARD Result waitSemaphoresKHR( SemaphoreWaitInfo const & waitInfo,
                                                   uint64_t                  timeout,
                                                   DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSignalSemaphoreKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphoreKHR.html
    VULKAN_HPP_NODISCARD Result signalSemaphoreKHR( SemaphoreSignalInfo const * pSignalInfo,
                                                    DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSignalSemaphoreKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSignalSemaphoreKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      signalSemaphoreKHR( SemaphoreSignalInfo const & signalInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_present_timing ===

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetSwapchainPresentTimingQueueSizeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetSwapchainPresentTimingQueueSizeEXT.html
    VULKAN_HPP_NODISCARD Result setSwapchainPresentTimingQueueSizeEXT(
      SwapchainKHR swapchain, uint32_t size, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkSetSwapchainPresentTimingQueueSizeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetSwapchainPresentTimingQueueSizeEXT.html
    VULKAN_HPP_NODISCARD Result setSwapchainPresentTimingQueueSizeEXT( SwapchainKHR             swapchain,
                                                                       uint32_t                 size,
                                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetSwapchainTimingPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainTimingPropertiesEXT.html
    VULKAN_HPP_NODISCARD Result getSwapchainTimingPropertiesEXT( SwapchainKHR                   swapchain,
                                                                 SwapchainTimingPropertiesEXT * pSwapchainTimingProperties,
                                                                 uint64_t *                     pSwapchainTimingPropertiesCounter,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSwapchainTimingPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainTimingPropertiesEXT.html
    VULKAN_HPP_NODISCARD ResultValue<std::pair<SwapchainTimingPropertiesEXT, uint64_t>>
                         getSwapchainTimingPropertiesEXT( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSwapchainTimeDomainPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSwapchainTimeDomainPropertiesEXT.html
    VULKAN_HPP_NODISCARD Result
      getSwapchainTimeDomainPropertiesEXT( SwapchainKHR                       swapchain,
                                           SwapchainTimeDomainPropertiesEXT * pSwapchainTimeDomainProperties,
                                           uint64_t *                         pTimeDomainsCounter,
                                           DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkGetPastPresentationTimingEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPastPresentationTimingEXT.html
    VULKAN_HPP_NODISCARD Result getPastPresentationTimingEXT( PastPresentationTimingInfoEXT const * pPastPresentationTimingInfo,
                                                              PastPresentationTimingPropertiesEXT * pPastPresentationTimingProperties,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_INTEL_performance_query ===

    // wrapper function for command vkInitializePerformanceApiINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkInitializePerformanceApiINTEL.html
    VULKAN_HPP_NODISCARD Result initializePerformanceApiINTEL( InitializePerformanceApiInfoINTEL const * pInitializeInfo,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkInitializePerformanceApiINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkInitializePerformanceApiINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      initializePerformanceApiINTEL( InitializePerformanceApiInfoINTEL const & initializeInfo,
                                     DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUninitializePerformanceApiINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUninitializePerformanceApiINTEL.html
    void uninitializePerformanceApiINTEL( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    // wrapper function for command vkAcquirePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquirePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD Result
      acquirePerformanceConfigurationINTEL( PerformanceConfigurationAcquireInfoINTEL const * pAcquireInfo,
                                            PerformanceConfigurationINTEL *                  pConfiguration,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquirePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquirePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PerformanceConfigurationINTEL>::type
      acquirePerformanceConfigurationINTEL( PerformanceConfigurationAcquireInfoINTEL const & acquireInfo,
                                            DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkAcquirePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquirePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<PerformanceConfigurationINTEL>>::type
      acquirePerformanceConfigurationINTELUnique( PerformanceConfigurationAcquireInfoINTEL const & acquireInfo,
                                                  DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleasePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleasePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD Result releasePerformanceConfigurationINTEL(
      PerformanceConfigurationINTEL configuration, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkReleasePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleasePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      releasePerformanceConfigurationINTEL( PerformanceConfigurationINTEL configuration VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                            DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleasePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleasePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD Result release( PerformanceConfigurationINTEL configuration,
                                         DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkReleasePerformanceConfigurationINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleasePerformanceConfigurationINTEL.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      release( PerformanceConfigurationINTEL configuration, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetPerformanceParameterINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPerformanceParameterINTEL.html
    VULKAN_HPP_NODISCARD Result getPerformanceParameterINTEL( PerformanceParameterTypeINTEL parameter,
                                                              PerformanceValueINTEL *       pValue,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPerformanceParameterINTEL, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPerformanceParameterINTEL.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PerformanceValueINTEL>::type
      getPerformanceParameterINTEL( PerformanceParameterTypeINTEL parameter, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_AMD_display_native_hdr ===

    // wrapper function for command vkSetLocalDimmingAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLocalDimmingAMD.html
    void setLocalDimmingAMD( SwapchainKHR             swapChain,
                             Bool32                   localDimmingEnable,
                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_buffer_device_address ===

    // wrapper function for command vkGetBufferDeviceAddressEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressEXT.html
    DeviceAddress getBufferAddressEXT( BufferDeviceAddressInfo const * pInfo,
                                       DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferDeviceAddressEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressEXT.html
    DeviceAddress getBufferAddressEXT( BufferDeviceAddressInfo const & info,
                                       DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_present_wait ===

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWaitForPresentKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresentKHR.html
    VULKAN_HPP_NODISCARD Result waitForPresentKHR( SwapchainKHR             swapchain,
                                                   uint64_t                 presentId,
                                                   uint64_t                 timeout,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkWaitForPresentKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresentKHR.html
    VULKAN_HPP_NODISCARD Result waitForPresentKHR( SwapchainKHR             swapchain,
                                                   uint64_t                 presentId,
                                                   uint64_t                 timeout,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_EXT_full_screen_exclusive ===

#  ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireFullScreenExclusiveModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireFullScreenExclusiveModeEXT.html
    VULKAN_HPP_NODISCARD Result
      acquireFullScreenExclusiveModeEXT( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  else
    // wrapper function for command vkAcquireFullScreenExclusiveModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireFullScreenExclusiveModeEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      acquireFullScreenExclusiveModeEXT( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#  ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleaseFullScreenExclusiveModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseFullScreenExclusiveModeEXT.html
    VULKAN_HPP_NODISCARD Result
      releaseFullScreenExclusiveModeEXT( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  else
    // wrapper function for command vkReleaseFullScreenExclusiveModeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseFullScreenExclusiveModeEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      releaseFullScreenExclusiveModeEXT( SwapchainKHR swapchain, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetDeviceGroupSurfacePresentModes2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupSurfacePresentModes2EXT.html
    VULKAN_HPP_NODISCARD Result getGroupSurfacePresentModes2EXT( PhysicalDeviceSurfaceInfo2KHR const * pSurfaceInfo,
                                                                 DeviceGroupPresentModeFlagsKHR *      pModes,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceGroupSurfacePresentModes2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceGroupSurfacePresentModes2EXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DeviceGroupPresentModeFlagsKHR>::type
      getGroupSurfacePresentModes2EXT( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo,
                                       DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_KHR_buffer_device_address ===

    // wrapper function for command vkGetBufferDeviceAddressKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressKHR.html
    DeviceAddress getBufferAddressKHR( BufferDeviceAddressInfo const * pInfo,
                                       DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferDeviceAddressKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferDeviceAddressKHR.html
    DeviceAddress getBufferAddressKHR( BufferDeviceAddressInfo const & info,
                                       DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferOpaqueCaptureAddressKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddressKHR.html
    uint64_t getBufferOpaqueCaptureAddressKHR( BufferDeviceAddressInfo const * pInfo,
                                               DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferOpaqueCaptureAddressKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureAddressKHR.html
    uint64_t getBufferOpaqueCaptureAddressKHR( BufferDeviceAddressInfo const & info,
                                               DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceMemoryOpaqueCaptureAddressKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddressKHR.html
    uint64_t getMemoryOpaqueCaptureAddressKHR( DeviceMemoryOpaqueCaptureAddressInfo const * pInfo,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceMemoryOpaqueCaptureAddressKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMemoryOpaqueCaptureAddressKHR.html
    uint64_t getMemoryOpaqueCaptureAddressKHR( DeviceMemoryOpaqueCaptureAddressInfo const & info,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_host_query_reset ===

    // wrapper function for command vkResetQueryPoolEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkResetQueryPoolEXT.html
    void resetQueryPoolEXT( QueryPool                queryPool,
                            uint32_t                 firstQuery,
                            uint32_t                 queryCount,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_deferred_host_operations ===

    // wrapper function for command vkCreateDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDeferredOperationKHR.html
    VULKAN_HPP_NODISCARD Result createDeferredOperationKHR( AllocationCallbacks const * pAllocator,
                                                            DeferredOperationKHR *      pDeferredOperation,
                                                            DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDeferredOperationKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DeferredOperationKHR>::type
      createDeferredOperationKHR( Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDeferredOperationKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DeferredOperationKHR>>::type
      createDeferredOperationKHRUnique( Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDeferredOperationKHR.html
    void destroyDeferredOperationKHR( DeferredOperationKHR        operation,
                                      AllocationCallbacks const * pAllocator,
                                      DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDeferredOperationKHR.html
    void destroyDeferredOperationKHR( DeferredOperationKHR operation                VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDeferredOperationKHR.html
    void destroy( DeferredOperationKHR        operation,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDeferredOperationKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDeferredOperationKHR.html
    void destroy( DeferredOperationKHR                          operation,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeferredOperationMaxConcurrencyKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html
    uint32_t getDeferredOperationMaxConcurrencyKHR( DeferredOperationKHR     operation,
                                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeferredOperationResultKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeferredOperationResultKHR.html
    VULKAN_HPP_NODISCARD Result getDeferredOperationResultKHR( DeferredOperationKHR     operation,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkGetDeferredOperationResultKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeferredOperationResultKHR.html
    VULKAN_HPP_NODISCARD Result getDeferredOperationResultKHR( DeferredOperationKHR     operation,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDeferredOperationJoinKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeferredOperationJoinKHR.html
    VULKAN_HPP_NODISCARD Result deferredOperationJoinKHR( DeferredOperationKHR     operation,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkDeferredOperationJoinKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDeferredOperationJoinKHR.html
    VULKAN_HPP_NODISCARD Result deferredOperationJoinKHR( DeferredOperationKHR     operation,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    //=== VK_KHR_pipeline_executable_properties ===

    // wrapper function for command vkGetPipelineExecutablePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutablePropertiesKHR.html
    VULKAN_HPP_NODISCARD Result
      getPipelineExecutablePropertiesKHR( PipelineInfoKHR const *           pPipelineInfo,
                                          uint32_t *                        pExecutableCount,
                                          PipelineExecutablePropertiesKHR * pProperties,
                                          DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineExecutablePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutablePropertiesKHR.html
    template <typename PipelineExecutablePropertiesKHRAllocator = std::allocator<PipelineExecutablePropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PipelineExecutablePropertiesKHR, PipelineExecutablePropertiesKHRAllocator>>::type
      getPipelineExecutablePropertiesKHR( PipelineInfoKHR const & pipelineInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPipelineExecutablePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutablePropertiesKHR.html
    template <typename PipelineExecutablePropertiesKHRAllocator = std::allocator<PipelineExecutablePropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PipelineExecutablePropertiesKHR, PipelineExecutablePropertiesKHRAllocator>>::type
      getPipelineExecutablePropertiesKHR( PipelineInfoKHR const &                          pipelineInfo,
                                          PipelineExecutablePropertiesKHRAllocator const & pipelineExecutablePropertiesKHRAllocator,
                                          DispatchLoader const & d                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPipelineExecutableStatisticsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutableStatisticsKHR.html
    VULKAN_HPP_NODISCARD Result
      getPipelineExecutableStatisticsKHR( PipelineExecutableInfoKHR const * pExecutableInfo,
                                          uint32_t *                        pStatisticCount,
                                          PipelineExecutableStatisticKHR *  pStatistics,
                                          DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineExecutableStatisticsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutableStatisticsKHR.html
    template <typename PipelineExecutableStatisticKHRAllocator = std::allocator<PipelineExecutableStatisticKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PipelineExecutableStatisticKHR, PipelineExecutableStatisticKHRAllocator>>::type
      getPipelineExecutableStatisticsKHR( PipelineExecutableInfoKHR const & executableInfo,
                                          DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPipelineExecutableStatisticsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutableStatisticsKHR.html
    template <typename PipelineExecutableStatisticKHRAllocator = std::allocator<PipelineExecutableStatisticKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PipelineExecutableStatisticKHR, PipelineExecutableStatisticKHRAllocator>>::type
      getPipelineExecutableStatisticsKHR( PipelineExecutableInfoKHR const &               executableInfo,
                                          PipelineExecutableStatisticKHRAllocator const & pipelineExecutableStatisticKHRAllocator,
                                          DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPipelineExecutableInternalRepresentationsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html
    VULKAN_HPP_NODISCARD Result
      getPipelineExecutableInternalRepresentationsKHR( PipelineExecutableInfoKHR const *             pExecutableInfo,
                                                       uint32_t *                                    pInternalRepresentationCount,
                                                       PipelineExecutableInternalRepresentationKHR * pInternalRepresentations,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_host_image_copy ===

    // wrapper function for command vkCopyMemoryToImageEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImageEXT.html
    VULKAN_HPP_NODISCARD Result copyMemoryToImageEXT( CopyMemoryToImageInfo const * pCopyMemoryToImageInfo,
                                                      DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyMemoryToImageEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToImageEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      copyMemoryToImageEXT( CopyMemoryToImageInfo const & copyMemoryToImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyImageToMemoryEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemoryEXT.html
    VULKAN_HPP_NODISCARD Result copyImageToMemoryEXT( CopyImageToMemoryInfo const * pCopyImageToMemoryInfo,
                                                      DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyImageToMemoryEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToMemoryEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      copyImageToMemoryEXT( CopyImageToMemoryInfo const & copyImageToMemoryInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyImageToImageEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImageEXT.html
    VULKAN_HPP_NODISCARD Result copyImageToImageEXT( CopyImageToImageInfo const * pCopyImageToImageInfo,
                                                     DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyImageToImageEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyImageToImageEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      copyImageToImageEXT( CopyImageToImageInfo const & copyImageToImageInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkTransitionImageLayoutEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayoutEXT.html
    VULKAN_HPP_NODISCARD Result transitionImageLayoutEXT( uint32_t                              transitionCount,
                                                          HostImageLayoutTransitionInfo const * pTransitions,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkTransitionImageLayoutEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkTransitionImageLayoutEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      transitionImageLayoutEXT( ArrayProxy<HostImageLayoutTransitionInfo const> const & transitions,
                                DispatchLoader const & d                                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSubresourceLayout2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2EXT.html
    void getImageSubresourceLayout2EXT( Image                     image,
                                        ImageSubresource2 const * pSubresource,
                                        SubresourceLayout2 *      pLayout,
                                        DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSubresourceLayout2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2EXT.html
    VULKAN_HPP_NODISCARD SubresourceLayout2 getImageSubresourceLayout2EXT(
      Image image, ImageSubresource2 const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetImageSubresourceLayout2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2EXT.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...> getImageSubresourceLayout2EXT(
      Image image, ImageSubresource2 const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_map_memory2 ===

    // wrapper function for command vkMapMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2KHR.html
    VULKAN_HPP_NODISCARD Result mapMemory2KHR( MemoryMapInfo const *    pMemoryMapInfo,
                                               void **                  ppData,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkMapMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkMapMemory2KHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<void *>::type mapMemory2KHR( MemoryMapInfo const &    memoryMapInfo,
                                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUnmapMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2KHR.html
    VULKAN_HPP_NODISCARD Result unmapMemory2KHR( MemoryUnmapInfo const *  pMemoryUnmapInfo,
                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUnmapMemory2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkUnmapMemory2KHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      unmapMemory2KHR( MemoryUnmapInfo const & memoryUnmapInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_swapchain_maintenance1 ===

    // wrapper function for command vkReleaseSwapchainImagesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesEXT.html
    VULKAN_HPP_NODISCARD Result releaseSwapchainImagesEXT( ReleaseSwapchainImagesInfoKHR const * pReleaseInfo,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleaseSwapchainImagesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      releaseSwapchainImagesEXT( ReleaseSwapchainImagesInfoKHR const & releaseInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_device_generated_commands ===

    // wrapper function for command vkGetGeneratedCommandsMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html
    void getGeneratedCommandsMemoryRequirementsNV( GeneratedCommandsMemoryRequirementsInfoNV const * pInfo,
                                                   MemoryRequirements2 *                             pMemoryRequirements,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetGeneratedCommandsMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getGeneratedCommandsMemoryRequirementsNV(
      GeneratedCommandsMemoryRequirementsInfoNV const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetGeneratedCommandsMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getGeneratedCommandsMemoryRequirementsNV( GeneratedCommandsMemoryRequirementsInfoNV const & info,
                                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutNV.html
    VULKAN_HPP_NODISCARD Result createIndirectCommandsLayoutNV( IndirectCommandsLayoutCreateInfoNV const * pCreateInfo,
                                                                AllocationCallbacks const *                pAllocator,
                                                                IndirectCommandsLayoutNV *                 pIndirectCommandsLayout,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<IndirectCommandsLayoutNV>::type
      createIndirectCommandsLayoutNV( IndirectCommandsLayoutCreateInfoNV const &    createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<IndirectCommandsLayoutNV>>::type
      createIndirectCommandsLayoutNVUnique( IndirectCommandsLayoutCreateInfoNV const &    createInfo,
                                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutNV.html
    void destroyIndirectCommandsLayoutNV( IndirectCommandsLayoutNV    indirectCommandsLayout,
                                          AllocationCallbacks const * pAllocator,
                                          DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutNV.html
    void destroyIndirectCommandsLayoutNV( IndirectCommandsLayoutNV indirectCommandsLayout VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                          Optional<AllocationCallbacks const> allocator   VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutNV.html
    void destroy( IndirectCommandsLayoutNV    indirectCommandsLayout,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyIndirectCommandsLayoutNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutNV.html
    void destroy( IndirectCommandsLayoutNV                      indirectCommandsLayout,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_private_data ===

    // wrapper function for command vkCreatePrivateDataSlotEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlotEXT.html
    VULKAN_HPP_NODISCARD Result createPrivateDataSlotEXT( PrivateDataSlotCreateInfo const * pCreateInfo,
                                                          AllocationCallbacks const *       pAllocator,
                                                          PrivateDataSlot *                 pPrivateDataSlot,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreatePrivateDataSlotEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlotEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PrivateDataSlot>::type
      createPrivateDataSlotEXT( PrivateDataSlotCreateInfo const &             createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreatePrivateDataSlotEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePrivateDataSlotEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<PrivateDataSlot>>::type
      createPrivateDataSlotEXTUnique( PrivateDataSlotCreateInfo const &             createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPrivateDataSlotEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlotEXT.html
    void destroyPrivateDataSlotEXT( PrivateDataSlot             privateDataSlot,
                                    AllocationCallbacks const * pAllocator,
                                    DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPrivateDataSlotEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPrivateDataSlotEXT.html
    void destroyPrivateDataSlotEXT( PrivateDataSlot privateDataSlot               VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetPrivateDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateDataEXT.html
    VULKAN_HPP_NODISCARD Result setPrivateDataEXT( ObjectType               objectType,
                                                   uint64_t                 objectHandle,
                                                   PrivateDataSlot          privateDataSlot,
                                                   uint64_t                 data,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkSetPrivateDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetPrivateDataEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setPrivateDataEXT( ObjectType               objectType,
                         uint64_t                 objectHandle,
                         PrivateDataSlot          privateDataSlot,
                         uint64_t                 data,
                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetPrivateDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateDataEXT.html
    void getPrivateDataEXT( ObjectType               objectType,
                            uint64_t                 objectHandle,
                            PrivateDataSlot          privateDataSlot,
                            uint64_t *               pData,
                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPrivateDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPrivateDataEXT.html
    VULKAN_HPP_NODISCARD uint64_t getPrivateDataEXT( ObjectType               objectType,
                                                     uint64_t                 objectHandle,
                                                     PrivateDataSlot          privateDataSlot,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_video_encode_queue ===

    // wrapper function for command vkGetEncodedVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEncodedVideoSessionParametersKHR.html
    VULKAN_HPP_NODISCARD Result
      getEncodedVideoSessionParametersKHR( VideoEncodeSessionParametersGetInfoKHR const * pVideoSessionParametersInfo,
                                           VideoEncodeSessionParametersFeedbackInfoKHR *  pFeedbackInfo,
                                           size_t *                                       pDataSize,
                                           void *                                         pData,
                                           DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetEncodedVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEncodedVideoSessionParametersKHR.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<VideoEncodeSessionParametersFeedbackInfoKHR, std::vector<uint8_t, Uint8_tAllocator>>>::type
      getEncodedVideoSessionParametersKHR( VideoEncodeSessionParametersGetInfoKHR const & videoSessionParametersInfo,
                                           DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetEncodedVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEncodedVideoSessionParametersKHR.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<VideoEncodeSessionParametersFeedbackInfoKHR, std::vector<uint8_t, Uint8_tAllocator>>>::type
      getEncodedVideoSessionParametersKHR( VideoEncodeSessionParametersGetInfoKHR const & videoSessionParametersInfo,
                                           Uint8_tAllocator const &                       uint8_tAllocator,
                                           DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetEncodedVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEncodedVideoSessionParametersKHR.html
    template <typename X, typename Y, typename... Z, typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<StructureChain<X, Y, Z...>, std::vector<uint8_t, Uint8_tAllocator>>>::type
      getEncodedVideoSessionParametersKHR( VideoEncodeSessionParametersGetInfoKHR const & videoSessionParametersInfo,
                                           DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetEncodedVideoSessionParametersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetEncodedVideoSessionParametersKHR.html
    template <typename X, typename Y, typename... Z, typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<StructureChain<X, Y, Z...>, std::vector<uint8_t, Uint8_tAllocator>>>::type
      getEncodedVideoSessionParametersKHR( VideoEncodeSessionParametersGetInfoKHR const & videoSessionParametersInfo,
                                           Uint8_tAllocator const &                       uint8_tAllocator,
                                           DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_ENABLE_BETA_EXTENSIONS )
    //=== VK_NV_cuda_kernel_launch ===

    // wrapper function for command vkCreateCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCudaModuleNV.html
    VULKAN_HPP_NODISCARD Result createCudaModuleNV( CudaModuleCreateInfoNV const * pCreateInfo,
                                                    AllocationCallbacks const *    pAllocator,
                                                    CudaModuleNV *                 pModule,
                                                    DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCudaModuleNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<CudaModuleNV>::type
      createCudaModuleNV( CudaModuleCreateInfoNV const &                createInfo,
                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCudaModuleNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<CudaModuleNV>>::type
      createCudaModuleNVUnique( CudaModuleCreateInfoNV const &                createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetCudaModuleCacheNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCudaModuleCacheNV.html
    VULKAN_HPP_NODISCARD Result getCudaModuleCacheNV( CudaModuleNV             module,
                                                      size_t *                 pCacheSize,
                                                      void *                   pCacheData,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetCudaModuleCacheNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCudaModuleCacheNV.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type
      getCudaModuleCacheNV( CudaModuleNV module, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetCudaModuleCacheNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCudaModuleCacheNV.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type getCudaModuleCacheNV(
      CudaModuleNV module, Uint8_tAllocator const & uint8_tAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCudaFunctionNV.html
    VULKAN_HPP_NODISCARD Result createCudaFunctionNV( CudaFunctionCreateInfoNV const * pCreateInfo,
                                                      AllocationCallbacks const *      pAllocator,
                                                      CudaFunctionNV *                 pFunction,
                                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCudaFunctionNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<CudaFunctionNV>::type
      createCudaFunctionNV( CudaFunctionCreateInfoNV const &              createInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateCudaFunctionNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<CudaFunctionNV>>::type
      createCudaFunctionNVUnique( CudaFunctionCreateInfoNV const &              createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaModuleNV.html
    void destroyCudaModuleNV( CudaModuleNV                module,
                              AllocationCallbacks const * pAllocator,
                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaModuleNV.html
    void destroyCudaModuleNV( CudaModuleNV                                  module,
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaModuleNV.html
    void destroy( CudaModuleNV                module,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCudaModuleNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaModuleNV.html
    void destroy( CudaModuleNV                                  module,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaFunctionNV.html
    void destroyCudaFunctionNV( CudaFunctionNV              function,
                                AllocationCallbacks const * pAllocator,
                                DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaFunctionNV.html
    void destroyCudaFunctionNV( CudaFunctionNV                                function,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaFunctionNV.html
    void destroy( CudaFunctionNV              function,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyCudaFunctionNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyCudaFunctionNV.html
    void destroy( CudaFunctionNV                                function,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_ENABLE_BETA_EXTENSIONS*/

#if defined( VK_USE_PLATFORM_METAL_EXT )
    //=== VK_EXT_metal_objects ===

    // wrapper function for command vkExportMetalObjectsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkExportMetalObjectsEXT.html
    void exportMetalObjectsEXT( ExportMetalObjectsInfoEXT * pMetalObjectsInfo,
                                DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkExportMetalObjectsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkExportMetalObjectsEXT.html
    void exportMetalObjectsEXT( ExportMetalObjectsInfoEXT & metalObjectsInfo,
                                DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_METAL_EXT*/

    //=== VK_EXT_descriptor_buffer ===

    // wrapper function for command vkGetDescriptorSetLayoutSizeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSizeEXT.html
    void getDescriptorSetLayoutSizeEXT( DescriptorSetLayout      layout,
                                        DeviceSize *             pLayoutSizeInBytes,
                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorSetLayoutSizeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutSizeEXT.html
    VULKAN_HPP_NODISCARD DeviceSize
      getDescriptorSetLayoutSizeEXT( DescriptorSetLayout layout, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDescriptorSetLayoutBindingOffsetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html
    void getDescriptorSetLayoutBindingOffsetEXT( DescriptorSetLayout      layout,
                                                 uint32_t                 binding,
                                                 DeviceSize *             pOffset,
                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorSetLayoutBindingOffsetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html
    VULKAN_HPP_NODISCARD DeviceSize getDescriptorSetLayoutBindingOffsetEXT(
      DescriptorSetLayout layout, uint32_t binding, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDescriptorEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorEXT.html
    void getDescriptorEXT( DescriptorGetInfoEXT const * pDescriptorInfo,
                           size_t                       dataSize,
                           void *                       pDescriptor,
                           DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorEXT.html
    void getDescriptorEXT( DescriptorGetInfoEXT const & descriptorInfo,
                           size_t                       dataSize,
                           void *                       pDescriptor,
                           DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDescriptorEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorEXT.html
    template <typename DescriptorType>
    VULKAN_HPP_NODISCARD DescriptorType getDescriptorEXT( DescriptorGetInfoEXT const & descriptorInfo,
                                                          DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html
    VULKAN_HPP_NODISCARD Result
      getBufferOpaqueCaptureDescriptorDataEXT( BufferCaptureDescriptorDataInfoEXT const * pInfo,
                                               void *                                     pData,
                                               DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getBufferOpaqueCaptureDescriptorDataEXT( BufferCaptureDescriptorDataInfoEXT const & info,
                                               DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html
    VULKAN_HPP_NODISCARD Result
      getImageOpaqueCaptureDescriptorDataEXT( ImageCaptureDescriptorDataInfoEXT const * pInfo,
                                              void *                                    pData,
                                              DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getImageOpaqueCaptureDescriptorDataEXT( ImageCaptureDescriptorDataInfoEXT const & info,
                                              DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageViewOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html
    VULKAN_HPP_NODISCARD Result
      getImageViewOpaqueCaptureDescriptorDataEXT( ImageViewCaptureDescriptorDataInfoEXT const * pInfo,
                                                  void *                                        pData,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageViewOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getImageViewOpaqueCaptureDescriptorDataEXT( ImageViewCaptureDescriptorDataInfoEXT const & info,
                                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSamplerOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html
    VULKAN_HPP_NODISCARD Result
      getSamplerOpaqueCaptureDescriptorDataEXT( SamplerCaptureDescriptorDataInfoEXT const * pInfo,
                                                void *                                      pData,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSamplerOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getSamplerOpaqueCaptureDescriptorDataEXT( SamplerCaptureDescriptorDataInfoEXT const & info,
                                                DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html
    VULKAN_HPP_NODISCARD Result
      getAccelerationStructureOpaqueCaptureDescriptorDataEXT( AccelerationStructureCaptureDescriptorDataInfoEXT const * pInfo,
                                                              void *                                                    pData,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getAccelerationStructureOpaqueCaptureDescriptorDataEXT( AccelerationStructureCaptureDescriptorDataInfoEXT const & info,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_device_fault ===

    // wrapper function for command vkGetDeviceFaultInfoEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceFaultInfoEXT.html
    VULKAN_HPP_NODISCARD Result getFaultInfoEXT( DeviceFaultCountsEXT *   pFaultCounts,
                                                 DeviceFaultInfoEXT *     pFaultInfo,
                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

#if defined( VK_USE_PLATFORM_FUCHSIA )
    //=== VK_FUCHSIA_external_memory ===

    // wrapper function for command vkGetMemoryZirconHandleFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryZirconHandleFUCHSIA.html
    VULKAN_HPP_NODISCARD Result getMemoryZirconHandleFUCHSIA( MemoryGetZirconHandleInfoFUCHSIA const * pGetZirconHandleInfo,
                                                              zx_handle_t *                            pZirconHandle,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryZirconHandleFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryZirconHandleFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<zx_handle_t>::type
      getMemoryZirconHandleFUCHSIA( MemoryGetZirconHandleInfoFUCHSIA const & getZirconHandleInfo,
                                    DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMemoryZirconHandlePropertiesFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryZirconHandlePropertiesFUCHSIA.html
    VULKAN_HPP_NODISCARD Result
      getMemoryZirconHandlePropertiesFUCHSIA( ExternalMemoryHandleTypeFlagBits      handleType,
                                              zx_handle_t                           zirconHandle,
                                              MemoryZirconHandlePropertiesFUCHSIA * pMemoryZirconHandleProperties,
                                              DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryZirconHandlePropertiesFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryZirconHandlePropertiesFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<MemoryZirconHandlePropertiesFUCHSIA>::type getMemoryZirconHandlePropertiesFUCHSIA(
      ExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
    //=== VK_FUCHSIA_external_semaphore ===

    // wrapper function for command vkImportSemaphoreZirconHandleFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreZirconHandleFUCHSIA.html
    VULKAN_HPP_NODISCARD Result
      importSemaphoreZirconHandleFUCHSIA( ImportSemaphoreZirconHandleInfoFUCHSIA const * pImportSemaphoreZirconHandleInfo,
                                          DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkImportSemaphoreZirconHandleFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkImportSemaphoreZirconHandleFUCHSIA.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      importSemaphoreZirconHandleFUCHSIA( ImportSemaphoreZirconHandleInfoFUCHSIA const & importSemaphoreZirconHandleInfo,
                                          DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetSemaphoreZirconHandleFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreZirconHandleFUCHSIA.html
    VULKAN_HPP_NODISCARD Result getSemaphoreZirconHandleFUCHSIA( SemaphoreGetZirconHandleInfoFUCHSIA const * pGetZirconHandleInfo,
                                                                 zx_handle_t *                               pZirconHandle,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetSemaphoreZirconHandleFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetSemaphoreZirconHandleFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<zx_handle_t>::type
      getSemaphoreZirconHandleFUCHSIA( SemaphoreGetZirconHandleInfoFUCHSIA const & getZirconHandleInfo,
                                       DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_FUCHSIA )
    //=== VK_FUCHSIA_buffer_collection ===

    // wrapper function for command vkCreateBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferCollectionFUCHSIA.html
    VULKAN_HPP_NODISCARD Result createBufferCollectionFUCHSIA( BufferCollectionCreateInfoFUCHSIA const * pCreateInfo,
                                                               AllocationCallbacks const *               pAllocator,
                                                               BufferCollectionFUCHSIA *                 pCollection,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferCollectionFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<BufferCollectionFUCHSIA>::type
      createBufferCollectionFUCHSIA( BufferCollectionCreateInfoFUCHSIA const &     createInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateBufferCollectionFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<BufferCollectionFUCHSIA>>::type
      createBufferCollectionFUCHSIAUnique( BufferCollectionCreateInfoFUCHSIA const &     createInfo,
                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSetBufferCollectionImageConstraintsFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetBufferCollectionImageConstraintsFUCHSIA.html
    VULKAN_HPP_NODISCARD Result
      setBufferCollectionImageConstraintsFUCHSIA( BufferCollectionFUCHSIA             collection,
                                                  ImageConstraintsInfoFUCHSIA const * pImageConstraintsInfo,
                                                  DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetBufferCollectionImageConstraintsFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetBufferCollectionImageConstraintsFUCHSIA.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setBufferCollectionImageConstraintsFUCHSIA( BufferCollectionFUCHSIA             collection,
                                                  ImageConstraintsInfoFUCHSIA const & imageConstraintsInfo,
                                                  DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSetBufferCollectionBufferConstraintsFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetBufferCollectionBufferConstraintsFUCHSIA.html
    VULKAN_HPP_NODISCARD Result
      setBufferCollectionBufferConstraintsFUCHSIA( BufferCollectionFUCHSIA              collection,
                                                   BufferConstraintsInfoFUCHSIA const * pBufferConstraintsInfo,
                                                   DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetBufferCollectionBufferConstraintsFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetBufferCollectionBufferConstraintsFUCHSIA.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      setBufferCollectionBufferConstraintsFUCHSIA( BufferCollectionFUCHSIA              collection,
                                                   BufferConstraintsInfoFUCHSIA const & bufferConstraintsInfo,
                                                   DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferCollectionFUCHSIA.html
    void destroyBufferCollectionFUCHSIA( BufferCollectionFUCHSIA     collection,
                                         AllocationCallbacks const * pAllocator,
                                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferCollectionFUCHSIA.html
    void destroyBufferCollectionFUCHSIA( BufferCollectionFUCHSIA                       collection,
                                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferCollectionFUCHSIA.html
    void destroy( BufferCollectionFUCHSIA     collection,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyBufferCollectionFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyBufferCollectionFUCHSIA.html
    void destroy( BufferCollectionFUCHSIA                       collection,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetBufferCollectionPropertiesFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferCollectionPropertiesFUCHSIA.html
    VULKAN_HPP_NODISCARD Result
      getBufferCollectionPropertiesFUCHSIA( BufferCollectionFUCHSIA             collection,
                                            BufferCollectionPropertiesFUCHSIA * pProperties,
                                            DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetBufferCollectionPropertiesFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetBufferCollectionPropertiesFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<BufferCollectionPropertiesFUCHSIA>::type
      getBufferCollectionPropertiesFUCHSIA( BufferCollectionFUCHSIA collection, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_FUCHSIA*/

    //=== VK_HUAWEI_subpass_shading ===

    // wrapper function for command vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html
    VULKAN_HPP_NODISCARD Result getSubpassShadingMaxWorkgroupSizeHUAWEI(
      RenderPass renderpass, Extent2D * pMaxWorkgroupSize, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Extent2D>::type
      getSubpassShadingMaxWorkgroupSizeHUAWEI( RenderPass renderpass, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_external_memory_rdma ===

    // wrapper function for command vkGetMemoryRemoteAddressNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryRemoteAddressNV.html
    VULKAN_HPP_NODISCARD Result getMemoryRemoteAddressNV( MemoryGetRemoteAddressInfoNV const * pMemoryGetRemoteAddressInfo,
                                                          RemoteAddressNV *                    pAddress,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryRemoteAddressNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryRemoteAddressNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<RemoteAddressNV>::type
      getMemoryRemoteAddressNV( MemoryGetRemoteAddressInfoNV const & memoryGetRemoteAddressInfo,
                                DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_pipeline_properties ===

    // wrapper function for command vkGetPipelinePropertiesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelinePropertiesEXT.html
    VULKAN_HPP_NODISCARD Result getPipelinePropertiesEXT( PipelineInfoEXT const *  pPipelineInfo,
                                                          BaseOutStructure *       pPipelineProperties,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelinePropertiesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelinePropertiesEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<BaseOutStructure>::type
      getPipelinePropertiesEXT( PipelineInfoEXT const & pipelineInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_opacity_micromap ===

    // wrapper function for command vkCreateMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMicromapEXT.html
    VULKAN_HPP_NODISCARD Result createMicromapEXT( MicromapCreateInfoEXT const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   MicromapEXT *                 pMicromap,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMicromapEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<MicromapEXT>::type
      createMicromapEXT( MicromapCreateInfoEXT const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMicromapEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<MicromapEXT>>::type
      createMicromapEXTUnique( MicromapCreateInfoEXT const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyMicromapEXT.html
    void destroyMicromapEXT( MicromapEXT                 micromap,
                             AllocationCallbacks const * pAllocator,
                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyMicromapEXT.html
    void destroyMicromapEXT( MicromapEXT micromap                          VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyMicromapEXT.html
    void destroy( MicromapEXT                 micromap,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyMicromapEXT.html
    void destroy( MicromapEXT                                   micromap,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBuildMicromapsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBuildMicromapsEXT.html
    VULKAN_HPP_NODISCARD Result buildMicromapsEXT( DeferredOperationKHR         deferredOperation,
                                                   uint32_t                     infoCount,
                                                   MicromapBuildInfoEXT const * pInfos,
                                                   DispatchLoader const & d     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBuildMicromapsEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBuildMicromapsEXT.html
    VULKAN_HPP_NODISCARD Result buildMicromapsEXT( DeferredOperationKHR                           deferredOperation,
                                                   ArrayProxy<MicromapBuildInfoEXT const> const & infos,
                                                   DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMicromapEXT.html
    VULKAN_HPP_NODISCARD Result copyMicromapEXT( DeferredOperationKHR        deferredOperation,
                                                 CopyMicromapInfoEXT const * pInfo,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMicromapEXT.html
    VULKAN_HPP_NODISCARD Result copyMicromapEXT( DeferredOperationKHR        deferredOperation,
                                                 CopyMicromapInfoEXT const & info,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyMicromapToMemoryEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMicromapToMemoryEXT.html
    VULKAN_HPP_NODISCARD Result copyMicromapToMemoryEXT( DeferredOperationKHR                deferredOperation,
                                                         CopyMicromapToMemoryInfoEXT const * pInfo,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyMicromapToMemoryEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMicromapToMemoryEXT.html
    VULKAN_HPP_NODISCARD Result copyMicromapToMemoryEXT( DeferredOperationKHR                deferredOperation,
                                                         CopyMicromapToMemoryInfoEXT const & info,
                                                         DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCopyMemoryToMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToMicromapEXT.html
    VULKAN_HPP_NODISCARD Result copyMemoryToMicromapEXT( DeferredOperationKHR                deferredOperation,
                                                         CopyMemoryToMicromapInfoEXT const * pInfo,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCopyMemoryToMicromapEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCopyMemoryToMicromapEXT.html
    VULKAN_HPP_NODISCARD Result copyMemoryToMicromapEXT( DeferredOperationKHR                deferredOperation,
                                                         CopyMemoryToMicromapInfoEXT const & info,
                                                         DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkWriteMicromapsPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteMicromapsPropertiesEXT.html
    VULKAN_HPP_NODISCARD Result writeMicromapsPropertiesEXT( uint32_t                 micromapCount,
                                                             MicromapEXT const *      pMicromaps,
                                                             QueryType                queryType,
                                                             size_t                   dataSize,
                                                             void *                   pData,
                                                             size_t                   stride,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWriteMicromapsPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteMicromapsPropertiesEXT.html
    template <typename DataType, typename DataTypeAllocator = std::allocator<DataType>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataType, DataTypeAllocator>>::type
      writeMicromapsPropertiesEXT( ArrayProxy<MicromapEXT const> const & micromaps,
                                   QueryType                             queryType,
                                   size_t                                dataSize,
                                   size_t                                stride,
                                   DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkWriteMicromapsPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkWriteMicromapsPropertiesEXT.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      writeMicromapsPropertyEXT( ArrayProxy<MicromapEXT const> const & micromaps,
                                 QueryType                             queryType,
                                 size_t                                stride,
                                 DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceMicromapCompatibilityEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMicromapCompatibilityEXT.html
    void getMicromapCompatibilityEXT( MicromapVersionInfoEXT const *          pVersionInfo,
                                      AccelerationStructureCompatibilityKHR * pCompatibility,
                                      DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceMicromapCompatibilityEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceMicromapCompatibilityEXT.html
    VULKAN_HPP_NODISCARD AccelerationStructureCompatibilityKHR getMicromapCompatibilityEXT(
      MicromapVersionInfoEXT const & versionInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMicromapBuildSizesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMicromapBuildSizesEXT.html
    void getMicromapBuildSizesEXT( AccelerationStructureBuildTypeKHR buildType,
                                   MicromapBuildInfoEXT const *      pBuildInfo,
                                   MicromapBuildSizesInfoEXT *       pSizeInfo,
                                   DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMicromapBuildSizesEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMicromapBuildSizesEXT.html
    VULKAN_HPP_NODISCARD MicromapBuildSizesInfoEXT
      getMicromapBuildSizesEXT( AccelerationStructureBuildTypeKHR buildType,
                                MicromapBuildInfoEXT const &      buildInfo,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_pageable_device_local_memory ===

    // wrapper function for command vkSetDeviceMemoryPriorityEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetDeviceMemoryPriorityEXT.html
    void
      setMemoryPriorityEXT( DeviceMemory memory, float priority, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_KHR_maintenance4 ===

    // wrapper function for command vkGetDeviceBufferMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html
    void getBufferMemoryRequirementsKHR( DeviceBufferMemoryRequirements const * pInfo,
                                         MemoryRequirements2 *                  pMemoryRequirements,
                                         DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceBufferMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getBufferMemoryRequirementsKHR(
      DeviceBufferMemoryRequirements const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceBufferMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getBufferMemoryRequirementsKHR( DeviceBufferMemoryRequirements const & info,
                                                         DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceImageMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirementsKHR.html
    void getImageMemoryRequirementsKHR( DeviceImageMemoryRequirements const * pInfo,
                                        MemoryRequirements2 *                 pMemoryRequirements,
                                        DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceImageMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirementsKHR.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getImageMemoryRequirementsKHR(
      DeviceImageMemoryRequirements const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceImageMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageMemoryRequirementsKHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getImageMemoryRequirementsKHR( DeviceImageMemoryRequirements const & info,
                                                        DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceImageSparseMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirementsKHR.html
    void getImageSparseMemoryRequirementsKHR( DeviceImageMemoryRequirements const * pInfo,
                                              uint32_t *                            pSparseMemoryRequirementCount,
                                              SparseImageMemoryRequirements2 *      pSparseMemoryRequirements,
                                              DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceImageSparseMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirementsKHR.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirementsKHR( DeviceImageMemoryRequirements const & info,
                                                              DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDeviceImageSparseMemoryRequirementsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSparseMemoryRequirementsKHR.html
    template <typename SparseImageMemoryRequirements2Allocator = std::allocator<SparseImageMemoryRequirements2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageMemoryRequirements2, SparseImageMemoryRequirements2Allocator>
                         getImageSparseMemoryRequirementsKHR( DeviceImageMemoryRequirements const &           info,
                                                              SparseImageMemoryRequirements2Allocator const & sparseImageMemoryRequirements2Allocator,
                                                              DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VALVE_descriptor_set_host_mapping ===

    // wrapper function for command vkGetDescriptorSetLayoutHostMappingInfoVALVE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html
    void getDescriptorSetLayoutHostMappingInfoVALVE( DescriptorSetBindingReferenceVALVE const * pBindingReference,
                                                     DescriptorSetLayoutHostMappingInfoVALVE *  pHostMapping,
                                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorSetLayoutHostMappingInfoVALVE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html
    VULKAN_HPP_NODISCARD DescriptorSetLayoutHostMappingInfoVALVE
      getDescriptorSetLayoutHostMappingInfoVALVE( DescriptorSetBindingReferenceVALVE const & bindingReference,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDescriptorSetHostMappingVALVE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetHostMappingVALVE.html
    void getDescriptorSetHostMappingVALVE( DescriptorSet            descriptorSet,
                                           void **                  ppData,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDescriptorSetHostMappingVALVE, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDescriptorSetHostMappingVALVE.html
    VULKAN_HPP_NODISCARD void * getDescriptorSetHostMappingVALVE( DescriptorSet            descriptorSet,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_device_generated_commands_compute ===

    // wrapper function for command vkGetPipelineIndirectMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html
    void getPipelineIndirectMemoryRequirementsNV( ComputePipelineCreateInfo const * pCreateInfo,
                                                  MemoryRequirements2 *             pMemoryRequirements,
                                                  DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineIndirectMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getPipelineIndirectMemoryRequirementsNV(
      ComputePipelineCreateInfo const & createInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPipelineIndirectMemoryRequirementsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getPipelineIndirectMemoryRequirementsNV( ComputePipelineCreateInfo const & createInfo,
                                                                  DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPipelineIndirectDeviceAddressNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectDeviceAddressNV.html
    DeviceAddress getPipelineIndirectAddressNV( PipelineIndirectDeviceAddressInfoNV const * pInfo,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineIndirectDeviceAddressNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineIndirectDeviceAddressNV.html
    DeviceAddress getPipelineIndirectAddressNV( PipelineIndirectDeviceAddressInfoNV const & info,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_OHOS )
    //=== VK_OHOS_external_memory ===

    // wrapper function for command vkGetNativeBufferPropertiesOHOS, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetNativeBufferPropertiesOHOS.html
    VULKAN_HPP_NODISCARD Result getNativeBufferPropertiesOHOS( const struct OH_NativeBuffer * buffer,
                                                               NativeBufferPropertiesOHOS *   pProperties,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetNativeBufferPropertiesOHOS, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetNativeBufferPropertiesOHOS.html
    VULKAN_HPP_NODISCARD typename ResultValueType<NativeBufferPropertiesOHOS>::type
      getNativeBufferPropertiesOHOS( const struct OH_NativeBuffer & buffer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetNativeBufferPropertiesOHOS, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetNativeBufferPropertiesOHOS.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getNativeBufferPropertiesOHOS( const struct OH_NativeBuffer & buffer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMemoryNativeBufferOHOS, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryNativeBufferOHOS.html
    VULKAN_HPP_NODISCARD Result getMemoryNativeBufferOHOS( MemoryGetNativeBufferInfoOHOS const * pInfo,
                                                           struct OH_NativeBuffer **             pBuffer,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryNativeBufferOHOS, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryNativeBufferOHOS.html
    VULKAN_HPP_NODISCARD typename ResultValueType<struct OH_NativeBuffer *>::type
      getMemoryNativeBufferOHOS( MemoryGetNativeBufferInfoOHOS const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_OHOS*/

    //=== VK_ARM_tensors ===

    // wrapper function for command vkCreateTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorARM.html
    VULKAN_HPP_NODISCARD Result createTensorARM( TensorCreateInfoARM const * pCreateInfo,
                                                 AllocationCallbacks const * pAllocator,
                                                 TensorARM *                 pTensor,
                                                 DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorARM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<TensorARM>::type
      createTensorARM( TensorCreateInfoARM const &                   createInfo,
                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorARM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<TensorARM>>::type
      createTensorARMUnique( TensorCreateInfoARM const &                   createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorARM.html
    void destroyTensorARM( TensorARM                   tensor,
                           AllocationCallbacks const * pAllocator,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorARM.html
    void destroyTensorARM( TensorARM tensor                              VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorARM.html
    void destroy( TensorARM                   tensor,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyTensorARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorARM.html
    void destroy( TensorARM                                     tensor,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorViewARM.html
    VULKAN_HPP_NODISCARD Result createTensorViewARM( TensorViewCreateInfoARM const * pCreateInfo,
                                                     AllocationCallbacks const *     pAllocator,
                                                     TensorViewARM *                 pView,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorViewARM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<TensorViewARM>::type
      createTensorViewARM( TensorViewCreateInfoARM const &               createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateTensorViewARM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<TensorViewARM>>::type
      createTensorViewARMUnique( TensorViewCreateInfoARM const &               createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorViewARM.html
    void destroyTensorViewARM( TensorViewARM               tensorView,
                               AllocationCallbacks const * pAllocator,
                               DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorViewARM.html
    void destroyTensorViewARM( TensorViewARM tensorView                      VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorViewARM.html
    void destroy( TensorViewARM               tensorView,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyTensorViewARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyTensorViewARM.html
    void destroy( TensorViewARM                                 tensorView,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetTensorMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorMemoryRequirementsARM.html
    void getTensorMemoryRequirementsARM( TensorMemoryRequirementsInfoARM const * pInfo,
                                         MemoryRequirements2 *                   pMemoryRequirements,
                                         DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetTensorMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorMemoryRequirementsARM.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getTensorMemoryRequirementsARM(
      TensorMemoryRequirementsInfoARM const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetTensorMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorMemoryRequirementsARM.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getTensorMemoryRequirementsARM( TensorMemoryRequirementsInfoARM const & info,
                                                         DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBindTensorMemoryARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindTensorMemoryARM.html
    VULKAN_HPP_NODISCARD Result bindTensorMemoryARM( uint32_t                        bindInfoCount,
                                                     BindTensorMemoryInfoARM const * pBindInfos,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindTensorMemoryARM, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindTensorMemoryARM.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindTensorMemoryARM( ArrayProxy<BindTensorMemoryInfoARM const> const & bindInfos,
                           DispatchLoader const & d                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceTensorMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceTensorMemoryRequirementsARM.html
    void getTensorMemoryRequirementsARM( DeviceTensorMemoryRequirementsARM const * pInfo,
                                         MemoryRequirements2 *                     pMemoryRequirements,
                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceTensorMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceTensorMemoryRequirementsARM.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getTensorMemoryRequirementsARM(
      DeviceTensorMemoryRequirementsARM const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceTensorMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceTensorMemoryRequirementsARM.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getTensorMemoryRequirementsARM( DeviceTensorMemoryRequirementsARM const & info,
                                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetTensorOpaqueCaptureDescriptorDataARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorOpaqueCaptureDescriptorDataARM.html
    VULKAN_HPP_NODISCARD Result
      getTensorOpaqueCaptureDescriptorDataARM( TensorCaptureDescriptorDataInfoARM const * pInfo,
                                               void *                                     pData,
                                               DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetTensorOpaqueCaptureDescriptorDataARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorOpaqueCaptureDescriptorDataARM.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getTensorOpaqueCaptureDescriptorDataARM( TensorCaptureDescriptorDataInfoARM const & info,
                                               DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetTensorViewOpaqueCaptureDescriptorDataARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorViewOpaqueCaptureDescriptorDataARM.html
    VULKAN_HPP_NODISCARD Result
      getTensorViewOpaqueCaptureDescriptorDataARM( TensorViewCaptureDescriptorDataInfoARM const * pInfo,
                                                   void *                                         pData,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetTensorViewOpaqueCaptureDescriptorDataARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetTensorViewOpaqueCaptureDescriptorDataARM.html
    template <typename DataType>
    VULKAN_HPP_NODISCARD typename ResultValueType<DataType>::type
      getTensorViewOpaqueCaptureDescriptorDataARM( TensorViewCaptureDescriptorDataInfoARM const & info,
                                                   DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_shader_module_identifier ===

    // wrapper function for command vkGetShaderModuleIdentifierEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleIdentifierEXT.html
    void getShaderModuleIdentifierEXT( ShaderModule                shaderModule,
                                       ShaderModuleIdentifierEXT * pIdentifier,
                                       DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetShaderModuleIdentifierEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleIdentifierEXT.html
    VULKAN_HPP_NODISCARD ShaderModuleIdentifierEXT
      getShaderModuleIdentifierEXT( ShaderModule shaderModule, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetShaderModuleCreateInfoIdentifierEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html
    void getShaderModuleCreateInfoIdentifierEXT( ShaderModuleCreateInfo const * pCreateInfo,
                                                 ShaderModuleIdentifierEXT *    pIdentifier,
                                                 DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetShaderModuleCreateInfoIdentifierEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html
    VULKAN_HPP_NODISCARD ShaderModuleIdentifierEXT getShaderModuleCreateInfoIdentifierEXT(
      ShaderModuleCreateInfo const & createInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_optical_flow ===

    // wrapper function for command vkCreateOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateOpticalFlowSessionNV.html
    VULKAN_HPP_NODISCARD Result createOpticalFlowSessionNV( OpticalFlowSessionCreateInfoNV const * pCreateInfo,
                                                            AllocationCallbacks const *            pAllocator,
                                                            OpticalFlowSessionNV *                 pSession,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateOpticalFlowSessionNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<OpticalFlowSessionNV>::type
      createOpticalFlowSessionNV( OpticalFlowSessionCreateInfoNV const &        createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateOpticalFlowSessionNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<OpticalFlowSessionNV>>::type
      createOpticalFlowSessionNVUnique( OpticalFlowSessionCreateInfoNV const &        createInfo,
                                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyOpticalFlowSessionNV.html
    void destroyOpticalFlowSessionNV( OpticalFlowSessionNV        session,
                                      AllocationCallbacks const * pAllocator,
                                      DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyOpticalFlowSessionNV.html
    void destroyOpticalFlowSessionNV( OpticalFlowSessionNV                          session,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyOpticalFlowSessionNV.html
    void destroy( OpticalFlowSessionNV        session,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyOpticalFlowSessionNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyOpticalFlowSessionNV.html
    void destroy( OpticalFlowSessionNV                          session,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindOpticalFlowSessionImageNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindOpticalFlowSessionImageNV.html
    VULKAN_HPP_NODISCARD Result bindOpticalFlowSessionImageNV( OpticalFlowSessionNV             session,
                                                               OpticalFlowSessionBindingPointNV bindingPoint,
                                                               ImageView                        view,
                                                               ImageLayout                      layout,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkBindOpticalFlowSessionImageNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindOpticalFlowSessionImageNV.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindOpticalFlowSessionImageNV( OpticalFlowSessionNV             session,
                                     OpticalFlowSessionBindingPointNV bindingPoint,
                                     ImageView                        view,
                                     ImageLayout                      layout,
                                     DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    //=== VK_KHR_maintenance5 ===

    // wrapper function for command vkGetRenderingAreaGranularityKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularityKHR.html
    void getRenderingAreaGranularityKHR( RenderingAreaInfo const * pRenderingAreaInfo,
                                         Extent2D *                pGranularity,
                                         DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRenderingAreaGranularityKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRenderingAreaGranularityKHR.html
    VULKAN_HPP_NODISCARD Extent2D getRenderingAreaGranularityKHR( RenderingAreaInfo const & renderingAreaInfo,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDeviceImageSubresourceLayoutKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayoutKHR.html
    void getImageSubresourceLayoutKHR( DeviceImageSubresourceInfo const * pInfo,
                                       SubresourceLayout2 *               pLayout,
                                       DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDeviceImageSubresourceLayoutKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayoutKHR.html
    VULKAN_HPP_NODISCARD SubresourceLayout2 getImageSubresourceLayoutKHR(
      DeviceImageSubresourceInfo const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDeviceImageSubresourceLayoutKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDeviceImageSubresourceLayoutKHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getImageSubresourceLayoutKHR( DeviceImageSubresourceInfo const & info,
                                                       DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetImageSubresourceLayout2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2KHR.html
    void getImageSubresourceLayout2KHR( Image                     image,
                                        ImageSubresource2 const * pSubresource,
                                        SubresourceLayout2 *      pLayout,
                                        DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetImageSubresourceLayout2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2KHR.html
    VULKAN_HPP_NODISCARD SubresourceLayout2 getImageSubresourceLayout2KHR(
      Image image, ImageSubresource2 const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetImageSubresourceLayout2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetImageSubresourceLayout2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...> getImageSubresourceLayout2KHR(
      Image image, ImageSubresource2 const & subresource, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_AMD_anti_lag ===

    // wrapper function for command vkAntiLagUpdateAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAntiLagUpdateAMD.html
    void antiLagUpdateAMD( AntiLagDataAMD const * pData, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAntiLagUpdateAMD, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAntiLagUpdateAMD.html
    void antiLagUpdateAMD( AntiLagDataAMD const & data, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_present_wait2 ===

    // wrapper function for command vkWaitForPresent2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresent2KHR.html
    VULKAN_HPP_NODISCARD Result waitForPresent2KHR( SwapchainKHR                swapchain,
                                                    PresentWait2InfoKHR const * pPresentWait2Info,
                                                    DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkWaitForPresent2KHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkWaitForPresent2KHR.html
    VULKAN_HPP_NODISCARD Result waitForPresent2KHR( SwapchainKHR                swapchain,
                                                    PresentWait2InfoKHR const & presentWait2Info,
                                                    DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_shader_object ===

    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    VULKAN_HPP_NODISCARD Result createShadersEXT( uint32_t                    createInfoCount,
                                                  ShaderCreateInfoEXT const * pCreateInfos,
                                                  AllocationCallbacks const * pAllocator,
                                                  ShaderEXT *                 pShaders,
                                                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    template <typename ShaderEXTAllocator = std::allocator<ShaderEXT>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<ShaderEXT, ShaderEXTAllocator>>
                         createShadersEXT( ArrayProxy<ShaderCreateInfoEXT const> const & createInfos,
                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    template <typename ShaderEXTAllocator = std::allocator<ShaderEXT>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<ShaderEXT, ShaderEXTAllocator>>
                         createShadersEXT( ArrayProxy<ShaderCreateInfoEXT const> const & createInfos,
                                           Optional<AllocationCallbacks const>           allocator,
                                           ShaderEXTAllocator const &                    shaderEXTAllocator,
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    VULKAN_HPP_NODISCARD ResultValue<ShaderEXT> createShaderEXT( ShaderCreateInfoEXT const &                   createInfo,
                                                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    template <typename ShaderEXTAllocator = std::allocator<UniqueHandle<ShaderEXT>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<ShaderEXT>, ShaderEXTAllocator>>
                         createShadersEXTUnique( ArrayProxy<ShaderCreateInfoEXT const> const & createInfos,
                                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    template <typename ShaderEXTAllocator = std::allocator<UniqueHandle<ShaderEXT>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<ShaderEXT>, ShaderEXTAllocator>>
                         createShadersEXTUnique( ArrayProxy<ShaderCreateInfoEXT const> const & createInfos,
                                                 Optional<AllocationCallbacks const>           allocator,
                                                 ShaderEXTAllocator const &                    shaderEXTAllocator,
                                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateShadersEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateShadersEXT.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<ShaderEXT>>
                         createShaderEXTUnique( ShaderCreateInfoEXT const &                   createInfo,
                                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyShaderEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderEXT.html
    void destroyShaderEXT( ShaderEXT                   shader,
                           AllocationCallbacks const * pAllocator,
                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyShaderEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderEXT.html
    void destroyShaderEXT( ShaderEXT shader                              VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyShaderEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderEXT.html
    void destroy( ShaderEXT                   shader,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyShaderEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyShaderEXT.html
    void destroy( ShaderEXT                                     shader,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetShaderBinaryDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderBinaryDataEXT.html
    VULKAN_HPP_NODISCARD Result getShaderBinaryDataEXT( ShaderEXT                shader,
                                                        size_t *                 pDataSize,
                                                        void *                   pData,
                                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetShaderBinaryDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderBinaryDataEXT.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type
      getShaderBinaryDataEXT( ShaderEXT shader, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetShaderBinaryDataEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetShaderBinaryDataEXT.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<uint8_t, Uint8_tAllocator>>::type getShaderBinaryDataEXT(
      ShaderEXT shader, Uint8_tAllocator const & uint8_tAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_pipeline_binary ===

    // wrapper function for command vkCreatePipelineBinariesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html
    VULKAN_HPP_NODISCARD Result createPipelineBinariesKHR( PipelineBinaryCreateInfoKHR const * pCreateInfo,
                                                           AllocationCallbacks const *         pAllocator,
                                                           PipelineBinaryHandlesInfoKHR *      pBinaries,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreatePipelineBinariesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html
    template <typename PipelineBinaryKHRAllocator = std::allocator<PipelineBinaryKHR>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<PipelineBinaryKHR, PipelineBinaryKHRAllocator>>
                         createPipelineBinariesKHR( PipelineBinaryCreateInfoKHR const &           createInfo,
                                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreatePipelineBinariesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html
    template <typename PipelineBinaryKHRAllocator = std::allocator<PipelineBinaryKHR>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<PipelineBinaryKHR, PipelineBinaryKHRAllocator>>
                         createPipelineBinariesKHR( PipelineBinaryCreateInfoKHR const & createInfo,
                                                    Optional<AllocationCallbacks const> allocator,
                                                    PipelineBinaryKHRAllocator const &  pipelineBinaryKHRAllocator,
                                                    DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreatePipelineBinariesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html
    template <typename PipelineBinaryKHRAllocator = std::allocator<UniqueHandle<PipelineBinaryKHR>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<PipelineBinaryKHR>, PipelineBinaryKHRAllocator>>
                         createPipelineBinariesKHRUnique( PipelineBinaryCreateInfoKHR const &           createInfo,
                                                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreatePipelineBinariesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreatePipelineBinariesKHR.html
    template <typename PipelineBinaryKHRAllocator = std::allocator<UniqueHandle<PipelineBinaryKHR>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<PipelineBinaryKHR>, PipelineBinaryKHRAllocator>>
                         createPipelineBinariesKHRUnique( PipelineBinaryCreateInfoKHR const & createInfo,
                                                          Optional<AllocationCallbacks const> allocator,
                                                          PipelineBinaryKHRAllocator const &  pipelineBinaryKHRAllocator,
                                                          DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipelineBinaryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineBinaryKHR.html
    void destroyPipelineBinaryKHR( PipelineBinaryKHR           pipelineBinary,
                                   AllocationCallbacks const * pAllocator,
                                   DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipelineBinaryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineBinaryKHR.html
    void destroyPipelineBinaryKHR( PipelineBinaryKHR pipelineBinary              VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyPipelineBinaryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineBinaryKHR.html
    void destroy( PipelineBinaryKHR           pipelineBinary,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyPipelineBinaryKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyPipelineBinaryKHR.html
    void destroy( PipelineBinaryKHR                             pipelineBinary,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPipelineKeyKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineKeyKHR.html
    VULKAN_HPP_NODISCARD Result getPipelineKeyKHR( PipelineCreateInfoKHR const * pPipelineCreateInfo,
                                                   PipelineBinaryKeyKHR *        pPipelineKey,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineKeyKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineKeyKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<PipelineBinaryKeyKHR>::type
      getPipelineKeyKHR( Optional<PipelineCreateInfoKHR const> pipelineCreateInfo VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPipelineBinaryDataKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineBinaryDataKHR.html
    VULKAN_HPP_NODISCARD Result getPipelineBinaryDataKHR( PipelineBinaryDataInfoKHR const * pInfo,
                                                          PipelineBinaryKeyKHR *            pPipelineBinaryKey,
                                                          size_t *                          pPipelineBinaryDataSize,
                                                          void *                            pPipelineBinaryData,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPipelineBinaryDataKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineBinaryDataKHR.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<PipelineBinaryKeyKHR, std::vector<uint8_t, Uint8_tAllocator>>>::type
      getPipelineBinaryDataKHR( PipelineBinaryDataInfoKHR const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPipelineBinaryDataKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPipelineBinaryDataKHR.html
    template <typename Uint8_tAllocator = std::allocator<uint8_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<PipelineBinaryKeyKHR, std::vector<uint8_t, Uint8_tAllocator>>>::type
      getPipelineBinaryDataKHR( PipelineBinaryDataInfoKHR const & info,
                                Uint8_tAllocator const &          uint8_tAllocator,
                                DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkReleaseCapturedPipelineDataKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseCapturedPipelineDataKHR.html
    VULKAN_HPP_NODISCARD Result releaseCapturedPipelineDataKHR( ReleaseCapturedPipelineDataInfoKHR const * pInfo,
                                                                AllocationCallbacks const *                pAllocator,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleaseCapturedPipelineDataKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseCapturedPipelineDataKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      releaseCapturedPipelineDataKHR( ReleaseCapturedPipelineDataInfoKHR const &    info,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_QCOM_tile_properties ===

    // wrapper function for command vkGetFramebufferTilePropertiesQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFramebufferTilePropertiesQCOM.html
    VULKAN_HPP_NODISCARD Result getFramebufferTilePropertiesQCOM( Framebuffer              framebuffer,
                                                                  uint32_t *               pPropertiesCount,
                                                                  TilePropertiesQCOM *     pProperties,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetFramebufferTilePropertiesQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFramebufferTilePropertiesQCOM.html
    template <typename TilePropertiesQCOMAllocator = std::allocator<TilePropertiesQCOM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<TilePropertiesQCOM, TilePropertiesQCOMAllocator>>::type
      getFramebufferTilePropertiesQCOM( Framebuffer framebuffer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetFramebufferTilePropertiesQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetFramebufferTilePropertiesQCOM.html
    template <typename TilePropertiesQCOMAllocator = std::allocator<TilePropertiesQCOM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<TilePropertiesQCOM, TilePropertiesQCOMAllocator>>::type
      getFramebufferTilePropertiesQCOM( Framebuffer                         framebuffer,
                                        TilePropertiesQCOMAllocator const & tilePropertiesQCOMAllocator,
                                        DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDynamicRenderingTilePropertiesQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html
    VULKAN_HPP_NODISCARD Result
      getDynamicRenderingTilePropertiesQCOM( RenderingInfo const *    pRenderingInfo,
                                             TilePropertiesQCOM *     pProperties,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDynamicRenderingTilePropertiesQCOM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<TilePropertiesQCOM>::type
      getDynamicRenderingTilePropertiesQCOM( RenderingInfo const & renderingInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_swapchain_maintenance1 ===

    // wrapper function for command vkReleaseSwapchainImagesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesKHR.html
    VULKAN_HPP_NODISCARD Result releaseSwapchainImagesKHR( ReleaseSwapchainImagesInfoKHR const * pReleaseInfo,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleaseSwapchainImagesKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseSwapchainImagesKHR.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      releaseSwapchainImagesKHR( ReleaseSwapchainImagesInfoKHR const & releaseInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_cooperative_vector ===

    // wrapper function for command vkConvertCooperativeVectorMatrixNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkConvertCooperativeVectorMatrixNV.html
    VULKAN_HPP_NODISCARD Result convertCooperativeVectorMatrixNV( ConvertCooperativeVectorMatrixInfoNV const * pInfo,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkConvertCooperativeVectorMatrixNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkConvertCooperativeVectorMatrixNV.html
    VULKAN_HPP_NODISCARD Result convertCooperativeVectorMatrixNV( ConvertCooperativeVectorMatrixInfoNV const & info,
                                                                  DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_low_latency2 ===

    // wrapper function for command vkSetLatencySleepModeNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencySleepModeNV.html
    VULKAN_HPP_NODISCARD Result setLatencySleepModeNV( SwapchainKHR                   swapchain,
                                                       LatencySleepModeInfoNV const * pSleepModeInfo,
                                                       DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetLatencySleepModeNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencySleepModeNV.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type setLatencySleepModeNV(
      SwapchainKHR swapchain, LatencySleepModeInfoNV const & sleepModeInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkLatencySleepNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkLatencySleepNV.html
    VULKAN_HPP_NODISCARD Result latencySleepNV( SwapchainKHR               swapchain,
                                                LatencySleepInfoNV const * pSleepInfo,
                                                DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkLatencySleepNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkLatencySleepNV.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      latencySleepNV( SwapchainKHR swapchain, LatencySleepInfoNV const & sleepInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSetLatencyMarkerNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencyMarkerNV.html
    void setLatencyMarkerNV( SwapchainKHR                   swapchain,
                             SetLatencyMarkerInfoNV const * pLatencyMarkerInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSetLatencyMarkerNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkSetLatencyMarkerNV.html
    void setLatencyMarkerNV( SwapchainKHR                   swapchain,
                             SetLatencyMarkerInfoNV const & latencyMarkerInfo,
                             DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetLatencyTimingsNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetLatencyTimingsNV.html
    void getLatencyTimingsNV( SwapchainKHR             swapchain,
                              GetLatencyMarkerInfoNV * pLatencyMarkerInfo,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_ARM_data_graph ===

    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    VULKAN_HPP_NODISCARD Result createDataGraphPipelinesARM( DeferredOperationKHR                   deferredOperation,
                                                             PipelineCache                          pipelineCache,
                                                             uint32_t                               createInfoCount,
                                                             DataGraphPipelineCreateInfoARM const * pCreateInfos,
                                                             AllocationCallbacks const *            pAllocator,
                                                             Pipeline *                             pPipelines,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createDataGraphPipelinesARM( DeferredOperationKHR                                     deferredOperation,
                                                      PipelineCache                                            pipelineCache,
                                                      ArrayProxy<DataGraphPipelineCreateInfoARM const> const & createInfos,
                                                      Optional<AllocationCallbacks const> allocator            VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                      DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    template <typename PipelineAllocator = std::allocator<Pipeline>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<Pipeline, PipelineAllocator>>
                         createDataGraphPipelinesARM( DeferredOperationKHR                                     deferredOperation,
                                                      PipelineCache                                            pipelineCache,
                                                      ArrayProxy<DataGraphPipelineCreateInfoARM const> const & createInfos,
                                                      Optional<AllocationCallbacks const>                      allocator,
                                                      PipelineAllocator const &                                pipelineAllocator,
                                                      DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    VULKAN_HPP_NODISCARD ResultValue<Pipeline>
                         createDataGraphPipelineARM( DeferredOperationKHR                          deferredOperation,
                                                     PipelineCache                                 pipelineCache,
                                                     DataGraphPipelineCreateInfoARM const &        createInfo,
                                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createDataGraphPipelinesARMUnique( DeferredOperationKHR                                     deferredOperation,
                                                            PipelineCache                                            pipelineCache,
                                                            ArrayProxy<DataGraphPipelineCreateInfoARM const> const & createInfos,
                                                            Optional<AllocationCallbacks const> allocator            VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                            DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    template <typename PipelineAllocator = std::allocator<UniqueHandle<Pipeline>>>
    VULKAN_HPP_NODISCARD ResultValue<std::vector<UniqueHandle<Pipeline>, PipelineAllocator>>
                         createDataGraphPipelinesARMUnique( DeferredOperationKHR                                     deferredOperation,
                                                            PipelineCache                                            pipelineCache,
                                                            ArrayProxy<DataGraphPipelineCreateInfoARM const> const & createInfos,
                                                            Optional<AllocationCallbacks const>                      allocator,
                                                            PipelineAllocator const &                                pipelineAllocator,
                                                            DispatchLoader const & d                                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkCreateDataGraphPipelinesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelinesARM.html
    VULKAN_HPP_NODISCARD ResultValue<UniqueHandle<Pipeline>>
                         createDataGraphPipelineARMUnique( DeferredOperationKHR                          deferredOperation,
                                                           PipelineCache                                 pipelineCache,
                                                           DataGraphPipelineCreateInfoARM const &        createInfo,
                                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelineSessionARM.html
    VULKAN_HPP_NODISCARD Result
      createDataGraphPipelineSessionARM( DataGraphPipelineSessionCreateInfoARM const * pCreateInfo,
                                         AllocationCallbacks const *                   pAllocator,
                                         DataGraphPipelineSessionARM *                 pSession,
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelineSessionARM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DataGraphPipelineSessionARM>::type
      createDataGraphPipelineSessionARM( DataGraphPipelineSessionCreateInfoARM const & createInfo,
                                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDataGraphPipelineSessionARM.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DataGraphPipelineSessionARM>>::type
      createDataGraphPipelineSessionARMUnique( DataGraphPipelineSessionCreateInfoARM const & createInfo,
                                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDataGraphPipelineSessionBindPointRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionBindPointRequirementsARM.html
    VULKAN_HPP_NODISCARD Result
      getDataGraphPipelineSessionBindPointRequirementsARM( DataGraphPipelineSessionBindPointRequirementsInfoARM const * pInfo,
                                                           uint32_t *                                                   pBindPointRequirementCount,
                                                           DataGraphPipelineSessionBindPointRequirementARM *            pBindPointRequirements,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDataGraphPipelineSessionBindPointRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionBindPointRequirementsARM.html
    template <typename DataGraphPipelineSessionBindPointRequirementARMAllocator = std::allocator<DataGraphPipelineSessionBindPointRequirementARM>>
    VULKAN_HPP_NODISCARD
      typename ResultValueType<std::vector<DataGraphPipelineSessionBindPointRequirementARM, DataGraphPipelineSessionBindPointRequirementARMAllocator>>::type
      getDataGraphPipelineSessionBindPointRequirementsARM( DataGraphPipelineSessionBindPointRequirementsInfoARM const & info,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDataGraphPipelineSessionBindPointRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionBindPointRequirementsARM.html
    template <typename DataGraphPipelineSessionBindPointRequirementARMAllocator = std::allocator<DataGraphPipelineSessionBindPointRequirementARM>>
    VULKAN_HPP_NODISCARD
      typename ResultValueType<std::vector<DataGraphPipelineSessionBindPointRequirementARM, DataGraphPipelineSessionBindPointRequirementARMAllocator>>::type
      getDataGraphPipelineSessionBindPointRequirementsARM(
        DataGraphPipelineSessionBindPointRequirementsInfoARM const &     info,
        DataGraphPipelineSessionBindPointRequirementARMAllocator const & dataGraphPipelineSessionBindPointRequirementARMAllocator,
        DispatchLoader const & d                                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDataGraphPipelineSessionMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionMemoryRequirementsARM.html
    void getDataGraphPipelineSessionMemoryRequirementsARM( DataGraphPipelineSessionMemoryRequirementsInfoARM const * pInfo,
                                                           MemoryRequirements2 *                                     pMemoryRequirements,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDataGraphPipelineSessionMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionMemoryRequirementsARM.html
    VULKAN_HPP_NODISCARD MemoryRequirements2
      getDataGraphPipelineSessionMemoryRequirementsARM( DataGraphPipelineSessionMemoryRequirementsInfoARM const & info,
                                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetDataGraphPipelineSessionMemoryRequirementsARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineSessionMemoryRequirementsARM.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getDataGraphPipelineSessionMemoryRequirementsARM( DataGraphPipelineSessionMemoryRequirementsInfoARM const & info,
                                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkBindDataGraphPipelineSessionMemoryARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindDataGraphPipelineSessionMemoryARM.html
    VULKAN_HPP_NODISCARD Result
      bindDataGraphPipelineSessionMemoryARM( uint32_t                                          bindInfoCount,
                                             BindDataGraphPipelineSessionMemoryInfoARM const * pBindInfos,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkBindDataGraphPipelineSessionMemoryARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkBindDataGraphPipelineSessionMemoryARM.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      bindDataGraphPipelineSessionMemoryARM( ArrayProxy<BindDataGraphPipelineSessionMemoryInfoARM const> const & bindInfos,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDataGraphPipelineSessionARM.html
    void destroyDataGraphPipelineSessionARM( DataGraphPipelineSessionARM session,
                                             AllocationCallbacks const * pAllocator,
                                             DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDataGraphPipelineSessionARM.html
    void destroyDataGraphPipelineSessionARM( DataGraphPipelineSessionARM                   session,
                                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDataGraphPipelineSessionARM.html
    void destroy( DataGraphPipelineSessionARM session,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDataGraphPipelineSessionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDataGraphPipelineSessionARM.html
    void destroy( DataGraphPipelineSessionARM                   session,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDataGraphPipelineAvailablePropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineAvailablePropertiesARM.html
    VULKAN_HPP_NODISCARD Result
      getDataGraphPipelineAvailablePropertiesARM( DataGraphPipelineInfoARM const * pPipelineInfo,
                                                  uint32_t *                       pPropertiesCount,
                                                  DataGraphPipelinePropertyARM *   pProperties,
                                                  DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDataGraphPipelineAvailablePropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineAvailablePropertiesARM.html
    template <typename DataGraphPipelinePropertyARMAllocator = std::allocator<DataGraphPipelinePropertyARM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataGraphPipelinePropertyARM, DataGraphPipelinePropertyARMAllocator>>::type
      getDataGraphPipelineAvailablePropertiesARM( DataGraphPipelineInfoARM const & pipelineInfo,
                                                  DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDataGraphPipelineAvailablePropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelineAvailablePropertiesARM.html
    template <typename DataGraphPipelinePropertyARMAllocator = std::allocator<DataGraphPipelinePropertyARM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DataGraphPipelinePropertyARM, DataGraphPipelinePropertyARMAllocator>>::type
      getDataGraphPipelineAvailablePropertiesARM( DataGraphPipelineInfoARM const &              pipelineInfo,
                                                  DataGraphPipelinePropertyARMAllocator const & dataGraphPipelinePropertyARMAllocator,
                                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDataGraphPipelinePropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDataGraphPipelinePropertiesARM.html
    VULKAN_HPP_NODISCARD Result
      getDataGraphPipelinePropertiesARM( DataGraphPipelineInfoARM const *          pPipelineInfo,
                                         uint32_t                                  propertiesCount,
                                         DataGraphPipelinePropertyQueryResultARM * pProperties,
                                         DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
    //=== VK_QNX_external_memory_screen_buffer ===

    // wrapper function for command vkGetScreenBufferPropertiesQNX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetScreenBufferPropertiesQNX.html
    VULKAN_HPP_NODISCARD Result getScreenBufferPropertiesQNX( const struct _screen_buffer * buffer,
                                                              ScreenBufferPropertiesQNX *   pProperties,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetScreenBufferPropertiesQNX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetScreenBufferPropertiesQNX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ScreenBufferPropertiesQNX>::type
      getScreenBufferPropertiesQNX( const struct _screen_buffer & buffer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetScreenBufferPropertiesQNX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetScreenBufferPropertiesQNX.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getScreenBufferPropertiesQNX( const struct _screen_buffer & buffer, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_SCREEN_QNX*/

    //=== VK_KHR_calibrated_timestamps ===

    // wrapper function for command vkGetCalibratedTimestampsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsKHR.html
    VULKAN_HPP_NODISCARD Result getCalibratedTimestampsKHR( uint32_t                           timestampCount,
                                                            CalibratedTimestampInfoKHR const * pTimestampInfos,
                                                            uint64_t *                         pTimestamps,
                                                            uint64_t *                         pMaxDeviation,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetCalibratedTimestampsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsKHR.html
    template <typename Uint64_tAllocator = std::allocator<uint64_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<uint64_t, Uint64_tAllocator>, uint64_t>>::type
      getCalibratedTimestampsKHR( ArrayProxy<CalibratedTimestampInfoKHR const> const & timestampInfos,
                                  DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetCalibratedTimestampsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsKHR.html
    template <typename Uint64_tAllocator = std::allocator<uint64_t>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<uint64_t, Uint64_tAllocator>, uint64_t>>::type
      getCalibratedTimestampsKHR( ArrayProxy<CalibratedTimestampInfoKHR const> const & timestampInfos,
                                  Uint64_tAllocator const &                            uint64_tAllocator,
                                  DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetCalibratedTimestampsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetCalibratedTimestampsKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<uint64_t, uint64_t>>::type
      getCalibratedTimestampKHR( CalibratedTimestampInfoKHR const & timestampInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_external_compute_queue ===

    // wrapper function for command vkCreateExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExternalComputeQueueNV.html
    VULKAN_HPP_NODISCARD Result createExternalComputeQueueNV( ExternalComputeQueueCreateInfoNV const * pCreateInfo,
                                                              AllocationCallbacks const *              pAllocator,
                                                              ExternalComputeQueueNV *                 pExternalQueue,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExternalComputeQueueNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ExternalComputeQueueNV>::type
      createExternalComputeQueueNV( ExternalComputeQueueCreateInfoNV const &      createInfo,
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateExternalComputeQueueNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<ExternalComputeQueueNV>>::type
      createExternalComputeQueueNVUnique( ExternalComputeQueueCreateInfoNV const &      createInfo,
                                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyExternalComputeQueueNV.html
    void destroyExternalComputeQueueNV( ExternalComputeQueueNV      externalQueue,
                                        AllocationCallbacks const * pAllocator,
                                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyExternalComputeQueueNV.html
    void destroyExternalComputeQueueNV( ExternalComputeQueueNV                        externalQueue,
                                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyExternalComputeQueueNV.html
    void destroy( ExternalComputeQueueNV      externalQueue,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyExternalComputeQueueNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyExternalComputeQueueNV.html
    void destroy( ExternalComputeQueueNV                        externalQueue,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_cluster_acceleration_structure ===

    // wrapper function for command vkGetClusterAccelerationStructureBuildSizesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetClusterAccelerationStructureBuildSizesNV.html
    void getClusterAccelerationStructureBuildSizesNV( ClusterAccelerationStructureInputInfoNV const * pInfo,
                                                      AccelerationStructureBuildSizesInfoKHR *        pSizeInfo,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetClusterAccelerationStructureBuildSizesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetClusterAccelerationStructureBuildSizesNV.html
    VULKAN_HPP_NODISCARD AccelerationStructureBuildSizesInfoKHR getClusterAccelerationStructureBuildSizesNV(
      ClusterAccelerationStructureInputInfoNV const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_partitioned_acceleration_structure ===

    // wrapper function for command vkGetPartitionedAccelerationStructuresBuildSizesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPartitionedAccelerationStructuresBuildSizesNV.html
    void getPartitionedAccelerationStructuresBuildSizesNV( PartitionedAccelerationStructureInstancesInputNV const * pInfo,
                                                           AccelerationStructureBuildSizesInfoKHR *                 pSizeInfo,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPartitionedAccelerationStructuresBuildSizesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPartitionedAccelerationStructuresBuildSizesNV.html
    VULKAN_HPP_NODISCARD AccelerationStructureBuildSizesInfoKHR
      getPartitionedAccelerationStructuresBuildSizesNV( PartitionedAccelerationStructureInstancesInputNV const & info,
                                                        DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_device_generated_commands ===

    // wrapper function for command vkGetGeneratedCommandsMemoryRequirementsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsEXT.html
    void getGeneratedCommandsMemoryRequirementsEXT( GeneratedCommandsMemoryRequirementsInfoEXT const * pInfo,
                                                    MemoryRequirements2 *                              pMemoryRequirements,
                                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetGeneratedCommandsMemoryRequirementsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsEXT.html
    VULKAN_HPP_NODISCARD MemoryRequirements2 getGeneratedCommandsMemoryRequirementsEXT(
      GeneratedCommandsMemoryRequirementsInfoEXT const & info, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetGeneratedCommandsMemoryRequirementsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetGeneratedCommandsMemoryRequirementsEXT.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getGeneratedCommandsMemoryRequirementsEXT( GeneratedCommandsMemoryRequirementsInfoEXT const & info,
                                                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutEXT.html
    VULKAN_HPP_NODISCARD Result createIndirectCommandsLayoutEXT( IndirectCommandsLayoutCreateInfoEXT const * pCreateInfo,
                                                                 AllocationCallbacks const *                 pAllocator,
                                                                 IndirectCommandsLayoutEXT *                 pIndirectCommandsLayout,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<IndirectCommandsLayoutEXT>::type
      createIndirectCommandsLayoutEXT( IndirectCommandsLayoutCreateInfoEXT const &   createInfo,
                                       Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                       DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectCommandsLayoutEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<IndirectCommandsLayoutEXT>>::type
      createIndirectCommandsLayoutEXTUnique( IndirectCommandsLayoutCreateInfoEXT const &   createInfo,
                                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutEXT.html
    void destroyIndirectCommandsLayoutEXT( IndirectCommandsLayoutEXT   indirectCommandsLayout,
                                           AllocationCallbacks const * pAllocator,
                                           DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutEXT.html
    void destroyIndirectCommandsLayoutEXT( IndirectCommandsLayoutEXT indirectCommandsLayout VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                           Optional<AllocationCallbacks const> allocator    VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutEXT.html
    void destroy( IndirectCommandsLayoutEXT   indirectCommandsLayout,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyIndirectCommandsLayoutEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectCommandsLayoutEXT.html
    void destroy( IndirectCommandsLayoutEXT                     indirectCommandsLayout,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectExecutionSetEXT.html
    VULKAN_HPP_NODISCARD Result createIndirectExecutionSetEXT( IndirectExecutionSetCreateInfoEXT const * pCreateInfo,
                                                               AllocationCallbacks const *               pAllocator,
                                                               IndirectExecutionSetEXT *                 pIndirectExecutionSet,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectExecutionSetEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<IndirectExecutionSetEXT>::type
      createIndirectExecutionSetEXT( IndirectExecutionSetCreateInfoEXT const &     createInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIndirectExecutionSetEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<IndirectExecutionSetEXT>>::type
      createIndirectExecutionSetEXTUnique( IndirectExecutionSetCreateInfoEXT const &     createInfo,
                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectExecutionSetEXT.html
    void destroyIndirectExecutionSetEXT( IndirectExecutionSetEXT     indirectExecutionSet,
                                         AllocationCallbacks const * pAllocator,
                                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectExecutionSetEXT.html
    void destroyIndirectExecutionSetEXT( IndirectExecutionSetEXT indirectExecutionSet  VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectExecutionSetEXT.html
    void destroy( IndirectExecutionSetEXT     indirectExecutionSet,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyIndirectExecutionSetEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyIndirectExecutionSetEXT.html
    void destroy( IndirectExecutionSetEXT                       indirectExecutionSet,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUpdateIndirectExecutionSetPipelineEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateIndirectExecutionSetPipelineEXT.html
    void updateIndirectExecutionSetPipelineEXT( IndirectExecutionSetEXT                      indirectExecutionSet,
                                                uint32_t                                     executionSetWriteCount,
                                                WriteIndirectExecutionSetPipelineEXT const * pExecutionSetWrites,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUpdateIndirectExecutionSetPipelineEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateIndirectExecutionSetPipelineEXT.html
    void updateIndirectExecutionSetPipelineEXT( IndirectExecutionSetEXT                                        indirectExecutionSet,
                                                ArrayProxy<WriteIndirectExecutionSetPipelineEXT const> const & executionSetWrites,
                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkUpdateIndirectExecutionSetShaderEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateIndirectExecutionSetShaderEXT.html
    void updateIndirectExecutionSetShaderEXT( IndirectExecutionSetEXT                    indirectExecutionSet,
                                              uint32_t                                   executionSetWriteCount,
                                              WriteIndirectExecutionSetShaderEXT const * pExecutionSetWrites,
                                              DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkUpdateIndirectExecutionSetShaderEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkUpdateIndirectExecutionSetShaderEXT.html
    void updateIndirectExecutionSetShaderEXT( IndirectExecutionSetEXT                                      indirectExecutionSet,
                                              ArrayProxy<WriteIndirectExecutionSetShaderEXT const> const & executionSetWrites,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_METAL_EXT )
    //=== VK_EXT_external_memory_metal ===

    // wrapper function for command vkGetMemoryMetalHandleEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryMetalHandleEXT.html
    VULKAN_HPP_NODISCARD Result getMemoryMetalHandleEXT( MemoryGetMetalHandleInfoEXT const * pGetMetalHandleInfo,
                                                         void **                             pHandle,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryMetalHandleEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryMetalHandleEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<void *>::type
      getMemoryMetalHandleEXT( MemoryGetMetalHandleInfoEXT const & getMetalHandleInfo,
                               DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetMemoryMetalHandlePropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryMetalHandlePropertiesEXT.html
    VULKAN_HPP_NODISCARD Result
      getMemoryMetalHandlePropertiesEXT( ExternalMemoryHandleTypeFlagBits handleType,
                                         void const *                     pHandle,
                                         MemoryMetalHandlePropertiesEXT * pMemoryMetalHandleProperties,
                                         DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetMemoryMetalHandlePropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetMemoryMetalHandlePropertiesEXT.html
    template <typename HandleType>
    VULKAN_HPP_NODISCARD typename ResultValueType<MemoryMetalHandlePropertiesEXT>::type getMemoryMetalHandlePropertiesEXT(
      ExternalMemoryHandleTypeFlagBits handleType, HandleType const & handle, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_METAL_EXT*/

    operator VkDevice() const VULKAN_HPP_NOEXCEPT
    {
      return m_device;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_device != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_device == VK_NULL_HANDLE;
    }

  private:
    VkDevice m_device = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDevice>
  {
    using Type = Device;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDevice>
  {
    using Type = Device;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDevice, VK_NULL_HANDLE>
  {
    using Type = Device;
  };
#endif

  template <>
  struct isVulkanHandleType<Device>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkDisplayModeKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkDisplayModeKHR.html
  class DisplayModeKHR
  {
  public:
    using CType      = VkDisplayModeKHR;
    using NativeType = VkDisplayModeKHR;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eDisplayModeKHR;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eDisplayModeKHR;

  public:
    DisplayModeKHR() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    DisplayModeKHR( DisplayModeKHR const & rhs )             = default;
    DisplayModeKHR & operator=( DisplayModeKHR const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    DisplayModeKHR( DisplayModeKHR && rhs )             = default;
    DisplayModeKHR & operator=( DisplayModeKHR && rhs ) = default;
#else
    DisplayModeKHR( DisplayModeKHR && rhs ) VULKAN_HPP_NOEXCEPT : m_displayModeKHR( exchange( rhs.m_displayModeKHR, {} ) ) {}

    DisplayModeKHR & operator=( DisplayModeKHR && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_displayModeKHR = exchange( rhs.m_displayModeKHR, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR DisplayModeKHR( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    VULKAN_HPP_TYPESAFE_EXPLICIT DisplayModeKHR( VkDisplayModeKHR displayModeKHR ) VULKAN_HPP_NOEXCEPT : m_displayModeKHR( displayModeKHR ) {}

#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )
    DisplayModeKHR & operator=( VkDisplayModeKHR displayModeKHR ) VULKAN_HPP_NOEXCEPT
    {
      m_displayModeKHR = displayModeKHR;
      return *this;
    }
#endif

    DisplayModeKHR & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_displayModeKHR = {};
      return *this;
    }

    VULKAN_HPP_TYPESAFE_EXPLICIT operator VkDisplayModeKHR() const VULKAN_HPP_NOEXCEPT
    {
      return m_displayModeKHR;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_displayModeKHR != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_displayModeKHR == VK_NULL_HANDLE;
    }

  private:
    VkDisplayModeKHR m_displayModeKHR = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eDisplayModeKHR>
  {
    using Type = DisplayModeKHR;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eDisplayModeKHR>
  {
    using Type = DisplayModeKHR;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkDisplayModeKHR, VK_NULL_HANDLE>
  {
    using Type = DisplayModeKHR;
  };
#endif

  template <>
  struct isVulkanHandleType<DisplayModeKHR>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkPhysicalDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDevice.html
  class PhysicalDevice
  {
  public:
    using CType      = VkPhysicalDevice;
    using NativeType = VkPhysicalDevice;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::ePhysicalDevice;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::ePhysicalDevice;

  public:
    PhysicalDevice() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    PhysicalDevice( PhysicalDevice const & rhs )             = default;
    PhysicalDevice & operator=( PhysicalDevice const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    PhysicalDevice( PhysicalDevice && rhs )             = default;
    PhysicalDevice & operator=( PhysicalDevice && rhs ) = default;
#else
    PhysicalDevice( PhysicalDevice && rhs ) VULKAN_HPP_NOEXCEPT : m_physicalDevice( exchange( rhs.m_physicalDevice, {} ) ) {}

    PhysicalDevice & operator=( PhysicalDevice && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_physicalDevice = exchange( rhs.m_physicalDevice, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR PhysicalDevice( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    PhysicalDevice( VkPhysicalDevice physicalDevice ) VULKAN_HPP_NOEXCEPT : m_physicalDevice( physicalDevice ) {}

    PhysicalDevice & operator=( VkPhysicalDevice physicalDevice ) VULKAN_HPP_NOEXCEPT
    {
      m_physicalDevice = physicalDevice;
      return *this;
    }

    PhysicalDevice & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_physicalDevice = {};
      return *this;
    }

    //=== VK_VERSION_1_0 ===

    // wrapper function for command vkGetPhysicalDeviceFeatures, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures.html
    void getFeatures( PhysicalDeviceFeatures * pFeatures, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFeatures, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures.html
    VULKAN_HPP_NODISCARD PhysicalDeviceFeatures getFeatures( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties.html
    void getFormatProperties( Format                   format,
                              FormatProperties *       pFormatProperties,
                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties.html
    VULKAN_HPP_NODISCARD FormatProperties getFormatProperties( Format                   format,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties.html
    VULKAN_HPP_NODISCARD Result getImageFormatProperties( Format                   format,
                                                          ImageType                type,
                                                          ImageTiling              tiling,
                                                          ImageUsageFlags          usage,
                                                          ImageCreateFlags         flags,
                                                          ImageFormatProperties *  pImageFormatProperties,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ImageFormatProperties>::type
      getImageFormatProperties( Format                   format,
                                ImageType                type,
                                ImageTiling              tiling,
                                ImageUsageFlags          usage,
                                ImageCreateFlags flags   VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties.html
    void getProperties( PhysicalDeviceProperties * pProperties, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties.html
    VULKAN_HPP_NODISCARD PhysicalDeviceProperties getProperties( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
    void getQueueFamilyProperties( uint32_t *               pQueueFamilyPropertyCount,
                                   QueueFamilyProperties *  pQueueFamilyProperties,
                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
    template <typename QueueFamilyPropertiesAllocator = std::allocator<QueueFamilyProperties>>
    VULKAN_HPP_NODISCARD std::vector<QueueFamilyProperties, QueueFamilyPropertiesAllocator>
                         getQueueFamilyProperties( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
    template <typename QueueFamilyPropertiesAllocator = std::allocator<QueueFamilyProperties>>
    VULKAN_HPP_NODISCARD std::vector<QueueFamilyProperties, QueueFamilyPropertiesAllocator>
                         getQueueFamilyProperties( QueueFamilyPropertiesAllocator const & queueFamilyPropertiesAllocator,
                                                   DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceMemoryProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties.html
    void getMemoryProperties( PhysicalDeviceMemoryProperties * pMemoryProperties,
                              DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceMemoryProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties.html
    VULKAN_HPP_NODISCARD PhysicalDeviceMemoryProperties
      getMemoryProperties( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDevice.html
    VULKAN_HPP_NODISCARD Result createDevice( DeviceCreateInfo const *    pCreateInfo,
                                              AllocationCallbacks const * pAllocator,
                                              Device *                    pDevice,
                                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDevice.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Device>::type
      createDevice( DeviceCreateInfo const &                      createInfo,
                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDevice, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDevice.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Device>>::type
      createDeviceUnique( DeviceCreateInfo const &                      createInfo,
                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkEnumerateDeviceExtensionProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceExtensionProperties.html
    VULKAN_HPP_NODISCARD Result
      enumerateDeviceExtensionProperties( char const *             pLayerName,
                                          uint32_t *               pPropertyCount,
                                          ExtensionProperties *    pProperties,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumerateDeviceExtensionProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceExtensionProperties.html
    template <typename ExtensionPropertiesAllocator = std::allocator<ExtensionProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<ExtensionProperties, ExtensionPropertiesAllocator>>::type
      enumerateDeviceExtensionProperties( Optional<std::string const> layerName VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumerateDeviceExtensionProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceExtensionProperties.html
    template <typename ExtensionPropertiesAllocator = std::allocator<ExtensionProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<ExtensionProperties, ExtensionPropertiesAllocator>>::type
      enumerateDeviceExtensionProperties( Optional<std::string const>          layerName,
                                          ExtensionPropertiesAllocator const & extensionPropertiesAllocator,
                                          DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkEnumerateDeviceLayerProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceLayerProperties.html
    VULKAN_HPP_NODISCARD Result enumerateDeviceLayerProperties( uint32_t *               pPropertyCount,
                                                                LayerProperties *        pProperties,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumerateDeviceLayerProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceLayerProperties.html
    template <typename LayerPropertiesAllocator = std::allocator<LayerProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<LayerProperties, LayerPropertiesAllocator>>::type
      enumerateDeviceLayerProperties( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumerateDeviceLayerProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateDeviceLayerProperties.html
    template <typename LayerPropertiesAllocator = std::allocator<LayerProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<LayerProperties, LayerPropertiesAllocator>>::type
      enumerateDeviceLayerProperties( LayerPropertiesAllocator const & layerPropertiesAllocator,
                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
    void getSparseImageFormatProperties( Format                        format,
                                         ImageType                     type,
                                         SampleCountFlagBits           samples,
                                         ImageUsageFlags               usage,
                                         ImageTiling                   tiling,
                                         uint32_t *                    pPropertyCount,
                                         SparseImageFormatProperties * pProperties,
                                         DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
    template <typename SparseImageFormatPropertiesAllocator = std::allocator<SparseImageFormatProperties>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageFormatProperties, SparseImageFormatPropertiesAllocator>
                         getSparseImageFormatProperties( Format                   format,
                                                         ImageType                type,
                                                         SampleCountFlagBits      samples,
                                                         ImageUsageFlags          usage,
                                                         ImageTiling              tiling,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
    template <typename SparseImageFormatPropertiesAllocator = std::allocator<SparseImageFormatProperties>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageFormatProperties, SparseImageFormatPropertiesAllocator>
                         getSparseImageFormatProperties( Format                                       format,
                                                         ImageType                                    type,
                                                         SampleCountFlagBits                          samples,
                                                         ImageUsageFlags                              usage,
                                                         ImageTiling                                  tiling,
                                                         SparseImageFormatPropertiesAllocator const & sparseImageFormatPropertiesAllocator,
                                                         DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_1 ===

    // wrapper function for command vkGetPhysicalDeviceFeatures2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html
    void getFeatures2( PhysicalDeviceFeatures2 * pFeatures, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFeatures2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html
    VULKAN_HPP_NODISCARD PhysicalDeviceFeatures2 getFeatures2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceFeatures2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...> getFeatures2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2.html
    void getProperties2( PhysicalDeviceProperties2 * pProperties, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2.html
    VULKAN_HPP_NODISCARD PhysicalDeviceProperties2
      getProperties2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getProperties2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2.html
    void getFormatProperties2( Format                   format,
                               FormatProperties2 *      pFormatProperties,
                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2.html
    VULKAN_HPP_NODISCARD FormatProperties2 getFormatProperties2( Format                   format,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getFormatProperties2( Format format, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
    VULKAN_HPP_NODISCARD Result getImageFormatProperties2( PhysicalDeviceImageFormatInfo2 const * pImageFormatInfo,
                                                           ImageFormatProperties2 *               pImageFormatProperties,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ImageFormatProperties2>::type
      getImageFormatProperties2( PhysicalDeviceImageFormatInfo2 const & imageFormatInfo,
                                 DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getImageFormatProperties2( PhysicalDeviceImageFormatInfo2 const & imageFormatInfo,
                                 DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
    void getQueueFamilyProperties2( uint32_t *               pQueueFamilyPropertyCount,
                                    QueueFamilyProperties2 * pQueueFamilyProperties,
                                    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
    template <typename QueueFamilyProperties2Allocator = std::allocator<QueueFamilyProperties2>>
    VULKAN_HPP_NODISCARD std::vector<QueueFamilyProperties2, QueueFamilyProperties2Allocator>
                         getQueueFamilyProperties2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
    template <typename QueueFamilyProperties2Allocator = std::allocator<QueueFamilyProperties2>>
    VULKAN_HPP_NODISCARD std::vector<QueueFamilyProperties2, QueueFamilyProperties2Allocator>
                         getQueueFamilyProperties2( QueueFamilyProperties2Allocator const & queueFamilyProperties2Allocator,
                                                    DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD std::vector<StructureChain, StructureChainAllocator>
                         getQueueFamilyProperties2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD std::vector<StructureChain, StructureChainAllocator>
      getQueueFamilyProperties2( StructureChainAllocator & structureChainAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceMemoryProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2.html
    void getMemoryProperties2( PhysicalDeviceMemoryProperties2 * pMemoryProperties,
                               DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceMemoryProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2.html
    VULKAN_HPP_NODISCARD PhysicalDeviceMemoryProperties2
      getMemoryProperties2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceMemoryProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getMemoryProperties2( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
    void getSparseImageFormatProperties2( PhysicalDeviceSparseImageFormatInfo2 const * pFormatInfo,
                                          uint32_t *                                   pPropertyCount,
                                          SparseImageFormatProperties2 *               pProperties,
                                          DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
    template <typename SparseImageFormatProperties2Allocator = std::allocator<SparseImageFormatProperties2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageFormatProperties2, SparseImageFormatProperties2Allocator>
                         getSparseImageFormatProperties2( PhysicalDeviceSparseImageFormatInfo2 const & formatInfo,
                                                          DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties2, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
    template <typename SparseImageFormatProperties2Allocator = std::allocator<SparseImageFormatProperties2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageFormatProperties2, SparseImageFormatProperties2Allocator>
                         getSparseImageFormatProperties2( PhysicalDeviceSparseImageFormatInfo2 const &  formatInfo,
                                                          SparseImageFormatProperties2Allocator const & sparseImageFormatProperties2Allocator,
                                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceExternalBufferProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
    void getExternalBufferProperties( PhysicalDeviceExternalBufferInfo const * pExternalBufferInfo,
                                      ExternalBufferProperties *               pExternalBufferProperties,
                                      DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalBufferProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
    VULKAN_HPP_NODISCARD ExternalBufferProperties
      getExternalBufferProperties( PhysicalDeviceExternalBufferInfo const & externalBufferInfo,
                                   DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceExternalFenceProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
    void getExternalFenceProperties( PhysicalDeviceExternalFenceInfo const * pExternalFenceInfo,
                                     ExternalFenceProperties *               pExternalFenceProperties,
                                     DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalFenceProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
    VULKAN_HPP_NODISCARD ExternalFenceProperties getExternalFenceProperties(
      PhysicalDeviceExternalFenceInfo const & externalFenceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceExternalSemaphoreProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
    void getExternalSemaphoreProperties( PhysicalDeviceExternalSemaphoreInfo const * pExternalSemaphoreInfo,
                                         ExternalSemaphoreProperties *               pExternalSemaphoreProperties,
                                         DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalSemaphoreProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
    VULKAN_HPP_NODISCARD ExternalSemaphoreProperties
      getExternalSemaphoreProperties( PhysicalDeviceExternalSemaphoreInfo const & externalSemaphoreInfo,
                                      DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_3 ===

    // wrapper function for command vkGetPhysicalDeviceToolProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolProperties.html
    VULKAN_HPP_NODISCARD Result getToolProperties( uint32_t *                     pToolCount,
                                                   PhysicalDeviceToolProperties * pToolProperties,
                                                   DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceToolProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolProperties.html
    template <typename PhysicalDeviceToolPropertiesAllocator = std::allocator<PhysicalDeviceToolProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceToolProperties, PhysicalDeviceToolPropertiesAllocator>>::type
      getToolProperties( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceToolProperties, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolProperties.html
    template <typename PhysicalDeviceToolPropertiesAllocator = std::allocator<PhysicalDeviceToolProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceToolProperties, PhysicalDeviceToolPropertiesAllocator>>::type
      getToolProperties( PhysicalDeviceToolPropertiesAllocator const & physicalDeviceToolPropertiesAllocator,
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_surface ===

    // wrapper function for command vkGetPhysicalDeviceSurfaceSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
    VULKAN_HPP_NODISCARD Result getSurfaceSupportKHR( uint32_t                 queueFamilyIndex,
                                                      SurfaceKHR               surface,
                                                      Bool32 *                 pSupported,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfaceSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<Bool32>::type
      getSurfaceSupportKHR( uint32_t queueFamilyIndex, SurfaceKHR surface, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD Result getSurfaceCapabilitiesKHR( SurfaceKHR               surface,
                                                           SurfaceCapabilitiesKHR * pSurfaceCapabilities,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceCapabilitiesKHR>::type
      getSurfaceCapabilitiesKHR( SurfaceKHR surface, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSurfaceFormatsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
    VULKAN_HPP_NODISCARD Result getSurfaceFormatsKHR( SurfaceKHR               surface,
                                                      uint32_t *               pSurfaceFormatCount,
                                                      SurfaceFormatKHR *       pSurfaceFormats,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfaceFormatsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
    template <typename SurfaceFormatKHRAllocator = std::allocator<SurfaceFormatKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<SurfaceFormatKHR, SurfaceFormatKHRAllocator>>::type
      getSurfaceFormatsKHR( SurfaceKHR surface VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ), DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfaceFormatsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
    template <typename SurfaceFormatKHRAllocator = std::allocator<SurfaceFormatKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<SurfaceFormatKHR, SurfaceFormatKHRAllocator>>::type
      getSurfaceFormatsKHR( SurfaceKHR                        surface,
                            SurfaceFormatKHRAllocator const & surfaceFormatKHRAllocator,
                            DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSurfacePresentModesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
    VULKAN_HPP_NODISCARD Result getSurfacePresentModesKHR( SurfaceKHR               surface,
                                                           uint32_t *               pPresentModeCount,
                                                           PresentModeKHR *         pPresentModes,
                                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfacePresentModesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
    template <typename PresentModeKHRAllocator = std::allocator<PresentModeKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PresentModeKHR, PresentModeKHRAllocator>>::type
      getSurfacePresentModesKHR( SurfaceKHR surface       VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfacePresentModesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
    template <typename PresentModeKHRAllocator = std::allocator<PresentModeKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PresentModeKHR, PresentModeKHRAllocator>>::type getSurfacePresentModesKHR(
      SurfaceKHR surface, PresentModeKHRAllocator const & presentModeKHRAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_swapchain ===

    // wrapper function for command vkGetPhysicalDevicePresentRectanglesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
    VULKAN_HPP_NODISCARD Result getPresentRectanglesKHR( SurfaceKHR               surface,
                                                         uint32_t *               pRectCount,
                                                         Rect2D *                 pRects,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDevicePresentRectanglesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
    template <typename Rect2DAllocator = std::allocator<Rect2D>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<Rect2D, Rect2DAllocator>>::type
      getPresentRectanglesKHR( SurfaceKHR surface, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDevicePresentRectanglesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
    template <typename Rect2DAllocator = std::allocator<Rect2D>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<Rect2D, Rect2DAllocator>>::type getPresentRectanglesKHR(
      SurfaceKHR surface, Rect2DAllocator const & rect2DAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_display ===

    // wrapper function for command vkGetPhysicalDeviceDisplayPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
    VULKAN_HPP_NODISCARD Result getDisplayPropertiesKHR( uint32_t *               pPropertyCount,
                                                         DisplayPropertiesKHR *   pProperties,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceDisplayPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
    template <typename DisplayPropertiesKHRAllocator = std::allocator<DisplayPropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayPropertiesKHR, DisplayPropertiesKHRAllocator>>::type
      getDisplayPropertiesKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceDisplayPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
    template <typename DisplayPropertiesKHRAllocator = std::allocator<DisplayPropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayPropertiesKHR, DisplayPropertiesKHRAllocator>>::type
      getDisplayPropertiesKHR( DisplayPropertiesKHRAllocator const & displayPropertiesKHRAllocator,
                               DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceDisplayPlanePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
    VULKAN_HPP_NODISCARD Result getDisplayPlanePropertiesKHR( uint32_t *                  pPropertyCount,
                                                              DisplayPlanePropertiesKHR * pProperties,
                                                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceDisplayPlanePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
    template <typename DisplayPlanePropertiesKHRAllocator = std::allocator<DisplayPlanePropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayPlanePropertiesKHR, DisplayPlanePropertiesKHRAllocator>>::type
      getDisplayPlanePropertiesKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceDisplayPlanePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
    template <typename DisplayPlanePropertiesKHRAllocator = std::allocator<DisplayPlanePropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayPlanePropertiesKHR, DisplayPlanePropertiesKHRAllocator>>::type
      getDisplayPlanePropertiesKHR( DisplayPlanePropertiesKHRAllocator const & displayPlanePropertiesKHRAllocator,
                                    DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDisplayPlaneSupportedDisplaysKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
    VULKAN_HPP_NODISCARD Result
      getDisplayPlaneSupportedDisplaysKHR( uint32_t                 planeIndex,
                                           uint32_t *               pDisplayCount,
                                           DisplayKHR *             pDisplays,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDisplayPlaneSupportedDisplaysKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
    template <typename DisplayKHRAllocator = std::allocator<DisplayKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayKHR, DisplayKHRAllocator>>::type
      getDisplayPlaneSupportedDisplaysKHR( uint32_t planeIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDisplayPlaneSupportedDisplaysKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
    template <typename DisplayKHRAllocator = std::allocator<DisplayKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayKHR, DisplayKHRAllocator>>::type getDisplayPlaneSupportedDisplaysKHR(
      uint32_t planeIndex, DisplayKHRAllocator const & displayKHRAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDisplayModePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModePropertiesKHR.html
    VULKAN_HPP_NODISCARD Result getDisplayModePropertiesKHR( DisplayKHR                 display,
                                                             uint32_t *                 pPropertyCount,
                                                             DisplayModePropertiesKHR * pProperties,
                                                             DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDisplayModePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModePropertiesKHR.html
    template <typename DisplayModePropertiesKHRAllocator = std::allocator<DisplayModePropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayModePropertiesKHR, DisplayModePropertiesKHRAllocator>>::type
      getDisplayModePropertiesKHR( DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDisplayModePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModePropertiesKHR.html
    template <typename DisplayModePropertiesKHRAllocator = std::allocator<DisplayModePropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayModePropertiesKHR, DisplayModePropertiesKHRAllocator>>::type
      getDisplayModePropertiesKHR( DisplayKHR                                display,
                                   DisplayModePropertiesKHRAllocator const & displayModePropertiesKHRAllocator,
                                   DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkCreateDisplayModeKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayModeKHR.html
    VULKAN_HPP_NODISCARD Result createDisplayModeKHR( DisplayKHR                       display,
                                                      DisplayModeCreateInfoKHR const * pCreateInfo,
                                                      AllocationCallbacks const *      pAllocator,
                                                      DisplayModeKHR *                 pMode,
                                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDisplayModeKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayModeKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DisplayModeKHR>::type
      createDisplayModeKHR( DisplayKHR                                    display,
                            DisplayModeCreateInfoKHR const &              createInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDisplayModeKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayModeKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DisplayModeKHR>>::type
      createDisplayModeKHRUnique( DisplayKHR                                    display,
                                  DisplayModeCreateInfoKHR const &              createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDisplayPlaneCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD Result getDisplayPlaneCapabilitiesKHR( DisplayModeKHR                mode,
                                                                uint32_t                      planeIndex,
                                                                DisplayPlaneCapabilitiesKHR * pCapabilities,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDisplayPlaneCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DisplayPlaneCapabilitiesKHR>::type
      getDisplayPlaneCapabilitiesKHR( DisplayModeKHR mode, uint32_t planeIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_XLIB_KHR )
    //=== VK_KHR_xlib_surface ===

    // wrapper function for command vkGetPhysicalDeviceXlibPresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceXlibPresentationSupportKHR.html
    Bool32 getXlibPresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                          Display *                dpy,
                                          VisualID                 visualID,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceXlibPresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceXlibPresentationSupportKHR.html
    Bool32 getXlibPresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                          Display &                dpy,
                                          VisualID                 visualID,
                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_XLIB_KHR*/

#if defined( VK_USE_PLATFORM_XCB_KHR )
    //=== VK_KHR_xcb_surface ===

    // wrapper function for command vkGetPhysicalDeviceXcbPresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceXcbPresentationSupportKHR.html
    Bool32 getXcbPresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                         xcb_connection_t *       connection,
                                         xcb_visualid_t           visual_id,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceXcbPresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceXcbPresentationSupportKHR.html
    Bool32 getXcbPresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                         xcb_connection_t &       connection,
                                         xcb_visualid_t           visual_id,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_XCB_KHR*/

#if defined( VK_USE_PLATFORM_WAYLAND_KHR )
    //=== VK_KHR_wayland_surface ===

    // wrapper function for command vkGetPhysicalDeviceWaylandPresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceWaylandPresentationSupportKHR.html
    Bool32 getWaylandPresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                             struct wl_display *      display,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceWaylandPresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceWaylandPresentationSupportKHR.html
    Bool32 getWaylandPresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                             struct wl_display &      display,
                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WAYLAND_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_KHR_win32_surface ===

    // wrapper function for command vkGetPhysicalDeviceWin32PresentationSupportKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceWin32PresentationSupportKHR.html
    Bool32 getWin32PresentationSupportKHR( uint32_t                 queueFamilyIndex,
                                           DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_KHR_video_queue ===

    // wrapper function for command vkGetPhysicalDeviceVideoCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD Result getVideoCapabilitiesKHR( VideoProfileInfoKHR const * pVideoProfile,
                                                         VideoCapabilitiesKHR *      pCapabilities,
                                                         DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceVideoCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<VideoCapabilitiesKHR>::type
      getVideoCapabilitiesKHR( VideoProfileInfoKHR const & videoProfile, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceVideoCapabilitiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getVideoCapabilitiesKHR( VideoProfileInfoKHR const & videoProfile, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceVideoFormatPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
    VULKAN_HPP_NODISCARD Result getVideoFormatPropertiesKHR( PhysicalDeviceVideoFormatInfoKHR const * pVideoFormatInfo,
                                                             uint32_t *                               pVideoFormatPropertyCount,
                                                             VideoFormatPropertiesKHR *               pVideoFormatProperties,
                                                             DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceVideoFormatPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
    template <typename VideoFormatPropertiesKHRAllocator = std::allocator<VideoFormatPropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<VideoFormatPropertiesKHR, VideoFormatPropertiesKHRAllocator>>::type
      getVideoFormatPropertiesKHR( PhysicalDeviceVideoFormatInfoKHR const & videoFormatInfo,
                                   DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceVideoFormatPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
    template <typename VideoFormatPropertiesKHRAllocator = std::allocator<VideoFormatPropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<VideoFormatPropertiesKHR, VideoFormatPropertiesKHRAllocator>>::type
      getVideoFormatPropertiesKHR( PhysicalDeviceVideoFormatInfoKHR const &  videoFormatInfo,
                                   VideoFormatPropertiesKHRAllocator const & videoFormatPropertiesKHRAllocator,
                                   DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceVideoFormatPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<StructureChain, StructureChainAllocator>>::type
      getVideoFormatPropertiesKHR( PhysicalDeviceVideoFormatInfoKHR const & videoFormatInfo,
                                   DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceVideoFormatPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<StructureChain, StructureChainAllocator>>::type
      getVideoFormatPropertiesKHR( PhysicalDeviceVideoFormatInfoKHR const & videoFormatInfo,
                                   StructureChainAllocator &                structureChainAllocator,
                                   DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_external_memory_capabilities ===

    // wrapper function for command vkGetPhysicalDeviceExternalImageFormatPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html
    VULKAN_HPP_NODISCARD Result
      getExternalImageFormatPropertiesNV( Format                            format,
                                          ImageType                         type,
                                          ImageTiling                       tiling,
                                          ImageUsageFlags                   usage,
                                          ImageCreateFlags                  flags,
                                          ExternalMemoryHandleTypeFlagsNV   externalHandleType,
                                          ExternalImageFormatPropertiesNV * pExternalImageFormatProperties,
                                          DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalImageFormatPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ExternalImageFormatPropertiesNV>::type
      getExternalImageFormatPropertiesNV( Format                                             format,
                                          ImageType                                          type,
                                          ImageTiling                                        tiling,
                                          ImageUsageFlags                                    usage,
                                          ImageCreateFlags flags                             VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                          ExternalMemoryHandleTypeFlagsNV externalHandleType VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                          DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_get_physical_device_properties2 ===

    // wrapper function for command vkGetPhysicalDeviceFeatures2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2KHR.html
    void getFeatures2KHR( PhysicalDeviceFeatures2 * pFeatures, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFeatures2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2KHR.html
    VULKAN_HPP_NODISCARD PhysicalDeviceFeatures2 getFeatures2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceFeatures2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFeatures2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getFeatures2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2KHR.html
    void getProperties2KHR( PhysicalDeviceProperties2 * pProperties,
                            DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2KHR.html
    VULKAN_HPP_NODISCARD PhysicalDeviceProperties2
      getProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceProperties2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2KHR.html
    void getFormatProperties2KHR( Format                   format,
                                  FormatProperties2 *      pFormatProperties,
                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2KHR.html
    VULKAN_HPP_NODISCARD FormatProperties2
      getFormatProperties2KHR( Format format, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFormatProperties2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getFormatProperties2KHR( Format format, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2KHR.html
    VULKAN_HPP_NODISCARD Result getImageFormatProperties2KHR( PhysicalDeviceImageFormatInfo2 const * pImageFormatInfo,
                                                              ImageFormatProperties2 *               pImageFormatProperties,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2KHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<ImageFormatProperties2>::type
      getImageFormatProperties2KHR( PhysicalDeviceImageFormatInfo2 const & imageFormatInfo,
                                    DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceImageFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceImageFormatProperties2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getImageFormatProperties2KHR( PhysicalDeviceImageFormatInfo2 const & imageFormatInfo,
                                    DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html
    void getQueueFamilyProperties2KHR( uint32_t *               pQueueFamilyPropertyCount,
                                       QueueFamilyProperties2 * pQueueFamilyProperties,
                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html
    template <typename QueueFamilyProperties2Allocator = std::allocator<QueueFamilyProperties2>>
    VULKAN_HPP_NODISCARD std::vector<QueueFamilyProperties2, QueueFamilyProperties2Allocator>
                         getQueueFamilyProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html
    template <typename QueueFamilyProperties2Allocator = std::allocator<QueueFamilyProperties2>>
    VULKAN_HPP_NODISCARD std::vector<QueueFamilyProperties2, QueueFamilyProperties2Allocator>
                         getQueueFamilyProperties2KHR( QueueFamilyProperties2Allocator const & queueFamilyProperties2Allocator,
                                                       DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD std::vector<StructureChain, StructureChainAllocator>
                         getQueueFamilyProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyProperties2KHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD std::vector<StructureChain, StructureChainAllocator>
                         getQueueFamilyProperties2KHR( StructureChainAllocator & structureChainAllocator,
                                                       DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceMemoryProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2KHR.html
    void getMemoryProperties2KHR( PhysicalDeviceMemoryProperties2 * pMemoryProperties,
                                  DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceMemoryProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2KHR.html
    VULKAN_HPP_NODISCARD PhysicalDeviceMemoryProperties2
      getMemoryProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
    // wrapper function for command vkGetPhysicalDeviceMemoryProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMemoryProperties2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD StructureChain<X, Y, Z...>
                         getMemoryProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2KHR.html
    void getSparseImageFormatProperties2KHR( PhysicalDeviceSparseImageFormatInfo2 const * pFormatInfo,
                                             uint32_t *                                   pPropertyCount,
                                             SparseImageFormatProperties2 *               pProperties,
                                             DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2KHR.html
    template <typename SparseImageFormatProperties2Allocator = std::allocator<SparseImageFormatProperties2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageFormatProperties2, SparseImageFormatProperties2Allocator>
                         getSparseImageFormatProperties2KHR( PhysicalDeviceSparseImageFormatInfo2 const & formatInfo,
                                                             DispatchLoader const & d                     VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSparseImageFormatProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2KHR.html
    template <typename SparseImageFormatProperties2Allocator = std::allocator<SparseImageFormatProperties2>>
    VULKAN_HPP_NODISCARD std::vector<SparseImageFormatProperties2, SparseImageFormatProperties2Allocator>
                         getSparseImageFormatProperties2KHR( PhysicalDeviceSparseImageFormatInfo2 const &  formatInfo,
                                                             SparseImageFormatProperties2Allocator const & sparseImageFormatProperties2Allocator,
                                                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_external_memory_capabilities ===

    // wrapper function for command vkGetPhysicalDeviceExternalBufferPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferPropertiesKHR.html
    void getExternalBufferPropertiesKHR( PhysicalDeviceExternalBufferInfo const * pExternalBufferInfo,
                                         ExternalBufferProperties *               pExternalBufferProperties,
                                         DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalBufferPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalBufferPropertiesKHR.html
    VULKAN_HPP_NODISCARD ExternalBufferProperties
      getExternalBufferPropertiesKHR( PhysicalDeviceExternalBufferInfo const & externalBufferInfo,
                                      DispatchLoader const & d                 VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_external_semaphore_capabilities ===

    // wrapper function for command vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.html
    void getExternalSemaphorePropertiesKHR( PhysicalDeviceExternalSemaphoreInfo const * pExternalSemaphoreInfo,
                                            ExternalSemaphoreProperties *               pExternalSemaphoreProperties,
                                            DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.html
    VULKAN_HPP_NODISCARD ExternalSemaphoreProperties
      getExternalSemaphorePropertiesKHR( PhysicalDeviceExternalSemaphoreInfo const & externalSemaphoreInfo,
                                         DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_direct_mode_display ===

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkReleaseDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseDisplayEXT.html
    VULKAN_HPP_NODISCARD Result releaseDisplayEXT( DisplayKHR               display,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkReleaseDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkReleaseDisplayEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      releaseDisplayEXT( DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

#if defined( VK_USE_PLATFORM_XLIB_XRANDR_EXT )
    //=== VK_EXT_acquire_xlib_display ===

    // wrapper function for command vkAcquireXlibDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireXlibDisplayEXT.html
    VULKAN_HPP_NODISCARD Result acquireXlibDisplayEXT( Display *                dpy,
                                                       DisplayKHR               display,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireXlibDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireXlibDisplayEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      acquireXlibDisplayEXT( Display & dpy, DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetRandROutputDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRandROutputDisplayEXT.html
    VULKAN_HPP_NODISCARD Result getRandROutputDisplayEXT( Display *                dpy,
                                                          RROutput                 rrOutput,
                                                          DisplayKHR *             pDisplay,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetRandROutputDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRandROutputDisplayEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DisplayKHR>::type
      getRandROutputDisplayEXT( Display & dpy, RROutput rrOutput, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkGetRandROutputDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetRandROutputDisplayEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DisplayKHR>>::type
      getRandROutputDisplayEXTUnique( Display & dpy, RROutput rrOutput, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_XLIB_XRANDR_EXT*/

    //=== VK_EXT_display_surface_counter ===

    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilities2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html
    VULKAN_HPP_NODISCARD Result getSurfaceCapabilities2EXT( SurfaceKHR                surface,
                                                            SurfaceCapabilities2EXT * pSurfaceCapabilities,
                                                            DispatchLoader const & d  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilities2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceCapabilities2EXT>::type
      getSurfaceCapabilities2EXT( SurfaceKHR surface, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_external_fence_capabilities ===

    // wrapper function for command vkGetPhysicalDeviceExternalFencePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFencePropertiesKHR.html
    void getExternalFencePropertiesKHR( PhysicalDeviceExternalFenceInfo const * pExternalFenceInfo,
                                        ExternalFenceProperties *               pExternalFenceProperties,
                                        DispatchLoader const & d                VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalFencePropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalFencePropertiesKHR.html
    VULKAN_HPP_NODISCARD ExternalFenceProperties getExternalFencePropertiesKHR(
      PhysicalDeviceExternalFenceInfo const & externalFenceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_performance_query ===

    // wrapper function for command vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html
    VULKAN_HPP_NODISCARD Result
      enumerateQueueFamilyPerformanceQueryCountersKHR( uint32_t                           queueFamilyIndex,
                                                       uint32_t *                         pCounterCount,
                                                       PerformanceCounterKHR *            pCounters,
                                                       PerformanceCounterDescriptionKHR * pCounterDescriptions,
                                                       DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html
    template <typename PerformanceCounterKHRAllocator            = std::allocator<PerformanceCounterKHR>,
              typename PerformanceCounterDescriptionKHRAllocator = std::allocator<PerformanceCounterDescriptionKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<PerformanceCounterKHR, PerformanceCounterKHRAllocator>,
                                                            std::vector<PerformanceCounterDescriptionKHR, PerformanceCounterDescriptionKHRAllocator>>>::type
      enumerateQueueFamilyPerformanceQueryCountersKHR( uint32_t queueFamilyIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html
    template <typename PerformanceCounterKHRAllocator            = std::allocator<PerformanceCounterKHR>,
              typename PerformanceCounterDescriptionKHRAllocator = std::allocator<PerformanceCounterDescriptionKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<PerformanceCounterKHR, PerformanceCounterKHRAllocator>,
                                                            std::vector<PerformanceCounterDescriptionKHR, PerformanceCounterDescriptionKHRAllocator>>>::type
      enumerateQueueFamilyPerformanceQueryCountersKHR( uint32_t                                          queueFamilyIndex,
                                                       PerformanceCounterKHRAllocator const &            performanceCounterKHRAllocator,
                                                       PerformanceCounterDescriptionKHRAllocator const & performanceCounterDescriptionKHRAllocator,
                                                       DispatchLoader const & d                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html
    void getQueueFamilyPerformanceQueryPassesKHR( QueryPoolPerformanceCreateInfoKHR const * pPerformanceQueryCreateInfo,
                                                  uint32_t *                                pNumPasses,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html
    VULKAN_HPP_NODISCARD uint32_t
      getQueueFamilyPerformanceQueryPassesKHR( QueryPoolPerformanceCreateInfoKHR const & performanceQueryCreateInfo,
                                               DispatchLoader const & d                  VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_get_surface_capabilities2 ===

    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilities2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
    VULKAN_HPP_NODISCARD Result getSurfaceCapabilities2KHR( PhysicalDeviceSurfaceInfo2KHR const * pSurfaceInfo,
                                                            SurfaceCapabilities2KHR *             pSurfaceCapabilities,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilities2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceCapabilities2KHR>::type
      getSurfaceCapabilities2KHR( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfaceCapabilities2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getSurfaceCapabilities2KHR( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceSurfaceFormats2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
    VULKAN_HPP_NODISCARD Result getSurfaceFormats2KHR( PhysicalDeviceSurfaceInfo2KHR const * pSurfaceInfo,
                                                       uint32_t *                            pSurfaceFormatCount,
                                                       SurfaceFormat2KHR *                   pSurfaceFormats,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfaceFormats2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
    template <typename SurfaceFormat2KHRAllocator = std::allocator<SurfaceFormat2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<SurfaceFormat2KHR, SurfaceFormat2KHRAllocator>>::type
      getSurfaceFormats2KHR( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfaceFormats2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
    template <typename SurfaceFormat2KHRAllocator = std::allocator<SurfaceFormat2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<SurfaceFormat2KHR, SurfaceFormat2KHRAllocator>>::type
      getSurfaceFormats2KHR( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo,
                             SurfaceFormat2KHRAllocator const &    surfaceFormat2KHRAllocator,
                             DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfaceFormats2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<StructureChain, StructureChainAllocator>>::type
      getSurfaceFormats2KHR( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfaceFormats2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<StructureChain, StructureChainAllocator>>::type
      getSurfaceFormats2KHR( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo,
                             StructureChainAllocator &             structureChainAllocator,
                             DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_get_display_properties2 ===

    // wrapper function for command vkGetPhysicalDeviceDisplayProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
    VULKAN_HPP_NODISCARD Result getDisplayProperties2KHR( uint32_t *               pPropertyCount,
                                                          DisplayProperties2KHR *  pProperties,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceDisplayProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
    template <typename DisplayProperties2KHRAllocator = std::allocator<DisplayProperties2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayProperties2KHR, DisplayProperties2KHRAllocator>>::type
      getDisplayProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceDisplayProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
    template <typename DisplayProperties2KHRAllocator = std::allocator<DisplayProperties2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayProperties2KHR, DisplayProperties2KHRAllocator>>::type
      getDisplayProperties2KHR( DisplayProperties2KHRAllocator const & displayProperties2KHRAllocator,
                                DispatchLoader const & d               VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceDisplayPlaneProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
    VULKAN_HPP_NODISCARD Result getDisplayPlaneProperties2KHR( uint32_t *                   pPropertyCount,
                                                               DisplayPlaneProperties2KHR * pProperties,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceDisplayPlaneProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
    template <typename DisplayPlaneProperties2KHRAllocator = std::allocator<DisplayPlaneProperties2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayPlaneProperties2KHR, DisplayPlaneProperties2KHRAllocator>>::type
      getDisplayPlaneProperties2KHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceDisplayPlaneProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
    template <typename DisplayPlaneProperties2KHRAllocator = std::allocator<DisplayPlaneProperties2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayPlaneProperties2KHR, DisplayPlaneProperties2KHRAllocator>>::type
      getDisplayPlaneProperties2KHR( DisplayPlaneProperties2KHRAllocator const & displayPlaneProperties2KHRAllocator,
                                     DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDisplayModeProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModeProperties2KHR.html
    VULKAN_HPP_NODISCARD Result getDisplayModeProperties2KHR( DisplayKHR                  display,
                                                              uint32_t *                  pPropertyCount,
                                                              DisplayModeProperties2KHR * pProperties,
                                                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDisplayModeProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModeProperties2KHR.html
    template <typename DisplayModeProperties2KHRAllocator = std::allocator<DisplayModeProperties2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayModeProperties2KHR, DisplayModeProperties2KHRAllocator>>::type
      getDisplayModeProperties2KHR( DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDisplayModeProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModeProperties2KHR.html
    template <typename DisplayModeProperties2KHRAllocator = std::allocator<DisplayModeProperties2KHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<DisplayModeProperties2KHR, DisplayModeProperties2KHRAllocator>>::type
      getDisplayModeProperties2KHR( DisplayKHR                                 display,
                                    DisplayModeProperties2KHRAllocator const & displayModeProperties2KHRAllocator,
                                    DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDisplayModeProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModeProperties2KHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<StructureChain, StructureChainAllocator>>::type
      getDisplayModeProperties2KHR( DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetDisplayModeProperties2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayModeProperties2KHR.html
    template <typename StructureChain, typename StructureChainAllocator = std::allocator<StructureChain>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<StructureChain, StructureChainAllocator>>::type getDisplayModeProperties2KHR(
      DisplayKHR display, StructureChainAllocator & structureChainAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetDisplayPlaneCapabilities2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneCapabilities2KHR.html
    VULKAN_HPP_NODISCARD Result getDisplayPlaneCapabilities2KHR( DisplayPlaneInfo2KHR const *   pDisplayPlaneInfo,
                                                                 DisplayPlaneCapabilities2KHR * pCapabilities,
                                                                 DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDisplayPlaneCapabilities2KHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDisplayPlaneCapabilities2KHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DisplayPlaneCapabilities2KHR>::type
      getDisplayPlaneCapabilities2KHR( DisplayPlaneInfo2KHR const & displayPlaneInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_descriptor_heap ===

    // wrapper function for command vkGetPhysicalDeviceDescriptorSizeEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDescriptorSizeEXT.html
    DeviceSize getDescriptorSizeEXT( DescriptorType           descriptorType,
                                     DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;

    //=== VK_EXT_sample_locations ===

    // wrapper function for command vkGetPhysicalDeviceMultisamplePropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html
    void getMultisamplePropertiesEXT( SampleCountFlagBits        samples,
                                      MultisamplePropertiesEXT * pMultisampleProperties,
                                      DispatchLoader const & d   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceMultisamplePropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html
    VULKAN_HPP_NODISCARD MultisamplePropertiesEXT
      getMultisamplePropertiesEXT( SampleCountFlagBits samples, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_calibrated_timestamps ===

    // wrapper function for command vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html
    VULKAN_HPP_NODISCARD Result getCalibrateableTimeDomainsEXT( uint32_t *               pTimeDomainCount,
                                                                TimeDomainKHR *          pTimeDomains,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html
    template <typename TimeDomainKHRAllocator = std::allocator<TimeDomainKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<TimeDomainKHR, TimeDomainKHRAllocator>>::type
      getCalibrateableTimeDomainsEXT( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html
    template <typename TimeDomainKHRAllocator = std::allocator<TimeDomainKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<TimeDomainKHR, TimeDomainKHRAllocator>>::type
      getCalibrateableTimeDomainsEXT( TimeDomainKHRAllocator const & timeDomainKHRAllocator,
                                      DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_fragment_shading_rate ===

    // wrapper function for command vkGetPhysicalDeviceFragmentShadingRatesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html
    VULKAN_HPP_NODISCARD Result getFragmentShadingRatesKHR( uint32_t *                             pFragmentShadingRateCount,
                                                            PhysicalDeviceFragmentShadingRateKHR * pFragmentShadingRates,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceFragmentShadingRatesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html
    template <typename PhysicalDeviceFragmentShadingRateKHRAllocator = std::allocator<PhysicalDeviceFragmentShadingRateKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceFragmentShadingRateKHR, PhysicalDeviceFragmentShadingRateKHRAllocator>>::type
      getFragmentShadingRatesKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceFragmentShadingRatesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html
    template <typename PhysicalDeviceFragmentShadingRateKHRAllocator = std::allocator<PhysicalDeviceFragmentShadingRateKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceFragmentShadingRateKHR, PhysicalDeviceFragmentShadingRateKHRAllocator>>::type
      getFragmentShadingRatesKHR( PhysicalDeviceFragmentShadingRateKHRAllocator const & physicalDeviceFragmentShadingRateKHRAllocator,
                                  DispatchLoader const & d                              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_EXT_tooling_info ===

    // wrapper function for command vkGetPhysicalDeviceToolPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html
    VULKAN_HPP_NODISCARD Result getToolPropertiesEXT( uint32_t *                     pToolCount,
                                                      PhysicalDeviceToolProperties * pToolProperties,
                                                      DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceToolPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html
    template <typename PhysicalDeviceToolPropertiesAllocator = std::allocator<PhysicalDeviceToolProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceToolProperties, PhysicalDeviceToolPropertiesAllocator>>::type
      getToolPropertiesEXT( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceToolPropertiesEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html
    template <typename PhysicalDeviceToolPropertiesAllocator = std::allocator<PhysicalDeviceToolProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceToolProperties, PhysicalDeviceToolPropertiesAllocator>>::type
      getToolPropertiesEXT( PhysicalDeviceToolPropertiesAllocator const & physicalDeviceToolPropertiesAllocator,
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_cooperative_matrix ===

    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html
    VULKAN_HPP_NODISCARD Result getCooperativeMatrixPropertiesNV( uint32_t *                      pPropertyCount,
                                                                  CooperativeMatrixPropertiesNV * pProperties,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html
    template <typename CooperativeMatrixPropertiesNVAllocator = std::allocator<CooperativeMatrixPropertiesNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CooperativeMatrixPropertiesNV, CooperativeMatrixPropertiesNVAllocator>>::type
      getCooperativeMatrixPropertiesNV( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html
    template <typename CooperativeMatrixPropertiesNVAllocator = std::allocator<CooperativeMatrixPropertiesNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CooperativeMatrixPropertiesNV, CooperativeMatrixPropertiesNVAllocator>>::type
      getCooperativeMatrixPropertiesNV( CooperativeMatrixPropertiesNVAllocator const & cooperativeMatrixPropertiesNVAllocator,
                                        DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_coverage_reduction_mode ===

    // wrapper function for command vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html
    VULKAN_HPP_NODISCARD Result
      getSupportedFramebufferMixedSamplesCombinationsNV( uint32_t *                             pCombinationCount,
                                                         FramebufferMixedSamplesCombinationNV * pCombinations,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html
    template <typename FramebufferMixedSamplesCombinationNVAllocator = std::allocator<FramebufferMixedSamplesCombinationNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<FramebufferMixedSamplesCombinationNV, FramebufferMixedSamplesCombinationNVAllocator>>::type
      getSupportedFramebufferMixedSamplesCombinationsNV( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html
    template <typename FramebufferMixedSamplesCombinationNVAllocator = std::allocator<FramebufferMixedSamplesCombinationNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<FramebufferMixedSamplesCombinationNV, FramebufferMixedSamplesCombinationNVAllocator>>::type
      getSupportedFramebufferMixedSamplesCombinationsNV( FramebufferMixedSamplesCombinationNVAllocator const & framebufferMixedSamplesCombinationNVAllocator,
                                                         DispatchLoader const & d                              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_EXT_full_screen_exclusive ===

    // wrapper function for command vkGetPhysicalDeviceSurfacePresentModes2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModes2EXT.html
    VULKAN_HPP_NODISCARD Result getSurfacePresentModes2EXT( PhysicalDeviceSurfaceInfo2KHR const * pSurfaceInfo,
                                                            uint32_t *                            pPresentModeCount,
                                                            PresentModeKHR *                      pPresentModes,
                                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceSurfacePresentModes2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModes2EXT.html
    template <typename PresentModeKHRAllocator = std::allocator<PresentModeKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PresentModeKHR, PresentModeKHRAllocator>>::type
      getSurfacePresentModes2EXT( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceSurfacePresentModes2EXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceSurfacePresentModes2EXT.html
    template <typename PresentModeKHRAllocator = std::allocator<PresentModeKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PresentModeKHR, PresentModeKHRAllocator>>::type
      getSurfacePresentModes2EXT( PhysicalDeviceSurfaceInfo2KHR const & surfaceInfo,
                                  PresentModeKHRAllocator const &       presentModeKHRAllocator,
                                  DispatchLoader const & d              VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_EXT_acquire_drm_display ===

#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireDrmDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireDrmDisplayEXT.html
    VULKAN_HPP_NODISCARD Result acquireDrmDisplayEXT( int32_t                  drmFd,
                                                      DisplayKHR               display,
                                                      DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#else
    // wrapper function for command vkAcquireDrmDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireDrmDisplayEXT.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      acquireDrmDisplayEXT( int32_t drmFd, DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetDrmDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDrmDisplayEXT.html
    VULKAN_HPP_NODISCARD Result getDrmDisplayEXT( int32_t                  drmFd,
                                                  uint32_t                 connectorId,
                                                  DisplayKHR *             display,
                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetDrmDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDrmDisplayEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DisplayKHR>::type
      getDrmDisplayEXT( int32_t drmFd, uint32_t connectorId, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkGetDrmDisplayEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetDrmDisplayEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DisplayKHR>>::type
      getDrmDisplayEXTUnique( int32_t drmFd, uint32_t connectorId, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_video_encode_queue ===

    // wrapper function for command vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html
    VULKAN_HPP_NODISCARD Result
      getVideoEncodeQualityLevelPropertiesKHR( PhysicalDeviceVideoEncodeQualityLevelInfoKHR const * pQualityLevelInfo,
                                               VideoEncodeQualityLevelPropertiesKHR *               pQualityLevelProperties,
                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<VideoEncodeQualityLevelPropertiesKHR>::type
      getVideoEncodeQualityLevelPropertiesKHR( PhysicalDeviceVideoEncodeQualityLevelInfoKHR const & qualityLevelInfo,
                                               DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html
    template <typename X, typename Y, typename... Z>
    VULKAN_HPP_NODISCARD typename ResultValueType<StructureChain<X, Y, Z...>>::type
      getVideoEncodeQualityLevelPropertiesKHR( PhysicalDeviceVideoEncodeQualityLevelInfoKHR const & qualityLevelInfo,
                                               DispatchLoader const & d                             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_NV_acquire_winrt_display ===

#  ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkAcquireWinrtDisplayNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireWinrtDisplayNV.html
    VULKAN_HPP_NODISCARD Result acquireWinrtDisplayNV( DisplayKHR               display,
                                                       DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  else
    // wrapper function for command vkAcquireWinrtDisplayNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkAcquireWinrtDisplayNV.html
    VULKAN_HPP_NODISCARD_WHEN_NO_EXCEPTIONS typename ResultValueType<void>::type
      acquireWinrtDisplayNV( DisplayKHR display, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/

    // wrapper function for command vkGetWinrtDisplayNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetWinrtDisplayNV.html
    VULKAN_HPP_NODISCARD Result getWinrtDisplayNV( uint32_t                 deviceRelativeId,
                                                   DisplayKHR *             pDisplay,
                                                   DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetWinrtDisplayNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetWinrtDisplayNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DisplayKHR>::type
      getWinrtDisplayNV( uint32_t deviceRelativeId, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkGetWinrtDisplayNV, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetWinrtDisplayNV.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DisplayKHR>>::type
      getWinrtDisplayNVUnique( uint32_t deviceRelativeId, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_WIN32_KHR*/

#if defined( VK_USE_PLATFORM_DIRECTFB_EXT )
    //=== VK_EXT_directfb_surface ===

    // wrapper function for command vkGetPhysicalDeviceDirectFBPresentationSupportEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDirectFBPresentationSupportEXT.html
    Bool32 getDirectFBPresentationSupportEXT( uint32_t                 queueFamilyIndex,
                                              IDirectFB *              dfb,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceDirectFBPresentationSupportEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceDirectFBPresentationSupportEXT.html
    Bool32 getDirectFBPresentationSupportEXT( uint32_t                 queueFamilyIndex,
                                              IDirectFB &              dfb,
                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_DIRECTFB_EXT*/

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
    //=== VK_QNX_screen_surface ===

    // wrapper function for command vkGetPhysicalDeviceScreenPresentationSupportQNX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceScreenPresentationSupportQNX.html
    Bool32 getScreenPresentationSupportQNX( uint32_t                 queueFamilyIndex,
                                            struct _screen_window *  window,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceScreenPresentationSupportQNX, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceScreenPresentationSupportQNX.html
    Bool32 getScreenPresentationSupportQNX( uint32_t                 queueFamilyIndex,
                                            struct _screen_window &  window,
                                            DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_SCREEN_QNX*/

    //=== VK_ARM_tensors ===

    // wrapper function for command vkGetPhysicalDeviceExternalTensorPropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalTensorPropertiesARM.html
    void getExternalTensorPropertiesARM( PhysicalDeviceExternalTensorInfoARM const * pExternalTensorInfo,
                                         ExternalTensorPropertiesARM *               pExternalTensorProperties,
                                         DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceExternalTensorPropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceExternalTensorPropertiesARM.html
    VULKAN_HPP_NODISCARD ExternalTensorPropertiesARM
      getExternalTensorPropertiesARM( PhysicalDeviceExternalTensorInfoARM const & externalTensorInfo,
                                      DispatchLoader const & d                    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_optical_flow ===

    // wrapper function for command vkGetPhysicalDeviceOpticalFlowImageFormatsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html
    VULKAN_HPP_NODISCARD Result getOpticalFlowImageFormatsNV( OpticalFlowImageFormatInfoNV const * pOpticalFlowImageFormatInfo,
                                                              uint32_t *                           pFormatCount,
                                                              OpticalFlowImageFormatPropertiesNV * pImageFormatProperties,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceOpticalFlowImageFormatsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html
    template <typename OpticalFlowImageFormatPropertiesNVAllocator = std::allocator<OpticalFlowImageFormatPropertiesNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<OpticalFlowImageFormatPropertiesNV, OpticalFlowImageFormatPropertiesNVAllocator>>::type
      getOpticalFlowImageFormatsNV( OpticalFlowImageFormatInfoNV const & opticalFlowImageFormatInfo,
                                    DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceOpticalFlowImageFormatsNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html
    template <typename OpticalFlowImageFormatPropertiesNVAllocator = std::allocator<OpticalFlowImageFormatPropertiesNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<OpticalFlowImageFormatPropertiesNV, OpticalFlowImageFormatPropertiesNVAllocator>>::type
      getOpticalFlowImageFormatsNV( OpticalFlowImageFormatInfoNV const &                opticalFlowImageFormatInfo,
                                    OpticalFlowImageFormatPropertiesNVAllocator const & opticalFlowImageFormatPropertiesNVAllocator,
                                    DispatchLoader const & d                            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_cooperative_vector ===

    // wrapper function for command vkGetPhysicalDeviceCooperativeVectorPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeVectorPropertiesNV.html
    VULKAN_HPP_NODISCARD Result getCooperativeVectorPropertiesNV( uint32_t *                      pPropertyCount,
                                                                  CooperativeVectorPropertiesNV * pProperties,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceCooperativeVectorPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeVectorPropertiesNV.html
    template <typename CooperativeVectorPropertiesNVAllocator = std::allocator<CooperativeVectorPropertiesNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CooperativeVectorPropertiesNV, CooperativeVectorPropertiesNVAllocator>>::type
      getCooperativeVectorPropertiesNV( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceCooperativeVectorPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeVectorPropertiesNV.html
    template <typename CooperativeVectorPropertiesNVAllocator = std::allocator<CooperativeVectorPropertiesNV>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CooperativeVectorPropertiesNV, CooperativeVectorPropertiesNVAllocator>>::type
      getCooperativeVectorPropertiesNV( CooperativeVectorPropertiesNVAllocator const & cooperativeVectorPropertiesNVAllocator,
                                        DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_cooperative_matrix ===

    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html
    VULKAN_HPP_NODISCARD Result
      getCooperativeMatrixPropertiesKHR( uint32_t *                       pPropertyCount,
                                         CooperativeMatrixPropertiesKHR * pProperties,
                                         DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html
    template <typename CooperativeMatrixPropertiesKHRAllocator = std::allocator<CooperativeMatrixPropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CooperativeMatrixPropertiesKHR, CooperativeMatrixPropertiesKHRAllocator>>::type
      getCooperativeMatrixPropertiesKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html
    template <typename CooperativeMatrixPropertiesKHRAllocator = std::allocator<CooperativeMatrixPropertiesKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<CooperativeMatrixPropertiesKHR, CooperativeMatrixPropertiesKHRAllocator>>::type
      getCooperativeMatrixPropertiesKHR( CooperativeMatrixPropertiesKHRAllocator const & cooperativeMatrixPropertiesKHRAllocator,
                                         DispatchLoader const & d                        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_ARM_data_graph ===

    // wrapper function for command vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM.html
    VULKAN_HPP_NODISCARD Result
      getQueueFamilyDataGraphPropertiesARM( uint32_t                            queueFamilyIndex,
                                            uint32_t *                          pQueueFamilyDataGraphPropertyCount,
                                            QueueFamilyDataGraphPropertiesARM * pQueueFamilyDataGraphProperties,
                                            DispatchLoader const & d            VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM.html
    template <typename QueueFamilyDataGraphPropertiesARMAllocator = std::allocator<QueueFamilyDataGraphPropertiesARM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<QueueFamilyDataGraphPropertiesARM, QueueFamilyDataGraphPropertiesARMAllocator>>::type
      getQueueFamilyDataGraphPropertiesARM( uint32_t queueFamilyIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM.html
    template <typename QueueFamilyDataGraphPropertiesARMAllocator = std::allocator<QueueFamilyDataGraphPropertiesARM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<QueueFamilyDataGraphPropertiesARM, QueueFamilyDataGraphPropertiesARMAllocator>>::type
      getQueueFamilyDataGraphPropertiesARM( uint32_t                                           queueFamilyIndex,
                                            QueueFamilyDataGraphPropertiesARMAllocator const & queueFamilyDataGraphPropertiesARMAllocator,
                                            DispatchLoader const & d                           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM.html
    void getQueueFamilyDataGraphProcessingEnginePropertiesARM(
      PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM const * pQueueFamilyDataGraphProcessingEngineInfo,
      QueueFamilyDataGraphProcessingEnginePropertiesARM *               pQueueFamilyDataGraphProcessingEngineProperties,
      DispatchLoader const & d                                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM.html
    VULKAN_HPP_NODISCARD QueueFamilyDataGraphProcessingEnginePropertiesARM getQueueFamilyDataGraphProcessingEnginePropertiesARM(
      PhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM const & queueFamilyDataGraphProcessingEngineInfo,
      DispatchLoader const & d                                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_calibrated_timestamps ===

    // wrapper function for command vkGetPhysicalDeviceCalibrateableTimeDomainsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html
    VULKAN_HPP_NODISCARD Result getCalibrateableTimeDomainsKHR( uint32_t *               pTimeDomainCount,
                                                                TimeDomainKHR *          pTimeDomains,
                                                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceCalibrateableTimeDomainsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html
    template <typename TimeDomainKHRAllocator = std::allocator<TimeDomainKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<TimeDomainKHR, TimeDomainKHRAllocator>>::type
      getCalibrateableTimeDomainsKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceCalibrateableTimeDomainsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html
    template <typename TimeDomainKHRAllocator = std::allocator<TimeDomainKHR>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<TimeDomainKHR, TimeDomainKHRAllocator>>::type
      getCalibrateableTimeDomainsKHR( TimeDomainKHRAllocator const & timeDomainKHRAllocator,
                                      DispatchLoader const & d       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_NV_cooperative_matrix2 ===

    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV.html
    VULKAN_HPP_NODISCARD Result
      getCooperativeMatrixFlexibleDimensionsPropertiesNV( uint32_t *                                        pPropertyCount,
                                                          CooperativeMatrixFlexibleDimensionsPropertiesNV * pProperties,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV.html
    template <typename CooperativeMatrixFlexibleDimensionsPropertiesNVAllocator = std::allocator<CooperativeMatrixFlexibleDimensionsPropertiesNV>>
    VULKAN_HPP_NODISCARD
      typename ResultValueType<std::vector<CooperativeMatrixFlexibleDimensionsPropertiesNV, CooperativeMatrixFlexibleDimensionsPropertiesNVAllocator>>::type
      getCooperativeMatrixFlexibleDimensionsPropertiesNV( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV.html
    template <typename CooperativeMatrixFlexibleDimensionsPropertiesNVAllocator = std::allocator<CooperativeMatrixFlexibleDimensionsPropertiesNV>>
    VULKAN_HPP_NODISCARD
      typename ResultValueType<std::vector<CooperativeMatrixFlexibleDimensionsPropertiesNV, CooperativeMatrixFlexibleDimensionsPropertiesNVAllocator>>::type
      getCooperativeMatrixFlexibleDimensionsPropertiesNV(
        CooperativeMatrixFlexibleDimensionsPropertiesNVAllocator const & cooperativeMatrixFlexibleDimensionsPropertiesNVAllocator,
        DispatchLoader const & d                                         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_ARM_performance_counters_by_region ===

    // wrapper function for command vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM.html
    VULKAN_HPP_NODISCARD Result
      enumerateQueueFamilyPerformanceCountersByRegionARM( uint32_t                           queueFamilyIndex,
                                                          uint32_t *                         pCounterCount,
                                                          PerformanceCounterARM *            pCounters,
                                                          PerformanceCounterDescriptionARM * pCounterDescriptions,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM.html
    template <typename PerformanceCounterARMAllocator            = std::allocator<PerformanceCounterARM>,
              typename PerformanceCounterDescriptionARMAllocator = std::allocator<PerformanceCounterDescriptionARM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<PerformanceCounterARM, PerformanceCounterARMAllocator>,
                                                            std::vector<PerformanceCounterDescriptionARM, PerformanceCounterDescriptionARMAllocator>>>::type
      enumerateQueueFamilyPerformanceCountersByRegionARM( uint32_t queueFamilyIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM.html
    template <typename PerformanceCounterARMAllocator            = std::allocator<PerformanceCounterARM>,
              typename PerformanceCounterDescriptionARMAllocator = std::allocator<PerformanceCounterDescriptionARM>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::pair<std::vector<PerformanceCounterARM, PerformanceCounterARMAllocator>,
                                                            std::vector<PerformanceCounterDescriptionARM, PerformanceCounterDescriptionARMAllocator>>>::type
      enumerateQueueFamilyPerformanceCountersByRegionARM( uint32_t                                          queueFamilyIndex,
                                                          PerformanceCounterARMAllocator const &            performanceCounterARMAllocator,
                                                          PerformanceCounterDescriptionARMAllocator const & performanceCounterDescriptionARMAllocator,
                                                          DispatchLoader const & d                          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_UBM_SEC )
    //=== VK_SEC_ubm_surface ===

    // wrapper function for command vkGetPhysicalDeviceUbmPresentationSupportSEC, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceUbmPresentationSupportSEC.html
    Bool32 getUbmPresentationSupportSEC( uint32_t                 queueFamilyIndex,
                                         struct ubm_device *      ubm_device,
                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetPhysicalDeviceUbmPresentationSupportSEC, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetPhysicalDeviceUbmPresentationSupportSEC.html
    VULKAN_HPP_NODISCARD std::pair<Bool32, struct ubm_device>
      getUbmPresentationSupportSEC( uint32_t queueFamilyIndex, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif   /*VK_USE_PLATFORM_UBM_SEC*/

    operator VkPhysicalDevice() const VULKAN_HPP_NOEXCEPT
    {
      return m_physicalDevice;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_physicalDevice != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_physicalDevice == VK_NULL_HANDLE;
    }

  private:
    VkPhysicalDevice m_physicalDevice = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::ePhysicalDevice>
  {
    using Type = PhysicalDevice;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::ePhysicalDevice>
  {
    using Type = PhysicalDevice;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkPhysicalDevice, VK_NULL_HANDLE>
  {
    using Type = PhysicalDevice;
  };
#endif

  template <>
  struct isVulkanHandleType<PhysicalDevice>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  // wrapper class for handle VkInstance, see https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstance.html
  class Instance
  {
  public:
    using CType      = VkInstance;
    using NativeType = VkInstance;

    static VULKAN_HPP_CONST_OR_CONSTEXPR ObjectType               objectType            = ObjectType::eInstance;
    static VULKAN_HPP_CONST_OR_CONSTEXPR DebugReportObjectTypeEXT debugReportObjectType = DebugReportObjectTypeEXT::eInstance;

  public:
    Instance() VULKAN_HPP_NOEXCEPT {}  // = default; - try to workaround a compiler issue

    Instance( Instance const & rhs )             = default;
    Instance & operator=( Instance const & rhs ) = default;

#if !defined( VULKAN_HPP_HANDLES_MOVE_EXCHANGE )
    Instance( Instance && rhs )             = default;
    Instance & operator=( Instance && rhs ) = default;
#else
    Instance( Instance && rhs ) VULKAN_HPP_NOEXCEPT : m_instance( exchange( rhs.m_instance, {} ) ) {}

    Instance & operator=( Instance && rhs ) VULKAN_HPP_NOEXCEPT
    {
      m_instance = exchange( rhs.m_instance, {} );
      return *this;
    }
#endif

    VULKAN_HPP_CONSTEXPR Instance( std::nullptr_t ) VULKAN_HPP_NOEXCEPT {}

    Instance( VkInstance instance ) VULKAN_HPP_NOEXCEPT : m_instance( instance ) {}

    Instance & operator=( VkInstance instance ) VULKAN_HPP_NOEXCEPT
    {
      m_instance = instance;
      return *this;
    }

    Instance & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT
    {
      m_instance = {};
      return *this;
    }

    //=== VK_VERSION_1_0 ===

    // wrapper function for command vkDestroyInstance, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyInstance.html
    void destroy( AllocationCallbacks const * pAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyInstance, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyInstance.html
    void destroy( Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkEnumeratePhysicalDevices, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDevices.html
    VULKAN_HPP_NODISCARD Result enumeratePhysicalDevices( uint32_t *               pPhysicalDeviceCount,
                                                          PhysicalDevice *         pPhysicalDevices,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumeratePhysicalDevices, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDevices.html
    template <typename PhysicalDeviceAllocator = std::allocator<PhysicalDevice>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDevice, PhysicalDeviceAllocator>>::type
      enumeratePhysicalDevices( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumeratePhysicalDevices, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDevices.html
    template <typename PhysicalDeviceAllocator = std::allocator<PhysicalDevice>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDevice, PhysicalDeviceAllocator>>::type
      enumeratePhysicalDevices( PhysicalDeviceAllocator const & physicalDeviceAllocator,
                                DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkGetInstanceProcAddr, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html
    PFN_vkVoidFunction getProcAddr( char const * pName, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkGetInstanceProcAddr, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkGetInstanceProcAddr.html
    PFN_VoidFunction getProcAddr( std::string const & name, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_VERSION_1_1 ===

    // wrapper function for command vkEnumeratePhysicalDeviceGroups, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroups.html
    VULKAN_HPP_NODISCARD Result enumeratePhysicalDeviceGroups( uint32_t *                      pPhysicalDeviceGroupCount,
                                                               PhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumeratePhysicalDeviceGroups, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroups.html
    template <typename PhysicalDeviceGroupPropertiesAllocator = std::allocator<PhysicalDeviceGroupProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceGroupProperties, PhysicalDeviceGroupPropertiesAllocator>>::type
      enumeratePhysicalDeviceGroups( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumeratePhysicalDeviceGroups, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroups.html
    template <typename PhysicalDeviceGroupPropertiesAllocator = std::allocator<PhysicalDeviceGroupProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceGroupProperties, PhysicalDeviceGroupPropertiesAllocator>>::type
      enumeratePhysicalDeviceGroups( PhysicalDeviceGroupPropertiesAllocator const & physicalDeviceGroupPropertiesAllocator,
                                     DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_surface ===

    // wrapper function for command vkDestroySurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySurfaceKHR.html
    void destroySurfaceKHR( SurfaceKHR                  surface,
                            AllocationCallbacks const * pAllocator,
                            DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySurfaceKHR.html
    void destroySurfaceKHR( SurfaceKHR surface                            VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroySurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySurfaceKHR.html
    void destroy( SurfaceKHR                  surface,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroySurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroySurfaceKHR.html
    void destroy( SurfaceKHR                                    surface,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    //=== VK_KHR_display ===

    // wrapper function for command vkCreateDisplayPlaneSurfaceKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayPlaneSurfaceKHR.html
    VULKAN_HPP_NODISCARD Result createDisplayPlaneSurfaceKHR( DisplaySurfaceCreateInfoKHR const * pCreateInfo,
                                                              AllocationCallbacks const *         pAllocator,
                                                              SurfaceKHR *                        pSurface,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDisplayPlaneSurfaceKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayPlaneSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createDisplayPlaneSurfaceKHR( DisplaySurfaceCreateInfoKHR const &           createInfo,
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDisplayPlaneSurfaceKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDisplayPlaneSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createDisplayPlaneSurfaceKHRUnique( DisplaySurfaceCreateInfoKHR const &           createInfo,
                                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_XLIB_KHR )
    //=== VK_KHR_xlib_surface ===

    // wrapper function for command vkCreateXlibSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateXlibSurfaceKHR.html
    VULKAN_HPP_NODISCARD Result createXlibSurfaceKHR( XlibSurfaceCreateInfoKHR const * pCreateInfo,
                                                      AllocationCallbacks const *      pAllocator,
                                                      SurfaceKHR *                     pSurface,
                                                      DispatchLoader const & d         VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateXlibSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateXlibSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createXlibSurfaceKHR( XlibSurfaceCreateInfoKHR const &              createInfo,
                            Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                            DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateXlibSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateXlibSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createXlibSurfaceKHRUnique( XlibSurfaceCreateInfoKHR const &              createInfo,
                                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_XLIB_KHR*/

#if defined( VK_USE_PLATFORM_XCB_KHR )
    //=== VK_KHR_xcb_surface ===

    // wrapper function for command vkCreateXcbSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateXcbSurfaceKHR.html
    VULKAN_HPP_NODISCARD Result createXcbSurfaceKHR( XcbSurfaceCreateInfoKHR const * pCreateInfo,
                                                     AllocationCallbacks const *     pAllocator,
                                                     SurfaceKHR *                    pSurface,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateXcbSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateXcbSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createXcbSurfaceKHR( XcbSurfaceCreateInfoKHR const &               createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateXcbSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateXcbSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createXcbSurfaceKHRUnique( XcbSurfaceCreateInfoKHR const &               createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_XCB_KHR*/

#if defined( VK_USE_PLATFORM_WAYLAND_KHR )
    //=== VK_KHR_wayland_surface ===

    // wrapper function for command vkCreateWaylandSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateWaylandSurfaceKHR.html
    VULKAN_HPP_NODISCARD Result createWaylandSurfaceKHR( WaylandSurfaceCreateInfoKHR const * pCreateInfo,
                                                         AllocationCallbacks const *         pAllocator,
                                                         SurfaceKHR *                        pSurface,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateWaylandSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateWaylandSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createWaylandSurfaceKHR( WaylandSurfaceCreateInfoKHR const &           createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateWaylandSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateWaylandSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createWaylandSurfaceKHRUnique( WaylandSurfaceCreateInfoKHR const &           createInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_WAYLAND_KHR*/

#if defined( VK_USE_PLATFORM_ANDROID_KHR )
    //=== VK_KHR_android_surface ===

    // wrapper function for command vkCreateAndroidSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAndroidSurfaceKHR.html
    VULKAN_HPP_NODISCARD Result createAndroidSurfaceKHR( AndroidSurfaceCreateInfoKHR const * pCreateInfo,
                                                         AllocationCallbacks const *         pAllocator,
                                                         SurfaceKHR *                        pSurface,
                                                         DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateAndroidSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAndroidSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createAndroidSurfaceKHR( AndroidSurfaceCreateInfoKHR const &           createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateAndroidSurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateAndroidSurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createAndroidSurfaceKHRUnique( AndroidSurfaceCreateInfoKHR const &           createInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_ANDROID_KHR*/

#if defined( VK_USE_PLATFORM_WIN32_KHR )
    //=== VK_KHR_win32_surface ===

    // wrapper function for command vkCreateWin32SurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateWin32SurfaceKHR.html
    VULKAN_HPP_NODISCARD Result createWin32SurfaceKHR( Win32SurfaceCreateInfoKHR const * pCreateInfo,
                                                       AllocationCallbacks const *       pAllocator,
                                                       SurfaceKHR *                      pSurface,
                                                       DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateWin32SurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateWin32SurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createWin32SurfaceKHR( Win32SurfaceCreateInfoKHR const &             createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateWin32SurfaceKHR, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateWin32SurfaceKHR.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createWin32SurfaceKHRUnique( Win32SurfaceCreateInfoKHR const &             createInfo,
                                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_WIN32_KHR*/

    //=== VK_EXT_debug_report ===

    // wrapper function for command vkCreateDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugReportCallbackEXT.html
    VULKAN_HPP_NODISCARD Result createDebugReportCallbackEXT( DebugReportCallbackCreateInfoEXT const * pCreateInfo,
                                                              AllocationCallbacks const *              pAllocator,
                                                              DebugReportCallbackEXT *                 pCallback,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugReportCallbackEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DebugReportCallbackEXT>::type
      createDebugReportCallbackEXT( DebugReportCallbackCreateInfoEXT const &      createInfo,
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugReportCallbackEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DebugReportCallbackEXT>>::type
      createDebugReportCallbackEXTUnique( DebugReportCallbackCreateInfoEXT const &      createInfo,
                                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugReportCallbackEXT.html
    void destroyDebugReportCallbackEXT( DebugReportCallbackEXT      callback,
                                        AllocationCallbacks const * pAllocator,
                                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugReportCallbackEXT.html
    void destroyDebugReportCallbackEXT( DebugReportCallbackEXT callback               VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugReportCallbackEXT.html
    void destroy( DebugReportCallbackEXT      callback,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDebugReportCallbackEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugReportCallbackEXT.html
    void destroy( DebugReportCallbackEXT                        callback,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDebugReportMessageEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugReportMessageEXT.html
    void debugReportMessageEXT( DebugReportFlagsEXT      flags,
                                DebugReportObjectTypeEXT objectType,
                                uint64_t                 object,
                                size_t                   location,
                                int32_t                  messageCode,
                                char const *             pLayerPrefix,
                                char const *             pMessage,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDebugReportMessageEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkDebugReportMessageEXT.html
    void debugReportMessageEXT( DebugReportFlagsEXT      flags,
                                DebugReportObjectTypeEXT objectType,
                                uint64_t                 object,
                                size_t                   location,
                                int32_t                  messageCode,
                                std::string const &      layerPrefix,
                                std::string const &      message,
                                DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_GGP )
    //=== VK_GGP_stream_descriptor_surface ===

    // wrapper function for command vkCreateStreamDescriptorSurfaceGGP, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateStreamDescriptorSurfaceGGP.html
    VULKAN_HPP_NODISCARD Result createStreamDescriptorSurfaceGGP( StreamDescriptorSurfaceCreateInfoGGP const * pCreateInfo,
                                                                  AllocationCallbacks const *                  pAllocator,
                                                                  SurfaceKHR *                                 pSurface,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateStreamDescriptorSurfaceGGP, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateStreamDescriptorSurfaceGGP.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createStreamDescriptorSurfaceGGP( StreamDescriptorSurfaceCreateInfoGGP const &  createInfo,
                                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateStreamDescriptorSurfaceGGP, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateStreamDescriptorSurfaceGGP.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createStreamDescriptorSurfaceGGPUnique( StreamDescriptorSurfaceCreateInfoGGP const &  createInfo,
                                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_GGP*/

#if defined( VK_USE_PLATFORM_VI_NN )
    //=== VK_NN_vi_surface ===

    // wrapper function for command vkCreateViSurfaceNN, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateViSurfaceNN.html
    VULKAN_HPP_NODISCARD Result createViSurfaceNN( ViSurfaceCreateInfoNN const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   SurfaceKHR *                  pSurface,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateViSurfaceNN, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateViSurfaceNN.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createViSurfaceNN( ViSurfaceCreateInfoNN const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateViSurfaceNN, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateViSurfaceNN.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createViSurfaceNNUnique( ViSurfaceCreateInfoNN const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_VI_NN*/

    //=== VK_KHR_device_group_creation ===

    // wrapper function for command vkEnumeratePhysicalDeviceGroupsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroupsKHR.html
    VULKAN_HPP_NODISCARD Result enumeratePhysicalDeviceGroupsKHR( uint32_t *                      pPhysicalDeviceGroupCount,
                                                                  PhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties,
                                                                  DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkEnumeratePhysicalDeviceGroupsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroupsKHR.html
    template <typename PhysicalDeviceGroupPropertiesAllocator = std::allocator<PhysicalDeviceGroupProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceGroupProperties, PhysicalDeviceGroupPropertiesAllocator>>::type
      enumeratePhysicalDeviceGroupsKHR( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
    // wrapper function for command vkEnumeratePhysicalDeviceGroupsKHR, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumeratePhysicalDeviceGroupsKHR.html
    template <typename PhysicalDeviceGroupPropertiesAllocator = std::allocator<PhysicalDeviceGroupProperties>>
    VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<PhysicalDeviceGroupProperties, PhysicalDeviceGroupPropertiesAllocator>>::type
      enumeratePhysicalDeviceGroupsKHR( PhysicalDeviceGroupPropertiesAllocator const & physicalDeviceGroupPropertiesAllocator,
                                        DispatchLoader const & d                       VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_IOS_MVK )
    //=== VK_MVK_ios_surface ===

    // wrapper function for command vkCreateIOSSurfaceMVK, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIOSSurfaceMVK.html
    VULKAN_HPP_NODISCARD Result createIOSSurfaceMVK( IOSSurfaceCreateInfoMVK const * pCreateInfo,
                                                     AllocationCallbacks const *     pAllocator,
                                                     SurfaceKHR *                    pSurface,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateIOSSurfaceMVK, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIOSSurfaceMVK.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createIOSSurfaceMVK( IOSSurfaceCreateInfoMVK const &               createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateIOSSurfaceMVK, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateIOSSurfaceMVK.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createIOSSurfaceMVKUnique( IOSSurfaceCreateInfoMVK const &               createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_IOS_MVK*/

#if defined( VK_USE_PLATFORM_MACOS_MVK )
    //=== VK_MVK_macos_surface ===

    // wrapper function for command vkCreateMacOSSurfaceMVK, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMacOSSurfaceMVK.html
    VULKAN_HPP_NODISCARD Result createMacOSSurfaceMVK( MacOSSurfaceCreateInfoMVK const * pCreateInfo,
                                                       AllocationCallbacks const *       pAllocator,
                                                       SurfaceKHR *                      pSurface,
                                                       DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateMacOSSurfaceMVK, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMacOSSurfaceMVK.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createMacOSSurfaceMVK( MacOSSurfaceCreateInfoMVK const &             createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateMacOSSurfaceMVK, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMacOSSurfaceMVK.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createMacOSSurfaceMVKUnique( MacOSSurfaceCreateInfoMVK const &             createInfo,
                                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_MACOS_MVK*/

    //=== VK_EXT_debug_utils ===

    // wrapper function for command vkCreateDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugUtilsMessengerEXT.html
    VULKAN_HPP_NODISCARD Result createDebugUtilsMessengerEXT( DebugUtilsMessengerCreateInfoEXT const * pCreateInfo,
                                                              AllocationCallbacks const *              pAllocator,
                                                              DebugUtilsMessengerEXT *                 pMessenger,
                                                              DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugUtilsMessengerEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<DebugUtilsMessengerEXT>::type
      createDebugUtilsMessengerEXT( DebugUtilsMessengerCreateInfoEXT const &      createInfo,
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDebugUtilsMessengerEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<DebugUtilsMessengerEXT>>::type
      createDebugUtilsMessengerEXTUnique( DebugUtilsMessengerCreateInfoEXT const &      createInfo,
                                          Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                          DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugUtilsMessengerEXT.html
    void destroyDebugUtilsMessengerEXT( DebugUtilsMessengerEXT      messenger,
                                        AllocationCallbacks const * pAllocator,
                                        DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugUtilsMessengerEXT.html
    void destroyDebugUtilsMessengerEXT( DebugUtilsMessengerEXT messenger              VULKAN_HPP_DEFAULT_ASSIGNMENT( {} ),
                                        Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                        DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkDestroyDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugUtilsMessengerEXT.html
    void destroy( DebugUtilsMessengerEXT      messenger,
                  AllocationCallbacks const * pAllocator,
                  DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkDestroyDebugUtilsMessengerEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkDestroyDebugUtilsMessengerEXT.html
    void destroy( DebugUtilsMessengerEXT                        messenger,
                  Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                  DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

    // wrapper function for command vkSubmitDebugUtilsMessageEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSubmitDebugUtilsMessageEXT.html
    void submitDebugUtilsMessageEXT( DebugUtilsMessageSeverityFlagBitsEXT       messageSeverity,
                                     DebugUtilsMessageTypeFlagsEXT              messageTypes,
                                     DebugUtilsMessengerCallbackDataEXT const * pCallbackData,
                                     DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkSubmitDebugUtilsMessageEXT, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkSubmitDebugUtilsMessageEXT.html
    void submitDebugUtilsMessageEXT( DebugUtilsMessageSeverityFlagBitsEXT       messageSeverity,
                                     DebugUtilsMessageTypeFlagsEXT              messageTypes,
                                     DebugUtilsMessengerCallbackDataEXT const & callbackData,
                                     DispatchLoader const & d                   VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_FUCHSIA )
    //=== VK_FUCHSIA_imagepipe_surface ===

    // wrapper function for command vkCreateImagePipeSurfaceFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImagePipeSurfaceFUCHSIA.html
    VULKAN_HPP_NODISCARD Result createImagePipeSurfaceFUCHSIA( ImagePipeSurfaceCreateInfoFUCHSIA const * pCreateInfo,
                                                               AllocationCallbacks const *               pAllocator,
                                                               SurfaceKHR *                              pSurface,
                                                               DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateImagePipeSurfaceFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImagePipeSurfaceFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createImagePipeSurfaceFUCHSIA( ImagePipeSurfaceCreateInfoFUCHSIA const &     createInfo,
                                     Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                     DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateImagePipeSurfaceFUCHSIA, see
    // https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateImagePipeSurfaceFUCHSIA.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createImagePipeSurfaceFUCHSIAUnique( ImagePipeSurfaceCreateInfoFUCHSIA const &     createInfo,
                                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_FUCHSIA*/

#if defined( VK_USE_PLATFORM_METAL_EXT )
    //=== VK_EXT_metal_surface ===

    // wrapper function for command vkCreateMetalSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMetalSurfaceEXT.html
    VULKAN_HPP_NODISCARD Result createMetalSurfaceEXT( MetalSurfaceCreateInfoEXT const * pCreateInfo,
                                                       AllocationCallbacks const *       pAllocator,
                                                       SurfaceKHR *                      pSurface,
                                                       DispatchLoader const & d          VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateMetalSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMetalSurfaceEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createMetalSurfaceEXT( MetalSurfaceCreateInfoEXT const &             createInfo,
                             Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                             DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateMetalSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateMetalSurfaceEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createMetalSurfaceEXTUnique( MetalSurfaceCreateInfoEXT const &             createInfo,
                                   Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                   DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_METAL_EXT*/

    //=== VK_EXT_headless_surface ===

    // wrapper function for command vkCreateHeadlessSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateHeadlessSurfaceEXT.html
    VULKAN_HPP_NODISCARD Result createHeadlessSurfaceEXT( HeadlessSurfaceCreateInfoEXT const * pCreateInfo,
                                                          AllocationCallbacks const *          pAllocator,
                                                          SurfaceKHR *                         pSurface,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateHeadlessSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateHeadlessSurfaceEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createHeadlessSurfaceEXT( HeadlessSurfaceCreateInfoEXT const &          createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateHeadlessSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateHeadlessSurfaceEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createHeadlessSurfaceEXTUnique( HeadlessSurfaceCreateInfoEXT const &          createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

#if defined( VK_USE_PLATFORM_DIRECTFB_EXT )
    //=== VK_EXT_directfb_surface ===

    // wrapper function for command vkCreateDirectFBSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDirectFBSurfaceEXT.html
    VULKAN_HPP_NODISCARD Result createDirectFBSurfaceEXT( DirectFBSurfaceCreateInfoEXT const * pCreateInfo,
                                                          AllocationCallbacks const *          pAllocator,
                                                          SurfaceKHR *                         pSurface,
                                                          DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateDirectFBSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDirectFBSurfaceEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createDirectFBSurfaceEXT( DirectFBSurfaceCreateInfoEXT const &          createInfo,
                                Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateDirectFBSurfaceEXT, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateDirectFBSurfaceEXT.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createDirectFBSurfaceEXTUnique( DirectFBSurfaceCreateInfoEXT const &          createInfo,
                                      Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                      DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_DIRECTFB_EXT*/

#if defined( VK_USE_PLATFORM_SCREEN_QNX )
    //=== VK_QNX_screen_surface ===

    // wrapper function for command vkCreateScreenSurfaceQNX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateScreenSurfaceQNX.html
    VULKAN_HPP_NODISCARD Result createScreenSurfaceQNX( ScreenSurfaceCreateInfoQNX const * pCreateInfo,
                                                        AllocationCallbacks const *        pAllocator,
                                                        SurfaceKHR *                       pSurface,
                                                        DispatchLoader const & d           VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateScreenSurfaceQNX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateScreenSurfaceQNX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createScreenSurfaceQNX( ScreenSurfaceCreateInfoQNX const &            createInfo,
                              Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                              DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateScreenSurfaceQNX, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateScreenSurfaceQNX.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createScreenSurfaceQNXUnique( ScreenSurfaceCreateInfoQNX const &            createInfo,
                                    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_SCREEN_QNX*/

#if defined( VK_USE_PLATFORM_OHOS )
    //=== VK_OHOS_surface ===

    // wrapper function for command vkCreateSurfaceOHOS, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSurfaceOHOS.html
    VULKAN_HPP_NODISCARD Result createSurfaceOHOS( SurfaceCreateInfoOHOS const * pCreateInfo,
                                                   AllocationCallbacks const *   pAllocator,
                                                   SurfaceKHR *                  pSurface,
                                                   DispatchLoader const & d      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateSurfaceOHOS, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSurfaceOHOS.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createSurfaceOHOS( SurfaceCreateInfoOHOS const &                 createInfo,
                         Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                         DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateSurfaceOHOS, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateSurfaceOHOS.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createSurfaceOHOSUnique( SurfaceCreateInfoOHOS const &                 createInfo,
                               Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                               DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_OHOS*/

#if defined( VK_USE_PLATFORM_UBM_SEC )
    //=== VK_SEC_ubm_surface ===

    // wrapper function for command vkCreateUbmSurfaceSEC, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateUbmSurfaceSEC.html
    VULKAN_HPP_NODISCARD Result createUbmSurfaceSEC( UbmSurfaceCreateInfoSEC const * pCreateInfo,
                                                     AllocationCallbacks const *     pAllocator,
                                                     SurfaceKHR *                    pSurface,
                                                     DispatchLoader const & d        VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const VULKAN_HPP_NOEXCEPT;
#  ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
    // wrapper function for command vkCreateUbmSurfaceSEC, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateUbmSurfaceSEC.html
    VULKAN_HPP_NODISCARD typename ResultValueType<SurfaceKHR>::type
      createUbmSurfaceSEC( UbmSurfaceCreateInfoSEC const &               createInfo,
                           Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                           DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    ifndef VULKAN_HPP_NO_SMART_HANDLE
    // wrapper function for command vkCreateUbmSurfaceSEC, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateUbmSurfaceSEC.html
    VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<SurfaceKHR>>::type
      createUbmSurfaceSECUnique( UbmSurfaceCreateInfoSEC const &               createInfo,
                                 Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
                                 DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) const;
#    endif /* VULKAN_HPP_NO_SMART_HANDLE */
#  endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */
#endif     /*VK_USE_PLATFORM_UBM_SEC*/

    operator VkInstance() const VULKAN_HPP_NOEXCEPT
    {
      return m_instance;
    }

    explicit operator bool() const VULKAN_HPP_NOEXCEPT
    {
      return m_instance != VK_NULL_HANDLE;
    }

    bool operator!() const VULKAN_HPP_NOEXCEPT
    {
      return m_instance == VK_NULL_HANDLE;
    }

  private:
    VkInstance m_instance = {};
  };

  template <>
  struct CppType<ObjectType, ObjectType::eInstance>
  {
    using Type = Instance;
  };

  template <>
  struct CppType<DebugReportObjectTypeEXT, DebugReportObjectTypeEXT::eInstance>
  {
    using Type = Instance;
  };

#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )
  template <>
  struct CppType<VkInstance, VK_NULL_HANDLE>
  {
    using Type = Instance;
  };
#endif

  template <>
  struct isVulkanHandleType<Instance>
  {
    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;
  };

  //=== VK_VERSION_1_0 ===

  // wrapper function for command vkCreateInstance, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateInstance.html
  VULKAN_HPP_NODISCARD Result createInstance( InstanceCreateInfo const *  pCreateInfo,
                                              AllocationCallbacks const * pAllocator,
                                              Instance *                  pInstance,
                                              DispatchLoader const & d    VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  // wrapper function for command vkCreateInstance, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateInstance.html
  VULKAN_HPP_NODISCARD typename ResultValueType<Instance>::type createInstance(
    InstanceCreateInfo const &                    createInfo,
    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
#  ifndef VULKAN_HPP_NO_SMART_HANDLE
  // wrapper function for command vkCreateInstance, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkCreateInstance.html
  VULKAN_HPP_NODISCARD typename ResultValueType<UniqueHandle<Instance>>::type createInstanceUnique(
    InstanceCreateInfo const &                    createInfo,
    Optional<AllocationCallbacks const> allocator VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ),
    DispatchLoader const & d                      VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
#  endif /* VULKAN_HPP_NO_SMART_HANDLE */
#endif   /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

  // wrapper function for command vkEnumerateInstanceExtensionProperties, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html
  VULKAN_HPP_NODISCARD Result enumerateInstanceExtensionProperties(
    char const * pLayerName, uint32_t * pPropertyCount, ExtensionProperties * pProperties, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT )
    VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  // wrapper function for command vkEnumerateInstanceExtensionProperties, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html
  template <typename ExtensionPropertiesAllocator = std::allocator<ExtensionProperties>>
  VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<ExtensionProperties, ExtensionPropertiesAllocator>>::type enumerateInstanceExtensionProperties(
    Optional<std::string const> layerName VULKAN_HPP_DEFAULT_ASSIGNMENT( nullptr ), DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
  // wrapper function for command vkEnumerateInstanceExtensionProperties, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceExtensionProperties.html
  template <typename ExtensionPropertiesAllocator = std::allocator<ExtensionProperties>>
  VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<ExtensionProperties, ExtensionPropertiesAllocator>>::type enumerateInstanceExtensionProperties(
    Optional<std::string const>          layerName,
    ExtensionPropertiesAllocator const & extensionPropertiesAllocator,
    DispatchLoader const & d             VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

  // wrapper function for command vkEnumerateInstanceLayerProperties, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceLayerProperties.html
  VULKAN_HPP_NODISCARD Result enumerateInstanceLayerProperties(
    uint32_t * pPropertyCount, LayerProperties * pProperties, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT ) VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  // wrapper function for command vkEnumerateInstanceLayerProperties, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceLayerProperties.html
  template <typename LayerPropertiesAllocator = std::allocator<LayerProperties>>
  VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<LayerProperties, LayerPropertiesAllocator>>::type enumerateInstanceLayerProperties(
    DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
  // wrapper function for command vkEnumerateInstanceLayerProperties, see
  // https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceLayerProperties.html
  template <typename LayerPropertiesAllocator = std::allocator<LayerProperties>>
  VULKAN_HPP_NODISCARD typename ResultValueType<std::vector<LayerProperties, LayerPropertiesAllocator>>::type enumerateInstanceLayerProperties(
    LayerPropertiesAllocator const & layerPropertiesAllocator, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

  //=== VK_VERSION_1_1 ===

  // wrapper function for command vkEnumerateInstanceVersion, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceVersion.html
  VULKAN_HPP_NODISCARD Result enumerateInstanceVersion( uint32_t * pApiVersion, DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT )
    VULKAN_HPP_NOEXCEPT;
#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE
  // wrapper function for command vkEnumerateInstanceVersion, see https://registry.khronos.org/vulkan/specs/latest/man/html/vkEnumerateInstanceVersion.html
  VULKAN_HPP_NODISCARD typename ResultValueType<uint32_t>::type enumerateInstanceVersion( DispatchLoader const & d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT );
#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */

  // operators to compare VULKAN_HPP_NAMESPACE::-handles
  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator==( T const & lhs, T const & rhs )
  {
    return static_cast<typename T::NativeType>( lhs ) == static_cast<typename T::NativeType>( rhs );
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator!=( T const & lhs, T const & rhs )
  {
    return static_cast<typename T::NativeType>( lhs ) != static_cast<typename T::NativeType>( rhs );
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator<( T const & lhs, T const & rhs )
  {
    return static_cast<typename T::NativeType>( lhs ) < static_cast<typename T::NativeType>( rhs );
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator<=( T const & lhs, T const & rhs )
  {
    return static_cast<typename T::NativeType>( lhs ) <= static_cast<typename T::NativeType>( rhs );
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator>( T const & lhs, T const & rhs )
  {
    return static_cast<typename T::NativeType>( lhs ) > static_cast<typename T::NativeType>( rhs );
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator>=( T const & lhs, T const & rhs )
  {
    return static_cast<typename T::NativeType>( lhs ) >= static_cast<typename T::NativeType>( rhs );
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator==( T const & v, std::nullptr_t )
  {
    return !v;
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator==( std::nullptr_t, T const & v )
  {
    return !v;
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator!=( T const & v, std::nullptr_t )
  {
    return !!v;
  }

  template <typename T, typename std::enable_if<isVulkanHandleType<T>::value, int>::type = 0>
  bool operator!=( std::nullptr_t, T const & v )
  {
    return !!v;
  }
}  // namespace VULKAN_HPP_NAMESPACE
#endif
